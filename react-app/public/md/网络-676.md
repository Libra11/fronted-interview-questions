# 列表分页， 快速翻页下的竞态问题【热度: 444】

**关键词**：翻页场景竞态问题

**列表分页， 快速翻页下的竞态问题**

> 问题描述：比如在前端分页请求的时候， 因为翻页很快， 所以请求还没有来得及回来的时候， 就发起了下一次请求， 且请求返回的时间也是不固定的。 
> 如何保证最后一次请求结果和其请求页码是对应上的。

在处理这种情况时，一种常见的方法是使用请求标记或唯一标识符来确保请求和结果之间的对应关系。

以下是一个示例代码片段，展示了一种可能的解决方案：

```javascript
// 存储请求的标记
let requestId = 0;

// 发起请求的函数
function sendRequest(page) {
  requestId++;

  // 将请求标记与页码一起发送
  fetch(`/api?requestId=${requestId}&page=${page}`)

   .then(response => response.json())

   .then(data => {
      // 根据请求标记处理返回的数据
      handleResponseData(requestId, data);
    });
}

// 处理返回数据的函数
function handleResponseData(requestId, data) {
  if (requestId === currentRequestId) {
    // 在这里处理数据并更新页面
  }
}

// 在翻页时调用 sendRequest 函数
```

在这个示例中，每次发起请求时都会增加请求标记 `requestId`，并将其与页码一起发送到服务器。在处理返回的数据时，根据请求标记来确保与当前的请求对应。

另外，还可以考虑以下几点：
- 对快速翻页进行限制或优化，避免过于频繁的请求。
- 在服务器端处理请求时，可以根据请求标记来保证返回的数据与特定的请求相关联。
- 可以使用缓存来存储部分数据，减少不必要的请求。

**保证唯一性**

保证请求标记的唯一性可以通过以下几种方式：
1. 使用递增的数字：就像上面示例中的 `requestId` 一样，每次增加 1。
2. 使用随机数：生成一个随机的数字作为请求标记。
3. 使用时间戳：结合当前时间生成唯一的标记。
4. 组合多种因素：例如，将数字、时间戳或其他相关信息组合起来创建唯一标记。

例如，使用时间戳作为请求标记的示例代码如下：

```javascript
let requestId = Date.now();
```
这样每次请求时，`requestId` 都会是一个唯一的时间戳值。



## Comments / Answers

---

**frontbyby** at 2024-08-23T01:28:51Z

为什么不用AbortControl 来取消请求呢