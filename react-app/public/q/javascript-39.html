<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JS 中 this 指向问题了解多少？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h1&gt;关于 this 指针的研究&lt;/h1&gt;&lt;h2&gt;基础实例说明&lt;/h2&gt;&lt;p&gt;实例1：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt; var name = &amp;quot;Kevin Ya" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="JS 中 this 指向问题了解多少？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h1&gt;关于 this 指针的研究&lt;/h1&gt;&lt;h2&gt;基础实例说明&lt;/h2&gt;&lt;p&gt;实例1：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt; var name = &amp;quot;Kevin Yang&amp;quot;; function sayHi(){ console.log(&amp;quot;你好，我的名字叫&amp;quot;" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/39" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>JS 中 this 指向问题了解多少？</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-09T14:58:41Z · 更新：2023-05-31T14:27:18Z</div>
    </div>
    <article class="content markdown-body"><h1>关于 this 指针的研究</h1><h2>基础实例说明</h2><p>实例1：</p><pre class="code-block"><code class="language-html">&lt;script&gt;
    var name = &quot;Kevin Yang&quot;;
    function sayHi(){
        console.log(&quot;你好，我的名字叫&quot; + this.name);
    }
    sayHi()
&lt;/script&gt;
</code></pre><p>如果在html 端， 这个this.name 是可以调用全局对象name的， 这个this实际上是指向的window的， var 也是把变量挂在到window对象上面的。</p><p>但是同样的这个实例如果放在node 端，就是一个undefined ,原因是node端没有window对象。</p><p>实例2：</p><pre class="code-block"><code class="language-javascript">var name = &quot;Kevin Yang&quot;;   
function sayHi(){     
    console.log(&quot;你好，我的名字叫&quot; + this.name);   
}   
var person = {};   
person.sayHello = sayHi;   
person.sayHello(); 
</code></pre><p>这一次打招呼的内容就有点无厘头了，我们发现this.name已经变成undefined了。这说明，在sayHello函数内部执行时已经找不着this.name对象了。,原因是这儿时候，this指向的person 对象，但是this对象上面是没有name属性的。</p><p>如果改为这样 <code>var person = {name:&quot;Marry&quot;};</code> 就可以得到我们想要的内容了。</p><h2>判别this指针的指导性原则</h2><p><strong>在Javascript里面，this指针代表的是执行当前代码的对象的所有者。</strong></p><p>在上面的示例中我们可以看到，第一次，我们定义了一个全局函数对象sayHi并执行了这个函数，函数内部使用了this关键字，</p><p>那么执行this这 行代码的对象是sayHi（一切皆对象的体现），sayHi是被定义在全局作用域中。其实在Javascript中所谓的全局对象，</p><p>无非是定义在 window这个根对象下的一个属性而已。因此，sayHi的所有者是window对象。也就是说，在全局作用域下，</p><p>你可以通过直接使用name去引用这 个对象，你也可以通过window.name去引用同一个对象。因而<strong>this.name就可以翻译为window.name了</strong>。</p><p>再来看第二个this的示例。第一次，person里面没有name属性，因此弹 出的对话框就是this.name引用的就是undefined对象</p><p>（Javascript中所有只声明而没有定义的变量全都指向undefined对象）；</p><p>而第二次我们在定义person的时候加了name属性了，那么this.name指向的自然就是我们定义的字符串了。</p><p>理解了上面所说的之后，我们将上面最后一段示例改造成面向对象式的代码。</p><pre class="code-block"><code class="language-javascript">var name = &quot;Kevin Yang&quot;;   
function sayHi(){     
    console.log(&quot;你好，我的名字叫&quot; + this.name);   
}  
function Person(name){     
    this.name = name;   
}   
Person.prototype.sayHello = sayHi;   
var marry = new Person(&quot;Marry&quot;);     
marry.sayHello();   
var kevin = new Person(&quot;Kevin&quot;);   
kevin.sayHello(); 
</code></pre><h2>容易误用的情况</h2><h3>示例1——内联式绑定Dom元素的事件处理函数</h3><pre class="code-block"><code class="language-html">&lt;body&gt;
&lt;input id=&quot;btnTest&quot; type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;sayHi()&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;   
	function sayHi(){     
		alert(&quot;当前点击的元素是&quot; + this.tagName);  
	}   
&lt;/script&gt; 
&lt;/body&gt;
</code></pre><p>在此例代码中，我们绑定了button的点击事件，期望在弹出的对话框中打印出点击元素的标签名。但运行结果却是： 当前点击的元素是 undefined</p><p>也就是this指针并不是指向input元素。这是因为当使用内联式绑定Dom元素的事件处理函数时，实际上相当于执行了以下代码：</p><p>在这种情况下sayHi函数对象的所有权并没有发生转移，<strong>还是属于window所有</strong>。用上面的指导原则一套我们就很好理解为什么this.tagName是undefined了。</p><p>那么如果我们要引用元素本身怎么办呢？</p><p>我们知道，onclick函数是属于btnTest元素的，那么在此函数内部，this指针正是指向此Dom对象，于是我们只需要把this作为参数传入sayHi即可。</p><pre class="code-block"><code class="language-html">&lt;input id=&quot;btnTest&quot; type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;sayHi(this)&quot;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;   
	function sayHi(el){     
		alert(&quot;当前点击的元素是&quot; + el.tagName);   } 
&lt;/script&gt; 
</code></pre><p>等价代码如下：</p><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;    
	document.getElementById(&quot;btnTest&quot;).onclick = function(){     sayHi(this);   } 
&lt;/script&gt;
</code></pre><h3>示例2——临时变量导致的this指针丢失</h3><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;   
	var Utility = {     
		decode:function(str){       return unescape(str);     },     
		getCookie:function(key){       
			// ... 省略提取cookie字符串的代码       
			var value = &quot;i%27m%20a%20cookie&quot;;       
			return this.decode(value);     
		}   
	};   
	console.log(Utility.getCookie(&quot;identity&quot;)) 
&lt;/script&gt;
</code></pre><p>一般都会自己封装一个Utility的类，然后将一些常用的函数作为Utility类的属性，如客户端经常会 用到的getCookie函数和解码函数。</p><p>如果每个函数都是彼此独立的，那么还好办，问题是，函数之间有时候会相互引用。例如上面的getCookie函 数，</p><p>会对从document.cookie中提取到的字符串进行decode之后再返回。如果我们通过Utility.getCookie去调用的话，那 么没有问题，</p><p>我们知道，getCookie内部的this指针指向的还是Utility对象，而Utility对象时包含decode属性的。代码可以成 功执行。</p><p>但是有个人不小心这样使用Utility对象呢？</p><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;   
	function showUserIdentity(){     
		// 保存getCookie函数到一个局部变量，因为下面会经常用到     
		var getCookie = Utility.getCookie;     
		alert(getCookie(&quot;identity&quot;));   
	}   
	showUserIdentity(); 
&lt;/script&gt;
</code></pre><p>这个时候运行代码会抛出异常“this.decode is not a function”。</p><p>运用上面我们讲到的指导原则，很好理解，因为此时Utility.getCookie对象被赋给了临时变量getCookie，</p><p>而临 时变量是属于window对象的——只不过外界不能直接引用，只对Javascript引擎可见——于是在getCookie函数内部的this指针指向 的就是window对象了，</p><p>而window对象没有定义一个decode的函数对象，因此就会抛出这样的异常来。</p><p>这个问题是由于引入了临时变量导致的this指针的转移。解决此问题的办法有几个：</p><p>不引入临时变量，每次使用均使用Utility.getCookie进行调用</p><p>getCookie函数内部使用Utility.decode显式引用decode对象而不通过this指针隐式引用（如果Utility是一个实例化的对象，也即是通过new生成的，那么此法不可用）</p><p><strong>使用Funtion.apply或者Function.call函数指定this指针</strong></p><p>第三种使用apply 和 call 修正的办法实例如下：</p><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;   
	function showUserIdentity(){     
		// 保存getCookie函数到一个局部变量，因为下面会经常用到     
		var getCookie = Utility.getCookie;     
		alert(getCookie.call(Utility,&quot;identity&quot;));     
		alert(getCookie.apply(Utility,[&quot;identity&quot;]));   
	}   
	showUserIdentity(); 
&lt;/script&gt;
</code></pre><h3>示例3——函数传参时导致的this指针丢失</h3><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;   
	var person = {     
		name:&quot;Kevin Yang&quot;,     
		sayHi:function(){       
			alert(&quot;你好，我是&quot;+this.name);     
		}   
	}   
	setTimeout(person.sayHi,5000); 
&lt;/script&gt;
</code></pre><p>这段代码期望在访客进入页面5秒钟之后向访客打声招呼。setTimeout函数接收一个函数作为参数，并在指定的触发时刻执行这个函数。</p><p>可是，当我们等了5秒钟之后，弹出的对话框显示的this.name却是undefined。</p><p>其实这个问题和上一个示例中的问题是类似的，都是因为临时变量而导致的问题。</p><p>当我们执行函数的时候，如果函数带有参数，那么这个时候Javascript引擎会创建一个临时变量，</p><p>并将传入的参数复制（注意，Javascript里面都是值传递的，没有引用传递的概念）给此临时变量。</p><p>也就是说，整个过程就跟上面我们定义了一个getCookie的临时变量，再将Utility.getCookie赋值给这个临时变量一样。只不过在这个示例中，容易忽视临时变量导致的bug。</p><h2>函数对象传参</h2><p>Prototype的解决方案——传参之前使用bind方法将函数封装起来，并返回封装后的对象</p><pre class="code-block"><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;   
	var person = {    
		name:&quot;Kevin Yang&quot;,     
		sayHi:function(){       
			alert(&quot;你好，我是&quot;+this.name);     
		}   
	}   
	var boundFunc = person.sayHi.bind(person,person.sayHi);   
	setTimeout(boundFunc,5000); 
&lt;/script&gt;
</code></pre><p>bind方法的实现其实是用到了Javascript又一个高级特性——<strong>闭包</strong>。我们来看一下源代码：</p><pre class="code-block"><code class="language-javascript">function bind(){  
	if (arguments.length &lt; 2 &amp;&amp; arguments[0] === undefined)      
		return this;   
	var __method = this, args = $A(arguments), object = args.shift();   
	return function(){     return __method.apply(object, args.concat($A(arguments)));   } 
}
</code></pre><p>首先将this指针存入函数内部临时变量，然后在返回的函数对象中引用此临时变量从而形成闭包。</p><h2>变化的this</h2><p>在JavaScript中，this通常 指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）。</p><p>当我们在页面中定义了函数 doSomething()的时候，它的owner是页面，或者是JavaScript中的window对象（或 global对象）。</p><p>对于一个onclick属性，它为它所属的HTML元素所拥有，this应该指向该HTML元素。</p><p>在几种常见场景中this的变化</p><p>```javascript</p><p>function doSomething () {</p><p>alert(this.navigator); //appCodeName</p><p>this.value = "I am from the Object constructor";</p><p>this.style.backgroundColor = "# 000000";</p><p>}</p><pre class="code-block"><code>- 作为普通函数直接调用时，this指向window对象.                                   
- 作为控件事件触发时                                     
    - inline event registration 内联事件注册 .将事件直接写在HTML代码中(&lt;element onclick=”doSomething()”&gt;), 此时this指向 window对象 。                          
    - Traditional event registration 传统事件注册 （DHTML方式）. 形如 element.onclick = doSomething; 此时this指向 element对象                         
    - &lt;element onclick=”doSomething(this)”&gt;作为参数传递可以指向element                            
- 作为对象使用时this指向当前对象。形如：new doSomething();                       
- 使用apply 或者call方法时，this指向所传递的对象。 形如：var obj={}; doSomething.apply(obj,new Array(”nothing”));                        


## 接下来文章中我们将要讨论的问题是：在函数doSomething()中this所指的是什么？ 
</code></pre><p>function doSomething() {</p><p>this.style.color = '#cc0000';</p><p>}</p><pre class="code-block"><code>在 JavaScript中，this通常指向的是我们正在执行的函数本身（译者注：用owner代表this所指向的内容），或者是，指向该函数所属的对 象。
当我们在页面中定义了函数doSomething()的时候，它的owner是页面，或者是JavaScript中的window对象（或 global对象）。
对于一个onclick属性，它为它所属的HTML元素所拥有，this应该指向该HTML元素。                          
这种“所有权”就是JavaScript中面向对象的一种方式。在Objects as associative arrays中可以查看一些更多的信息。
![11_02](https://user-images.githubusercontent.com/22188674/224062543-ec8a9e13-6a90-400b-a54d-16dfc33c64fc.gif)                 


## 总结 
怎样在一个代码环境中快速的找到this所指的对象呢？                      
- 1、 要清楚的知道对于函数的每一步操作是拷贝还是引用（调用）                        
- 2、 要清楚的知道函数的拥有者（owner）是什么                         
- 3、 对于一个function，我们要搞清楚我们是把它当作函数使用还是在当作类使用                             







## Comments / Answers

---

**yanlele** at 2023-05-31T14:27:17Z

补充一个图：

![image](https://github.com/pro-collection/interview-question/assets/22188674/15ef65da-6ccb-42c0-8c0e-170f8187d71f)
</article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>