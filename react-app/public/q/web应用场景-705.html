<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>滚动混动加载原理是什么， 用 JS 代码简单实现一个虚拟滚动加加载。【热度: 354】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：虚拟滚动、虚拟加载&lt;/p&gt;&lt;h3&gt;原理&lt;/h3&gt;&lt;p&gt;虚拟滚动（Virtual Scrolling）是一种性能优化的手段，通常用于处理长列表的显示问题。在传统的滚动加载中，当面对成千上万项的长列表时，直接在 DOM 中创建并展示所有" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="滚动混动加载原理是什么， 用 JS 代码简单实现一个虚拟滚动加加载。【热度: 354】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：虚拟滚动、虚拟加载&lt;/p&gt;&lt;h3&gt;原理&lt;/h3&gt;&lt;p&gt;虚拟滚动（Virtual Scrolling）是一种性能优化的手段，通常用于处理长列表的显示问题。在传统的滚动加载中，当面对成千上万项的长列表时，直接在 DOM 中创建并展示所有项会导致严重的性能问题，因为浏览器需要渲染所有的列表项。而虚拟滚动的核心原理是仅渲染用户可视范围内的列表项，以此减少 D" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/705" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>滚动混动加载原理是什么， 用 JS 代码简单实现一个虚拟滚动加加载。【热度: 354】</h1>
      <div class="subtitle">web应用场景 · web应用场景 · 小红书</div>
      <div class="meta">创建：2024-04-19T14:50:22Z · 更新：2024-09-15T06:48:38Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：虚拟滚动、虚拟加载</p><h3>原理</h3><p>虚拟滚动（Virtual Scrolling）是一种性能优化的手段，通常用于处理长列表的显示问题。在传统的滚动加载中，当面对成千上万项的长列表时，直接在 DOM 中创建并展示所有项会导致严重的性能问题，因为浏览器需要渲染所有的列表项。而虚拟滚动的核心原理是仅渲染用户可视范围内的列表项，以此减少 DOM 操作的数量和提高性能。</p><p>实现虚拟滚动，我们需要：</p><ol><li>监听滚动事件，了解当前滚动位置。</li><li>根据滚动位置计算当前应该渲染哪些列表项目（即在视口内的项目）。</li><li>只渲染那些项目，并用占位符（比如一个空的 div）占据其它项目应有的位置，保持滚动条大小不变。</li><li>当用户滚动时，重新计算并渲染新的项目。</li></ol><h3>基础版本实现</h3><p>以下是一个简单的虚拟滚动实现的 JavaScript 代码示例：</p><pre class="code-block"><code class="language-javascript">class VirtualScroll {
  constructor(container, itemHeight, totalItems, renderCallback) {
    this.container = container; // 容器元素
    this.itemHeight = itemHeight; // 每个项的高度
    this.totalItems = totalItems; // 总列表项数
    this.renderCallback = renderCallback; // 渲染每一项的回调函数

    this.viewportHeight = container.clientHeight; // 视口高度
    this.bufferSize = Math.ceil(this.viewportHeight / itemHeight) * 3; // 缓冲大小
    this.renderedItems = []; // 已渲染项的数组

    this.startIndex = 0; // 当前渲染的开始索引
    this.endIndex = this.bufferSize; // 当前渲染的结束索引

    container.addEventListener(&quot;scroll&quot;, () =&gt; this.onScroll());
    this.update();
  }

  onScroll() {
    const scrollTop = this.container.scrollTop;
    const newStartIndex = Math.floor(scrollTop / this.itemHeight) - this.bufferSize / 2;
    const newEndIndex = newStartIndex + this.bufferSize;

    if (newStartIndex !== this.startIndex || newEndIndex !== this.endIndex) {
      this.startIndex = Math.max(0, newStartIndex);
      this.endIndex = Math.min(this.totalItems, newEndIndex);
      this.update();
    }
  }

  update() {
    // 清空已有内容
    this.container.innerHTML = &quot;&quot;;

    // 计算并设置容器的总高度
    const totalHeight = this.totalItems * this.itemHeight;
    this.container.style.height = `${totalHeight}px`;

    // 渲染视口内的项
    const fragment = document.createDocumentFragment();
    for (let i = this.startIndex; i &lt; this.endIndex; i++) {
      const item = this.renderCallback(i);
      item.style.top = `${i * this.itemHeight}px`;
      fragment.appendChild(item);
    }
    this.container.appendChild(fragment);
  }
}

// 创建一个列表项的函数
function createItem(index) {
  const item = document.createElement(&quot;div&quot;);
  item.className = &quot;list-item&quot;;
  item.innerText = `Item ${index}`;
  item.style.position = &quot;absolute&quot;;
  item.style.width = &quot;100%&quot;;
  return item;
}

// 初始化虚拟滚动
const container = document.querySelector(&quot;.scroll-container&quot;); // 容器元素需要预先在HTML中定义
const virtualScroll = new VirtualScroll(container, 30, 10000, createItem);
</code></pre><p>这个例子中，我们创建了一个<code>VirtualScroll</code>类，通过传入容器、项高度、总项数和渲染回调函数来进行初始化。该类的<code>update</code>方法用于渲染出当前可视范围内部分的项目，并将它们放到文档碎片中，然后一次性添加到容器中。这样可以避免多次直接操作 DOM，减少性能消耗。当滚动时，<code>onScroll</code>方法将计算新的<code>startIndex</code>和<code>endIndex</code>，然后调用<code>update</code>方法进行更新。请注意，实际应用可能需要根据具体情况调整缓冲区大小等参数。</p><h3>进阶版本：使用 IntersectionObserver 来实现</h3><p>使用 <code>IntersectionObserver</code> 实现虚拟滚动就意味着我们会依赖于浏览器的 API 来观察哪些元素进入或离开视口（viewport），而非直接监听滚动事件。这样我们只需在需要时渲染或回收元素。</p><p>以下是一个简化版使用 <code>IntersectionObserver</code> 来实现虚拟滚动的例子：</p><pre class="code-block"><code class="language-javascript">class VirtualScroll {
  constructor(container, itemHeight, totalItems, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.renderItem = renderItem;

    this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
      root: this.container,
      threshold: 1.0,
    });

    this.items = new Map();

    this.init();
  }

  init() {
    // 填充初始屏幕的元素
    for (let i = 0; i &lt; this.totalItems; i++) {
      const placeholder = this.createPlaceholder(i);
      this.container.appendChild(placeholder);
      this.observer.observe(placeholder);
    }
  }

  createPlaceholder(index) {
    const placeholder = document.createElement(&quot;div&quot;);
    placeholder.style.height = `${this.itemHeight}px`;
    placeholder.style.width = &quot;100%&quot;;
    placeholder.dataset.index = index; // store index
    return placeholder;
  }

  onIntersection(entries) {
    entries.forEach((entry) =&gt; {
      const index = entry.target.dataset.index;
      if (entry.isIntersecting) {
        const rendered = this.renderItem(index);
        this.container.replaceChild(rendered, entry.target);
        this.items.set(index, rendered);
      } else if (this.items.has(index)) {
        const placeholder = this.createPlaceholder(index);
        this.container.replaceChild(placeholder, this.items.get(index));
        this.observer.observe(placeholder);
        this.items.delete(index);
      }
    });
  }
}

// Render item function
function renderItem(index) {
  const item = document.createElement(&quot;div&quot;);
  item.classList.add(&quot;item&quot;);
  item.textContent = `Item ${index}`;
  item.dataset.index = index;
  item.style.height = &quot;30px&quot;; // Same as your itemHeight in VirtualScroll
  return item;
}

// Example usage:
const container = document.getElementById(&quot;scroll-container&quot;); // This should be a predefined element in your HTML
const itemHeight = 30; // Height of each item
const itemCount = 1000; // Total number of items you have

const virtualScroll = new VirtualScroll(container, itemHeight, itemCount, renderItem);
</code></pre><p>在这里我们创建了一个 <code>VirtualScroll</code> 类，构造函数接收容器元素、每个项的高度、总项目数和用于渲染每个项目的函数。我们在初始化方法中，为每个项目创建了一个占位符元素，并且向 <code>IntersectionObserver</code> 注册了这些占位元素。</p><p>当一个占位元素进入到视口中时，我们就会渲染对应的项，并且将它替换这个占位符。当一个项离开视口，我们又会将它替换回原来的占位符并取消它的注册。</p><p>这种方法的优势包括：</p><ul><li>不需要绑定滚动事件，防止滚动性能问题。</li><li>浏览器会自动优化观察者的回调。</li><li>不需要手动计算当前应该渲染的项目，当用户快速滚动时也不会遇到空白内容。</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>