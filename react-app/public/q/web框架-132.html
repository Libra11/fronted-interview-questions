<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React setState 是同步还是异步的？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;在 React 中，&lt;code&gt;setState&lt;/code&gt; 方法有时是异步的，有时是同步的，具体取决于使用方式和环境。&lt;/p&gt;&lt;p&gt;当我们在 React 中调用 &lt;code&gt;setState&lt;/code&gt; 方法时，React 会将新状态合并到组件的状态队列中，并在未来的" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="React setState 是同步还是异步的？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;在 React 中，&lt;code&gt;setState&lt;/code&gt; 方法有时是异步的，有时是同步的，具体取决于使用方式和环境。&lt;/p&gt;&lt;p&gt;当我们在 React 中调用 &lt;code&gt;setState&lt;/code&gt; 方法时，React 会将新状态合并到组件的状态队列中，并在未来的某个时间更新组件的状态。这个更新过程是异步的，即不能保证在 &lt;code&gt;setState&lt;/code&gt; 调用后立即更新状" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/132" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>React setState 是同步还是异步的？</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-03-19T14:52:06Z · 更新：2023-10-04T10:21:43Z</div>
    </div>
    <article class="content markdown-body"><p>在 React 中，<code>setState</code> 方法有时是异步的，有时是同步的，具体取决于使用方式和环境。</p><p>当我们在 React 中调用 <code>setState</code> 方法时，React 会将新状态合并到组件的状态队列中，并在未来的某个时间更新组件的状态。这个更新过程是异步的，即不能保证在 <code>setState</code> 调用后立即更新状态，而是会将状态更新推迟到下一个渲染周期中。这种情况下，<code>setState</code> 方法会返回一个 <code>Promise</code> 对象，但该对象不包含任何有用的信息。</p><p>然而，当 <code>setState</code> 方法被直接调用，而不是在事件处理函数、异步代码或生命周期函数中被调用时，更新过程是同步的。在这种情况下，React 会立即更新组件的状态，并在更新后立即执行一次重新渲染。这种情况下，<code>setState</code> 方法不会返回任何信息。</p><p>需要注意的是，在 React 中异步更新状态的机制可以提高性能和优化页面渲染速度，因为它可以让 React 在适当的时候批量更新组件状态，从而避免过多的渲染和浏览器的性能问题。如果我们需要在更新状态后立即执行某些操作，可以使用 <code>setState</code> 方法的回调函数或生命周期函数 <code>componentDidUpdate</code> 来实现。例如：</p><pre class="code-block"><code class="language-js">jsCopy codeclass MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 }, () =&gt; {
      console.log(&#39;New count:&#39;, this.state.count);
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={() =&gt; this.handleClick()}&gt;Increment&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>这里的 <code>setState</code> 方法接受一个回调函数作为第二个参数，在状态更新完成后调用该函数并传递更新后的状态作为参数。在这个回调函数中可以执行任何需要在状态更新后立即执行的操作，例如输出调试信息、发送网络请求等。</p><hr /><blockquote>2023.04.19 更新</blockquote><p>如果<strong>直接在setState后面获取state的值是获取不到的。</strong></p><ul><li>在React内部机制能检测到的地方， setState就是异步的；</li><li>在React检测不到的地方，例如 原生事件<code>addEventListener</code>,<code>setInterval</code>,<code>setTimeout</code>，setState就是同步更新的</li></ul><p>setState并不是单纯的异步或同步，这其实与调用时的环境相关</p><ul><li>在合成事件 和 生命周期钩子(除componentDidUpdate) 中，setState是"异步"的；</li><li>在 原生事件 和setTimeout 中，setState是同步的，可以马上获取更新后的值；</li></ul><p><strong>批量更新</strong></p><p>多个顺序的setState不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行。在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新。</p><p><strong>异步现象原因</strong></p><p><code>setState 的“异步”并不是说内部由异步代码实现</code>，其实本身执行的过程和代码都是同步的，只是合成事件和生命钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，<code>当然可以通过第二个参数setState(partialState, callback)中的callback拿到更新后的结果。</code></p><p><code>setState 并非真异步，只是看上去像异步。在源码中，通过 isBatchingUpdates 来判断</code></p><p>setState调用流程：</p><ol><li>调用this.setState(newState)</li><li>将新状态newState存入pending队列</li><li>判断是否处于batch Update（isBatchingUpdates是否为true）</li></ol><ul><li>isBatchingUpdates=true，保存组件于dirtyComponents中，走异步更新流程，合并操作，延迟更新；</li><li>isBatchingUpdates=false，走同步过程。遍历所有的dirtyComponents，调用updateComponent，更新pending state or props</li></ul><p><img alt="流程" src="https://foruda.gitee.com/images/1681866680280312338/0308d34b_7819612.png" /></p><p><strong>为什么直接修改this.state无效</strong></p><p>setState本质是通过一个队列机制实现state更新的。 执行setState时，会将需要更新的state合并后放入状态队列，而不会立刻更新state，队列机制可以批量更新state。</p><p>如果不通过setState而直接修改this.state，那么这个state不会放入状态队列中，下次调用setState时对状态队列进行合并时，会忽略之前直接被修改的state，这样我们就无法合并了，而且实际也没有把你想要的state更新上去</p><p>参考文档：</p><ul><li>https://juejin.cn/post/7204307381689532474#heading-5</li></ul><h2>Comments / Answers</h2><hr /><p><strong>wuhuaizai</strong> at 2023-09-20T07:04:42Z</p><p>React18下也是这样的嘛？感觉找资料还是很多都是在说class component</p><hr /><p><strong>yanlele</strong> at 2023-09-20T07:32:30Z</p><blockquote>React18下也是这样的嘛？感觉找资料还是很多都是在说class component</blockquote><p>@wuhuaizai</p><p>我所掌握的资料是这样子的</p><hr /><p><strong>yanlele</strong> at 2023-10-04T10:21:43Z</p><p>可以参考这个资料： https://juejin.cn/post/7108362046369955847</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>