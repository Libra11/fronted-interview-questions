<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>手写 Promise , 并描述其原理与实现 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;Primise原理与实现&lt;/h2&gt;&lt;p&gt;目录&lt;/p&gt;&lt;p&gt;&lt;!-- toc --&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#promise-%E6%A0%B8%E5%BF%83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Promise 核心&lt;/a&gt;" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="手写 Promise , 并描述其原理与实现" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;Primise原理与实现&lt;/h2&gt;&lt;p&gt;目录&lt;/p&gt;&lt;p&gt;&lt;!-- toc --&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#promise-%E6%A0%B8%E5%BF%83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Promise 核心&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#es6-promise%E7%BB%86%E8%8A%82&quot; target=&quot;_b" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/57" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>手写 Promise , 并描述其原理与实现</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-10T15:16:34Z · 更新：2023-03-10T15:18:47Z</div>
    </div>
    <article class="content markdown-body"><h2>Primise原理与实现</h2><p>目录</p><p><!-- toc --></p><ul><li><a href="#promise-%E6%A0%B8%E5%BF%83" target="_blank" rel="noopener">Promise 核心</a></li><li><a href="#es6-promise%E7%BB%86%E8%8A%82" target="_blank" rel="noopener">ES6 Promise细节</a></li><li><a href="#%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">动手实现</a></li><li><a href="#%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">内部属性</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E5%99%A8" target="_blank" rel="noopener">执行器</a></li><li><a href="#then%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">then方法</a></li><li><a href="#%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">异步实现</a></li><li><a href="#then-%E8%BF%94%E5%9B%9E%E5%80%BC" target="_blank" rel="noopener">then 返回值</a></li><li><a href="#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">具体代码</a></li><li><a href="#%E4%B8%83%E6%AE%B5%E7%BB%8F%E5%85%B8%E7%9A%84promise" target="_blank" rel="noopener">七段经典的Promise</a></li><li><a href="#demo1" target="_blank" rel="noopener">demo1</a></li><li><a href="#demo2" target="_blank" rel="noopener">demo2</a></li><li><a href="#demo3" target="_blank" rel="noopener">demo3</a></li><li><a href="#demo4" target="_blank" rel="noopener">demo4</a></li><li><a href="#demo5" target="_blank" rel="noopener">demo5</a></li><li><a href="#demo6" target="_blank" rel="noopener">demo6</a></li><li><a href="#demo7" target="_blank" rel="noopener">demo7</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" target="_blank" rel="noopener">参考文章</a></li></ul><p><!-- tocstop --></p><h3>Promise 核心</h3><ul><li>Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要）</li><li>Promise 规范中规定了，promise 的状态只有3种：</li><li>pending</li><li>fulfilled</li><li>rejected</li></ul><p>Promise 的状态一旦改变则不会再改变。</p><ul><li>Promise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。</li></ul><h2>ES6 Promise细节</h2><ul><li>Promise 构造器中必须传入函数，否则会抛出错误。(没有执行器还怎么做异步操作。。。)</li><li>Promise.prototype上的 catch(onrejected) 方法是 then(null,onrejected) 的别名,并且会处理链之前的任何的reject。</li><li>Promise.prototype 上的 then和 catch 方法总会返回一个全新的 Promise 对象。</li><li>如果传入构造器的函数中抛出了错误,该 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。</li><li>then 中的回调如果抛出错误，返回的 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。</li><li>then 中的回调返回值会影响 then 返回的 promise 对象。(下文会具体分析)</li></ul><h2>动手实现</h2><p>做了上面的铺垫，实现一个 Promise 的思路就清晰很多了，本文使用 ES6 来进行实现，</p><p>暂且把这个类取名为 GPromise吧(不覆盖原生的，便于和原生进行对比测试)。</p><p>下文中 GPromise 代指将要实现的类，Promise 代指 ES6中的 Promise 类。</p><h3>内部属性</h3><p>在浏览器中打印出一个 Promise 实例会发现其中会包括两用”[[ ]]”包裹起来的属性，这是系统内部属性，只有JS 引擎能够访问。</p><pre class="code-block"><code>[[PromiseStatus]]
[[PromiseValue]]
</code></pre><p>以上两个属性分别是 Promise 对象的状态和最终值。</p><p>我们自己不能实现内部属性，JS中私有属性特性(#修饰符现在还是提案)暂时也没有支持，</p><p>所以暂且用”_”前缀规定私有属性，这样就模拟了Promise 中的两个内部属性。</p><pre class="code-block"><code class="language-js">class GPromise {
        constructor(executor) {
            this._promiseStatus = GPromise.PENDING;
            this._promiseValue;
            this.execute(executor);
        }

        execute(executor){
            //...
        }

        then(onfulfilled, onrejected){
            //...
        }
    }

GPromise.PENDING = &#39;pedding&#39;;
GPromise.FULFILLED = &#39;resolved&#39;;
GPromise.REJECTED = &#39;rejected&#39;;
</code></pre><h3>执行器</h3><ul><li>传入构造器的executor为函数，并且在构造时就会执行。</li><li>我们给 executor 中传入 resolve 和 reject 参数，这两个参数都是函数，用于改变改变 _promiseStatus和 _promiseValue 的值。</li><li>并且内部做了捕获异常的操作，一旦传入的executor 函数执行抛出错误，GPromise 实例会变成 rejected状态，</li></ul><p>即 _promiseStatus赋值为’rejected’，并且 _promiseValue赋值为Error对象。</p><pre class="code-block"><code class="language-js">execute(executor) {
    if (typeof executor != &#39;function&#39;) {
        throw new Error(` GPromise resolver ${executor} is not a function`);
    }
    //捕获错误
    try {
        executor(data =&gt; {
            this.promiseStatus = GPromise.FULFILLED;
            this.promiseValue = data;
        }, data =&gt; {
            this.promiseStatus = GPromise.REJECTED;
            this.promiseValue = data; 
        });
    } catch (e) {
        this.promiseStatus = GPromise.REJECTED;
        this.promiseValue = e;
    }
}
</code></pre><h3>then方法</h3><h4>异步实现</h4><p>then 方法内部逻辑稍微复杂点，并且有一点一定一定一定要注意到: then 方法中的回调是异步执行的，思考下下段代码:</p><pre class="code-block"><code class="language-js">console.log(1);
new Promise((resolve,reject)=&gt;{
    console.log(2);
    resolve();
})
.then(()=&gt;console.log(3));
console.log(4);
</code></pre><p>执行结果是什么呢？答案其实是:1 2 4 3。</p><p>then 方法中的难点就是处理异步,其中一个方案是通过 setInterval来监听GPromise 对象的状态改变，</p><p>一旦改变则执行相应then 中相应的回调函数(onfulfilled和onrejected),这样回调函数就能够插入事件队列末尾，</p><p>异步执行，实验证明可行，这种方案是最直观也最容易理解的。</p><h4>then 返回值</h4><p>then 方法的返回值是一个新的 GPromise 对象，并且这个对象的状态和 then 中的回调返回值相关，回调指代传入的 onfulfilled 和 rejected。</p><ol><li>如果 then 中的回调抛出了错误，返回的 GPromise 的 _promiseStatus 赋值为’rejected’， _promiseValue赋值为抛出的错误对象。</li><li>如果回调返回了一个非 GPromise 对象， then返回的 GPromise 的 _promiseStatus 赋值为’resolved’， _promiseValue赋值为回调的返回值。</li><li>如果回调返回了一个 GPromise 对象，then返回的GPromise对象 的_promiseStatus和 _promiseValue 和其保持同步。也就是 then 返回的GPromise记录了回调返回的状态和值，不是直接返回回调的返回值。</li></ol><h4>具体代码</h4><pre class="code-block"><code class="language-js">then(onfulfilled, onrejected) {
        let _ref = null,
            timer = null,
            result = new GPromise(() =&gt; {});

        //因为 promise 的 executor 是异步操作,需要监听 promise 对象状态变化，并且不能阻塞线程
        timer = setInterval(() =&gt; {
            if ((typeof onfulfilled == &#39;function&#39; &amp;&amp; this._promiseStatus == GPromise.FULFILLED) ||
                (typeof onrejected == &#39;function&#39; &amp;&amp; this._promiseStatus == GPromise.REJECTED)) {
                //状态发生变化，取消监听
                clearInterval(timer);
                //捕获传入 then 中的回调的错误，交给 then 返回的 promise 处理
                try {
                    if (this._promiseStatus == GPromise.FULFILLED) {
                        _ref = onfulfilled(this._promiseValue);
                    } else {
                        _ref = onrejected(this._promiseValue);
                    }

                    //根据回调的返回值来决定 then 返回的 GPromise 实例的状态
                    if (_ref instanceof GPromise) {
                        //如果回调函数中返回的是 GPromise 实例，那么需要监听其状态变化，返回新实例的状态是根据其变化相应的
                        timer = setInterval(()=&gt;{
                            if (_ref._promiseStatus == GPromise.FULFILLED ||
                                _ref._promiseStatus == GPromise.REJECTED) {
                                clearInterval(timer);
                                result._promiseValue = _ref._promiseValue;
                                result._promiseStatus = _ref._promiseStatus;
                            }
                        },0);

                    } else {
                        //如果返回的是非 GPromise 实例
                        result._promiseValue = _ref;
                        result._promiseStatus = GPromise.FULFILLED;
                    }
                } catch (e) {
                    //回调中抛出错误的情况
                    result._promiseStatus = GPromise.REJECTED;
                    result._promiseValue = e;
                }
            }
        }, 0);
        //promise 之所以能够链式操作，因为返回了GPromise对象
        return result;
    }
</code></pre><h2>七段经典的Promise</h2><p>Promise 的 then 的 注册微任务队列 和 执行 是分离的。</p><p>注册 : 是完全遵循 JS 和 Promise 的代码的执行过程。</p><p>执行 : 先 同步，再 微任务 ，再 宏观任务。</p><h3>demo1</h3><pre class="code-block"><code class="language-js">/**
 * promise 是可连续执行的？
 * 是可以的！
 */

new Promise((resolve, reject) =&gt; {
  console.log(1);
  // return reject();
  return resolve();
})
    .then(() =&gt; {
      console.log(2);
    })
    .then(()=&gt; {
      console.log(3);
    })
    .then(()=&gt; {
      console.log(4);
    })
    .catch(()=&gt; {
      console.log(&#39;catch&#39;);
    })
    .finally(()=&gt; {
      console.log(&#39;finally&#39;);
    });
</code></pre><h3>demo2</h3><pre class="code-block"><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(1);
  return resolve()
}).then(() =&gt; {
  console.log(2);
  // 外部第一个 then 方法里面 return 一个 Promise，这个 return ，代表 外部的第二个 then 的执行需要等待 return 之后的结果。
  return new Promise((resolve) =&gt; {
    console.log(3);

    return resolve()
  })
      .then(() =&gt; {
        console.log(4);
      })
      .then(() =&gt; {
        console.log(5);
      })
}).then(() =&gt; {
  console.log(6);
}).then(() =&gt; {
  console.log(7);
});
</code></pre><h3>demo3</h3><pre class="code-block"><code class="language-js">// 我们核心要看 then 的回调函数是啥时候注册的，我们知道，事件机制是 “先注册先执行”，
// 即数据结构中的 “栈” 的模式，first in first out。那么重点我们来看下他们谁先注册的。

// 外部的第二个 then 的注册，需要等待 外部的第一个 then 的同步代码执行完成。
// 当执行内部的 new Promise 的时候，然后碰到 resolve，resolve 执行完成，
// 代表此时的该 Promise 状态已经扭转，之后开始内部的第一个 .then 的微任务的注册，此时同步执行完成。
new Promise((resolve) =&gt; {
  console.log(1);
  return resolve()
}).then(() =&gt; {
  console.log(2);
  // 内部的 resolve 之后，当然是先执行内部的 new Promise 的第一个 then 的注册，这个 new Promise 执行完成，立即同步执行了后面的 .then 的注册。
  new Promise((resolve) =&gt; {
    console.log(3);
    return resolve()
  })
      .then(() =&gt; {
        console.log(4);
      })
      // 然而这个内部的第二个 then 是需要第一个 then 的的执行完成来决定的，而第一个 then 的回调是没有执行，仅仅只是执行了同步的 .then 方法的注册，所以会进入等待状态。
      .then(() =&gt; {
        console.log(5);
      })
      .then(()=&gt; {
        console.log(6);
      })
}).then(() =&gt; {
  // 外部的第一个 then 的同步操作已经完成了，
  // 然后开始注册外部的第二个 then，此时外部的同步任务也都完成了。
  // 外部第二个 then 完成之后， 进入等待， 内部的第二个 then 注册之后在执行
  console.log(7);
}).then(() =&gt; {
  console.log(8);
}).then(()=&gt; {
  console.log(9);
});
</code></pre><h3>demo4</h3><pre class="code-block"><code class="language-js">/**
 * 链式调用的注册是前后依赖的 比如上面的外部的第二个 then 的注册，是需要外部的第一个的 then 的执行完成。
 *
 * 变量定义的方式，注册都是同步的 比如这里的 p.then 和 var p = new Promise 都是同步执行的。
 */
new Promise(resolve=&gt; {
  console.log(&#39;1&#39;);
  resolve();
})
  .then(()=&gt; {
    console.log(2);
    const p = new Promise(resove=&gt; {
      console.log(3);
      resove();
    });

    p.then(()=&gt; {
      console.log(4);
    });

    p.then(()=&gt; {
      console.log(5);
    });
  })
  .then(()=&gt; {
    console.log(6)
  })
  .then(()=&gt; {
    console.log(7)
  });
</code></pre><h3>demo5</h3><pre class="code-block"><code class="language-js">/**
 * 这段代码中，外部的注册采用了非链式调用的写法，根据上面的讲解，
 * 我们知道了外部代码的 p.then 是并列同步注册的。
 * 所以代码在内部的 new Promise 执行完，p.then 就都同步注册完了。
 *
 * 内部的第一个 then 注册之后，
 * 就开始执行外部的第二个 then 了（外部的第二个 then 和 外部的第一个 then 都是同步注册完了）。
 * 然后再依次执行内部的第一个 then ,内部的第二个 then。
 * @type {Promise}
 */
const p = new Promise(resolve =&gt; {
  console.log(1);
  resolve()
});

p.then(() =&gt; {
  console.log(2);
  new Promise(resolve =&gt; {
    console.log(3);
    resolve();
  })
    .then(() =&gt; {
      console.log(4);
    })
    .then(() =&gt; {
      console.log(5);
    })
});

p.then(() =&gt; {
  console.log(6);
});

p.then(() =&gt; {
  console.log(7)
});
</code></pre><h3>demo6</h3><pre class="code-block"><code class="language-js">new Promise(resolve =&gt; {
  console.log(1);
  resolve();
})
  .then(() =&gt; {
    console.log(2);
    new Promise(resolve =&gt; {
      console.log(3);
      resolve();
    })
      .then(() =&gt; {
        console.log(4);
      })
      .then(() =&gt; {
        console.log(5);
      });

    return new Promise(resolve =&gt; {
      console.log(6);
      resolve();
    })
      .then(() =&gt; {
        console.log(7);
      })
      .then(() =&gt; {
        console.log(8);
      })
  })
  .then(() =&gt; {
    console.log(9);
  })
  .then(() =&gt; {
    console.log(10);
  });
</code></pre><h3>demo7</h3><pre class="code-block"><code class="language-js">new Promise((resolve, reject) =&gt; {
  console.log(&#39;外部promise&#39;);
  resolve();
})
  .then(() =&gt; {
    console.log(&#39;外部第一个then&#39;);
    new Promise((resolve, reject) =&gt; {
      console.log(&#39;内部promise&#39;);
      resolve();
    })
      .then(() =&gt; {
        console.log(&#39;内部第一个then&#39;);
        return Promise.resolve();
      })
      .then(() =&gt; {
        console.log(&#39;内部第二个then&#39;);
      })
  })
  .then(() =&gt; {
    console.log(&#39;外部第二个then&#39;);
  })
  .then(() =&gt; {
    console.log(&#39;外部第三个then&#39;);
  })
</code></pre><h2>参考文章</h2><ul><li><a href="https://blog.csdn.net/u014775861/article/details/78030508" target="_blank" rel="noopener">解析 Promise 原理，实现一个Promise</a></li><li><a href="https://juejin.im/post/5dc028dcf265da4d4b5fe94f" target="_blank" rel="noopener">深度揭秘 Promise 微任务注册和执行过程</a></li><li><a href="https://juejin.im/post/5dad3405f265da5bb252ff32" target="_blank" rel="noopener">Promise 执行过程的正确理解姿势</a></li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>