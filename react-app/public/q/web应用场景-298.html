<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>git merge 和 git rebase 区别【热度: 1,150】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 都是用来合并不同分支的命令，但是它们的实现方式和结果不同。&lt;/p&gt;&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 会把两个分支的最新提交点合并起来，生成一个新的合并提交，并" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="git merge 和 git rebase 区别【热度: 1,150】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 都是用来合并不同分支的命令，但是它们的实现方式和结果不同。&lt;/p&gt;&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 会把两个分支的最新提交点合并起来，生成一个新的合并提交，并且会保留两个分支各自的提交记录，形成一条分支合并的历史线。合并后的代码中，两个分支的修改都会被保留下来。&lt;/p&gt;&lt;p&gt;&lt;" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/298" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>git merge 和 git rebase 区别【热度: 1,150】</h1>
      <div class="subtitle">web应用场景 · web应用场景</div>
      <div class="meta">创建：2023-04-18T16:20:56Z · 更新：2023-11-26T15:22:03Z</div>
    </div>
    <article class="content markdown-body"><p><code>git merge</code> 和 <code>git rebase</code> 都是用来合并不同分支的命令，但是它们的实现方式和结果不同。</p><p><code>git merge</code> 会把两个分支的最新提交点合并起来，生成一个新的合并提交，并且会保留两个分支各自的提交记录，形成一条分支合并的历史线。合并后的代码中，两个分支的修改都会被保留下来。</p><p><code>git rebase</code> 也是用来合并分支的，但是它会将当前分支的提交“移动”到目标分支的最后面，然后再将目标分支的修改合并进来。这个过程中，会改变当前分支的提交记录，使它看起来像是在目标分支上进行的修改，从而保持一条干净的提交历史。如果发生冲突，需要手动解决冲突并进行提交。</p><p>总的来说，<code>git merge</code> 适合用于简单的合并场景，保留分支历史记录，而 <code>git rebase</code> 则适合用于合并长期存在分支的场景，可以保持一个干净的提交历史。但是在合并公共分支时，使用 <code>git rebase</code> 可能会破坏代码的协作性，因此需要谨慎使用。</p><hr /><p>补充更新：</p><p>假设你现在基于远程分支"origin"，创建一个叫"mywork"的分支。</p><p><code>$ git checkout -b mywork origin</code></p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/b40fdca9-4844-4996-b008-f24d0d486acb" /></p><p>现在我们在这个分支做一些修改，然后生成两个提交(commit).</p><pre class="code-block"><code>$ vi file.txt
$ git commit
$ vi otherfile.txt
$ git commit
...
</code></pre><p>但是与此同时，有些人也在"origin"分支上做了一些修改并且做了提交了. 这就意味着"origin"和"mywork"这两个分支各自"前进"了，它们之间"分叉"了。</p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/82286270-6422-4b34-a1b3-9d5367b50a78" /></p><p>在这里，你可以用"pull"命令把"origin"分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的"合并的提交"(merge commit):</p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/5f29e4cd-e1c5-4b8d-b4cd-2dd4db047e8a" /></p><p>但是，如果你想让"mywork"分支历史看起来像没有经过任何合并一样，你也许可以用 <code>git rebase</code></p><pre class="code-block"><code>$ git checkout mywork
$ git rebase origin
</code></pre><p>这些命令会把你的"mywork"分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到".git/rebase"目录中),然后把"mywork"分支更新 到最新的"origin"分支，最后把保存的这些补丁应用到"mywork"分支上。</p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/e0157351-163a-40e9-85d5-fbc1e35f5ba8" /></p><p>当'mywork'分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除.</p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/4937b995-8e48-4c32-b101-4fb551b60d01" /></p><p>现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别：</p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/0d85e67e-8366-4591-8118-50695129dd3c" /></p><p><img alt="image" src="https://github.com/pro-collection/interview-question/assets/22188674/b871d1a2-b8e5-4807-9b97-2de8ec103e07" /></p><p>在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用"git-add"命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:</p><p><code>$ git rebase --continue</code></p><p>这样git会继续应用(apply)余下的补丁。</p><p>在任何时候，你可以用--abort参数来终止rebase的行动，并且"mywork" 分支会回到rebase开始前的状态。</p><p><code>$ git rebase --abort</code></p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>