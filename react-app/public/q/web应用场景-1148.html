<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nginx 如何为不同前端资源配置缓存策略？如何强制刷新特定资源？【热度: 110】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：nginx 加载特定资源&lt;/p&gt;&lt;p&gt;Nginx 为不同前端资源配置缓存策略的核心是&lt;strong&gt;根据资源特性（是否常变、是否带版本标识）差异化设置缓存规则&lt;/strong&gt;，同时通过特定机制实现特定资源的强制刷新。以下是详细方案" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="Nginx 如何为不同前端资源配置缓存策略？如何强制刷新特定资源？【热度: 110】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：nginx 加载特定资源&lt;/p&gt;&lt;p&gt;Nginx 为不同前端资源配置缓存策略的核心是&lt;strong&gt;根据资源特性（是否常变、是否带版本标识）差异化设置缓存规则&lt;/strong&gt;，同时通过特定机制实现特定资源的强制刷新。以下是详细方案：&lt;/p&gt;&lt;h3&gt;一、按资源类型配置差异化缓存策略&lt;/h3&gt;&lt;p&gt;前端资源可分为&lt;strong&gt;静态资源&lt;/strong" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/1148" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>Nginx 如何为不同前端资源配置缓存策略？如何强制刷新特定资源？【热度: 110】</h1>
      <div class="subtitle">web应用场景 · web应用场景</div>
      <div class="meta">创建：2025-09-07T06:21:16Z · 更新：2025-09-07T06:21:17Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：nginx 加载特定资源</p><p>Nginx 为不同前端资源配置缓存策略的核心是<strong>根据资源特性（是否常变、是否带版本标识）差异化设置缓存规则</strong>，同时通过特定机制实现特定资源的强制刷新。以下是详细方案：</p><h3>一、按资源类型配置差异化缓存策略</h3><p>前端资源可分为<strong>静态资源</strong>（JS、CSS、图片等）和<strong>入口文件</strong>（如 <code>index.html</code>），需根据其更新频率和版本管理方式设置不同缓存策略：</p><h4>1. 带哈希/版本号的静态资源（永久强缓存）</h4><p><strong>特征</strong>：文件名含唯一哈希（如 <code>app.8f3b.js</code>）或版本号（如 <code>v2/style.css</code>），内容变化时文件名必变。</p><p><strong>策略</strong>：设置长期强缓存，减少重复请求。</p><pre class="code-block"><code class="language-nginx"># 匹配带哈希的 JS/CSS/图片（假设哈希为 8-16 位字符）
location ~* \.\w{8,16}\.(js|css|png|jpg|jpeg|webp|svg)$ {
    # 缓存 1 年（31536000 秒）
    expires 365d;
    # 强缓存标识：浏览器直接使用本地缓存，不发送请求
    add_header Cache-Control &quot;public, max-age=31536000, immutable&quot;;
}
</code></pre><ul><li><strong>关键参数</strong>：<code>immutable</code>（H5 新特性）告知浏览器资源不会变化，避免发送无效的条件请求（如 <code>If-Modified-Since</code>）。</li></ul><h4>2. 无哈希的静态资源（短期强缓存 + 协商缓存）</h4><p><strong>特征</strong>：文件名固定（如 <code>favicon.ico</code>、<code>common.js</code>），可能不定期更新但无版本标识。</p><p><strong>策略</strong>：短期强缓存减少请求，过期后通过协商缓存验证是否更新。</p><pre class="code-block"><code class="language-nginx"># 匹配无哈希的图片、字体等
location ~* \.(png|jpg|jpeg|ico|woff2?)$ {
    # 短期强缓存 7 天
    expires 7d;
    # 过期后必须验证是否更新
    add_header Cache-Control &quot;public, max-age=604800, must-revalidate&quot;;
}
</code></pre><h4>3. 入口文件与动态页面（协商缓存）</h4><p><strong>特征</strong>：如 <code>index.html</code>、<code>page.html</code>，作为路由入口或动态内容载体，需确保用户获取最新版本。</p><p><strong>策略</strong>：禁用强缓存，每次请求通过协商缓存验证。</p><pre class="code-block"><code class="language-nginx"># 入口文件（如 index.html）
location = /index.html {
    # 禁用强缓存（立即过期）
    expires -1;
    # 协商缓存：必须向服务器验证
    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;
}

# 其他 HTML 页面
location ~* \.html$ {
    expires -1;
    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;
}
</code></pre><ul><li><strong>协商缓存原理</strong>：Nginx 自动返回 <code>Last-Modified</code>（文件修改时间），浏览器下次请求携带 <code>If-Modified-Since</code>，服务器比对后返回 <code>304</code>（未修改）或 <code>200</code>（新内容）。</li></ul><h4>4. API 接口与动态数据（无缓存或短时缓存）</h4><p><strong>特征</strong>：如 <code>/api/user</code>，返回动态数据，需实时性。</p><p><strong>策略</strong>：禁用缓存或设置极短缓存时间。</p><pre class="code-block"><code class="language-nginx"># API 接口
location /api {
    # 完全禁用缓存
    add_header Cache-Control &quot;no-store, no-cache, must-revalidate&quot;;
    expires -1;
    # 转发到后端服务
    proxy_pass http://backend;
}
</code></pre><h3>二、强制刷新特定资源的方法</h3><p>当资源更新但因缓存未生效时，需强制用户获取最新版本，核心思路是<strong>破坏缓存标识</strong>或<strong>主动清理缓存</strong>：</p><h4>1. 前端主动更新资源标识（推荐）</h4><p>利用“哈希/版本号与内容绑定”的特性，资源更新时修改文件名，浏览器会视为新资源自动请求：</p><ul><li>例：<code>app.8f3b.js</code> → 更新后变为 <code>app.9c4d.js</code>，无需 Nginx 配置，彻底避免缓存问题。</li></ul><h4>2. 通过 URL 参数强制刷新（临时方案）</h4><p>对无哈希的资源，可在请求 URL 后添加随机参数（如 <code>?v=2</code>），使浏览器认为是新资源：</p><ul><li>例：<code>common.js</code> → <code>common.js?v=2</code></li><li><strong>Nginx 无需额外配置</strong>，但需前端手动更新参数，适合临时紧急更新。</li></ul><h4>3. 清理 CDN 缓存（若使用 CDN）</h4><p>若资源通过 CDN 分发，需在 CDN 控制台手动清理特定资源缓存：</p><ul><li>例：阿里云 CDN 支持按路径（如 <code>/&lt;em&gt;/&lt;/em&gt;.js</code>）或具体 URL 清理缓存，生效后用户请求会回源获取最新资源。</li></ul><h4>4. 动态修改资源的 <code>Last-Modified</code>（不推荐）</h4><p>通过 Nginx 指令强制修改资源的 <code>Last-Modified</code> 头，触发协商缓存更新：</p><pre class="code-block"><code class="language-nginx"># 强制刷新某个资源（如 common.js）
location = /static/js/common.js {
    # 手动设置一个较新的修改时间（比实际文件新）
    add_header Last-Modified &quot;Wed, 20 Sep 2025 08:00:00 GMT&quot;;
    # 协商缓存配置
    expires -1;
    add_header Cache-Control &quot;no-cache, must-revalidate&quot;;
}
</code></pre><ul><li><strong>缺点</strong>：需手动修改 Nginx 配置并 reload，仅适合紧急情况，不建议长期使用。</li></ul><h3>三、完整缓存配置示例</h3><pre class="code-block"><code class="language-nginx">server {
    listen 80;
    server_name example.com;
    root /path/to/frontend;

    # 1. 带哈希的静态资源（永久缓存）
    location ~* \.\w{8,16}\.(js|css|png|jpg|jpeg|webp|svg)$ {
        expires 365d;
        add_header Cache-Control &quot;public, max-age=31536000, immutable&quot;;
    }

    # 2. 无哈希的静态资源（短期+协商）
    location ~* \.(png|jpg|jpeg|ico|woff2?)$ {
        expires 7d;
        add_header Cache-Control &quot;public, max-age=604800, must-revalidate&quot;;
    }

    # 3. 入口文件与 HTML（协商缓存）
    location = /index.html {
        expires -1;
        add_header Cache-Control &quot;no-cache, must-revalidate&quot;;
    }

    # 4. API 接口（无缓存）
    location /api {
        add_header Cache-Control &quot;no-store, no-cache&quot;;
        expires -1;
        proxy_pass http://backend;
    }

    # SPA 路由支持（配合 History 模式）
    location / {
        try_files $uri $uri/ /index.html;
    }
}
</code></pre><h3>四、关键注意事项</h3><ol><li><strong>缓存与版本管理协同</strong>：前端打包工具（Webpack/Vite）需确保“内容变则哈希变”，与 Nginx 强缓存配合，这是最可靠的刷新方式。</li><li><strong>避免缓存 <code>index.html</code></strong>：入口文件必须用协商缓存，否则用户可能无法获取新的哈希资源列表。</li><li><strong>HTTPS 环境下的缓存</strong>：若启用 HTTPS，需确保 <code>Cache-Control</code> 头正确传递（Nginx 默认不拦截），避免 CDN 或代理服务器篡改缓存策略。</li></ol><h3>总结</h3><ul><li><strong>差异化缓存</strong>：带哈希资源用永久强缓存，无哈希资源用短期+协商缓存，入口文件和 API 禁用强缓存。</li><li><strong>强制刷新</strong>：优先通过修改资源哈希/版本号实现，临时场景可用 URL 参数，CDN 资源需手动清理 CDN 缓存。</li></ul><p>这种策略既能最大化利用缓存提升性能，又能确保资源更新及时生效。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>