<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>将静态资源缓存在本地的方式有哪些？【热度: 584】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：静态资源缓存本地&lt;/p&gt;&lt;p&gt;&lt;strong&gt;浏览器可以使用以下几种方式将前端静态资源缓存在本地&lt;/strong&gt;：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="将静态资源缓存在本地的方式有哪些？【热度: 584】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：静态资源缓存本地&lt;/p&gt;&lt;p&gt;&lt;strong&gt;浏览器可以使用以下几种方式将前端静态资源缓存在本地&lt;/strong&gt;：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、m" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/578" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>将静态资源缓存在本地的方式有哪些？【热度: 584】</h1>
      <div class="subtitle">工程化 · 工程化 · 网易</div>
      <div class="meta">创建：2023-10-01T09:46:23Z · 更新：2023-10-01T09:46:24Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：静态资源缓存本地</p><p><strong>浏览器可以使用以下几种方式将前端静态资源缓存在本地</strong>：</p><ol><li>HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、max-age（设置资源缓存的最大时间）等。浏览器根据这些缓存策略来决定是否将资源缓存在本地。</li></ol><ol><li>ETag/If-None-Match：服务器可以通过在响应头中添加ETag字段，用于标识资源的版本号。当浏览器再次请求资源时，会将上次请求返回的ETag值通过If-None-Match字段发送给服务器，由服务器判断资源是否发生了变化。如果资源未发生变化，服务器会返回304 Not Modified状态码，浏览器则直接使用本地缓存的资源。</li></ol><ol><li>Last-Modified/If-Modified-Since：服务器可以通过在响应头中添加Last-Modified字段，用于标识资源的最后修改时间。浏览器再次请求资源时，会将上次请求返回的Last-Modified值通过If-Modified-Since字段发送给服务器。服务器根据资源的最后修改时间判断资源是否发生了变化，如果未发生变化，则返回304 Not Modified状态码，浏览器使用本地缓存的资源。</li></ol><ol><li>Service Worker缓存：使用Service Worker可以将前端资源缓存在浏览器的Service Worker缓存中。Service Worker是运行在浏览器后台的脚本，它可以拦截和处理网络请求，因此可以将前端资源缓存起来，并在离线状态下提供缓存的资源。</li></ol><ol><li>LocalStorage或IndexedDB：对于一些小的静态资源，可以将其存储在浏览器的LocalStorage或IndexedDB中。这些存储方式是浏览器提供的本地存储机制，可以将数据以键值对的形式存储在浏览器中，从而实现缓存的效果。</li></ol><p><strong>如何将静态资源缓存在 LocalStorage或IndexedDB</strong></p><p>以下是一个使用LocalStorage将静态资源缓存的示例代码：</p><pre class="code-block"><code class="language-javascript">// 定义一个数组，包含需要缓存的静态资源的URL
var resources = [
  &#39;https://example.com/css/style.css&#39;,
  &#39;https://example.com/js/main.js&#39;,
  &#39;https://example.com/images/logo.png&#39;
];

// 遍历资源数组，将资源请求并存储在LocalStorage中
resources.forEach(function(url) {
  // 发起资源请求
  fetch(url)
    .then(function(response) {
      // 检查请求是否成功
      if (!response.ok) {
        throw new Error(&#39;Request failed: &#39; + response.status);
      }
      // 将响应数据存储在LocalStorage中
      return response.text();
    })
    .then(function(data) {
      // 将资源数据存储在LocalStorage中，以URL作为键名
      localStorage.setItem(url, data);
      console.log(&#39;Resource cached: &#39; + url);
    })
    .catch(function(error) {
      console.error(error);
    });
});
</code></pre><p>以下是一个使用IndexedDB将静态资源缓存的示例代码：</p><pre class="code-block"><code class="language-javascript">// 打开或创建一个IndexedDB数据库
var request = indexedDB.open(&#39;myDatabase&#39;, 1);

// 创建或更新数据库的对象存储空间
request.onupgradeneeded = function(event) {
  var db = event.target.result;
  var objectStore = db.createObjectStore(&#39;resources&#39;, { keyPath: &#39;url&#39; });
  objectStore.createIndex(&#39;url&#39;, &#39;url&#39;, { unique: true });
};

// 成功打开数据库后，将资源请求并存储在IndexedDB中
request.onsuccess = function(event) {
  var db = event.target.result;
  var transaction = db.transaction(&#39;resources&#39;, &#39;readwrite&#39;);
  var objectStore = transaction.objectStore(&#39;resources&#39;);

  resources.forEach(function(url) {
    // 发起资源请求
    fetch(url)
      .then(function(response) {
        // 检查请求是否成功
        if (!response.ok) {
          throw new Error(&#39;Request failed: &#39; + response.status);
        }
        // 将响应数据存储在IndexedDB中
        return response.blob();
      })
      .then(function(data) {
        // 创建一个资源对象，以URL作为键名
        var resource = { url: url, data: data };
        // 将资源对象存储在IndexedDB中
        objectStore.put(resource);
        console.log(&#39;Resource cached: &#39; + url);
      })
      .catch(function(error) {
        console.error(error);
      });
  });

  // 完成事务
  transaction.oncomplete = function() {
    console.log(&#39;All resources cached in IndexedDB.&#39;);
  };

  transaction.onerror = function(event) {
    console.error(&#39;Transaction error:&#39;, event.target.error);
  };
};
</code></pre><p>以上代码仅为示例，实际应用中需要根据具体的需求进行相应的优化和错误处理。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>