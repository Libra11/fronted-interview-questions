<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] 在 setState 时发生了什么【热度: 169】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React setState 过程&lt;/p&gt;&lt;p&gt;在 React 中，当调用&lt;code&gt;setState&lt;/code&gt;时，会发生以下一系列事情：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一、触发状态更新&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] 在 setState 时发生了什么【热度: 169】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React setState 过程&lt;/p&gt;&lt;p&gt;在 React 中，当调用&lt;code&gt;setState&lt;/code&gt;时，会发生以下一系列事情：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一、触发状态更新&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;调用 setState 方法&lt;/strong&gt;：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;当在 React 组件" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/983" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] 在 setState 时发生了什么【热度: 169】</h1>
      <div class="subtitle">小米 · web框架 · 小米</div>
      <div class="meta">创建：2024-10-12T15:29:46Z · 更新：2024-12-06T04:08:00Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：React setState 过程</p><p>在 React 中，当调用<code>setState</code>时，会发生以下一系列事情：</p><p><strong>一、触发状态更新</strong></p><ol><li><strong>调用 setState 方法</strong>：</li></ol><ul><li>当在 React 组件中调用<code>setState</code>方法时，React 会将这个状态更新请求排队。这意味着 React 不会立即更新组件的状态，而是将这个更新请求添加到一个队列中，等待合适的时机进行处理。</li><li>例如：</li></ul><p>```javascript</p><p>this.setState({ count: this.state.count + 1 });</p><p>```</p><ul><li>在这个例子中，调用<code>setState</code>方法来增加<code>count</code>状态的值。</li></ul><p><strong>二、合并状态</strong></p><ol><li><strong>状态合并</strong>：</li></ol><ul><li>如果多次调用<code>setState</code>方法，React 会将这些状态更新请求合并在一起。这意味着 React 不会立即应用每个状态更新请求，而是会将它们合并成一个单一的状态更新。</li><li>例如，如果在一个事件处理函数中多次调用<code>setState</code>方法：</li></ul><p>```javascript</p><p>handleClick() {</p><p>this.setState({ count: this.state.count + 1 });</p><p>this.setState({ count: this.state.count + 1 });</p><p>}</p><p>```</p><ul><li>React 不会立即将<code>count</code>的值增加两次，而是会将这两个状态更新请求合并成一个，最终只将<code>count</code>的值增加一次。</li></ul><ol><li><strong>浅合并对象状态</strong>：</li></ol><ul><li>如果<code>setState</code>方法的参数是一个对象，React 会进行浅合并。这意味着如果状态是一个对象，并且只更新了其中的一部分属性，React 会将新的属性值合并到旧的状态对象中，而不会替换整个状态对象。</li><li>例如：</li></ul><p>```javascript</p><p>this.setState({ user: { name: "New Name" } });</p><p>```</p><ul><li>如果原来的状态是<code>{ user: { name: &#39;Old Name&#39;, age: 30 } }</code>，那么调用<code>setState</code>方法后，新的状态将是<code>{ user: { name: &#39;New Name&#39;, age: 30 } }</code>。React 只会更新<code>user</code>对象的<code>name</code>属性，而不会影响<code>age</code>属性。</li></ul><p><strong>三、触发重新渲染</strong></p><ol><li><strong>协调阶段</strong>：</li></ol><ul><li>在合适的时机，React 会开始处理状态更新请求队列。React 会进入一个称为协调阶段的过程，在这个阶段，React 会比较组件的当前状态和新的状态，确定哪些组件需要重新渲染。</li><li>React 会使用一种称为虚拟 DOM 的技术来比较新旧状态，并确定最小化的更新操作，以提高性能。</li></ul><ol><li><strong>重新渲染组件</strong>：</li></ol><ul><li>如果 React 确定某个组件的状态发生了变化，并且需要重新渲染，它会调用该组件的<code>render</code>方法来生成新的虚拟 DOM。然后，React 会将新的虚拟 DOM 与旧的虚拟 DOM 进行比较，确定需要进行哪些实际的 DOM 操作来更新页面。</li><li>例如，如果一个组件的状态发生了变化，React 会调用该组件的<code>render</code>方法，生成新的虚拟 DOM，并将其与旧的虚拟 DOM 进行比较。如果有差异，React 会更新实际的 DOM，以反映新的状态。</li></ul><p><strong>四、异步执行</strong></p><ol><li><strong>异步更新状态</strong>：</li></ol><ul><li>在 React 中，<code>setState</code>方法通常是异步执行的。这意味着在调用<code>setState</code>方法后，不能立即依赖新的状态值。</li><li>例如：</li></ul><p>```javascript</p><p>this.setState({ count: this.state.count + 1 });</p><p>console.log(this.state.count);</p><p>```</p><ul><li>在这个例子中，<code>console.log</code>语句可能不会输出更新后的<code>count</code>值，因为<code>setState</code>方法是异步执行的，状态更新可能还没有完成。</li></ul><ol><li><strong>使用回调函数</strong>：</li></ol><ul><li>如果需要在状态更新完成后执行一些操作，可以在<code>setState</code>方法中传递一个回调函数作为第二个参数。这个回调函数将在状态更新完成后被调用。</li><li>例如：</li></ul><p>```javascript</p><p>this.setState({ count: this.state.count + 1 }, () => {</p><p>console.log(this.state.count);</p><p>});</p><p>```</p><ul><li>在这个例子中，回调函数将在状态更新完成后被调用，此时可以确保<code>count</code>的值已经更新。</li></ul><p>在 React 中，调用<code>setState</code>方法会触发一系列的操作，包括排队状态更新请求、合并状态、触发重新渲染等。</p><h2>Comments / Answers</h2><hr /><p><strong>greatanimalion</strong> at 2024-12-06T04:07:59Z</p><p>thats good</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>