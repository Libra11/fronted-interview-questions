<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[Vue] 为什么 data 属性是一个函数而不是一个对象？【热度: 448】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：vue data 函数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实例和组件定义data的区别&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;vue&lt;/code&gt; 实例的时候定义&lt;code&gt;data&lt;/code&gt;属性既可以是一个对象，也可以是一个函数" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[Vue] 为什么 data 属性是一个函数而不是一个对象？【热度: 448】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：vue data 函数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实例和组件定义data的区别&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;vue&lt;/code&gt; 实例的时候定义&lt;code&gt;data&lt;/code&gt;属性既可以是一个对象，也可以是一个函数&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;const " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/576" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[Vue] 为什么 data 属性是一个函数而不是一个对象？【热度: 448】</h1>
      <div class="subtitle">web框架 · web框架 · Shopee</div>
      <div class="meta">创建：2023-10-01T09:23:56Z · 更新：2023-10-01T09:31:47Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：vue data 函数</p><p><strong>实例和组件定义data的区别</strong></p><p><code>vue</code> 实例的时候定义<code>data</code>属性既可以是一个对象，也可以是一个函数</p><pre class="code-block"><code class="language-js">const app = new Vue({
  el: &quot;#app&quot;,
  // 对象格式
  data: {
    foo: &quot;foo&quot;
  },
  // 函数格式
  data() {
    return {
      foo: &quot;foo&quot;
    }
  }
})
</code></pre><p>组件中定义data属性，只能是一个函数</p><p>如果为组件data直接定义为一个对象</p><pre class="code-block"><code class="language-js">Vue.component(&#39;component1&#39;, {
  template: `&lt;div&gt;组件&lt;/div&gt;`,
  data: {
    foo: &quot;foo&quot;
  }
})
</code></pre><p>则会得到警告信息</p><p>警告说明：返回的data应该是一个函数在每一个组件实例中</p><p><strong>组件data定义函数与对象的区别</strong></p><p>上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？</p><p>在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例</p><p>这里我们模仿组件构造函数，定义data属性，采用对象的形式</p><pre class="code-block"><code class="language-js">function Component() {

}

Component.prototype.data = {
  count: 0
}
</code></pre><p>创建两个组件实例</p><pre class="code-block"><code class="language-js">const componentA = new Component()
const componentB = new Component()
</code></pre><p>产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响</p><p>如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</p><pre class="code-block"><code class="language-js">function Component() {
  this.data = this.data()
}

Component.prototype.data = function() {
  return {
    count: 0
  }
}
</code></pre><p>修改componentA组件data属性的值，componentB中的值不受影响</p><pre class="code-block"><code class="language-js">console.log(componentB.data.count)  // 0
componentA.data.count = 1
console.log(componentB.data.count)  // 0
</code></pre><p>vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染</p><p><strong>原理分析</strong></p><p>首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象</p><p>源码位置：<code>/vue-dev/src/core/instance/state.js</code></p><pre class="code-block"><code class="language-js">function initData(vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
    : data || {}
  // ...
}
</code></pre><p><code>data</code>既能是<code>object</code>也能是<code>function</code>，那为什么还会出现上文警告呢？</p><p>别急，继续看下文</p><p>组件在创建的时候，会进行选项的合并</p><p>源码位置：<code>/vue-dev/src/core/util/options.js</code></p><p>自定义组件会进入<code>mergeOptions</code>进行选项合并</p><pre class="code-block"><code class="language-ts">Vue.prototype._init = function(options?: Object) {
  // ...
  // merge options
  if (options &amp;&amp; options._isComponent) {
    // optimize internal component instantiation
    // since dynamic options merging is pretty slow, and none of the
    // internal component options needs special treatment.
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }
  // ...
}
</code></pre><p>定义data会进行数据校验</p><p>源码位置：<code>/vue-dev/src/core/instance/init.js</code></p><p>这时候<code>vm</code>实例为<code>undefined</code>，进入if判断，若<code>data</code>类型不是<code>function</code>，则出现警告提示</p><pre class="code-block"><code class="language-tsx">strats.data = function(
  parentVal: any,
  childVal: any,
  vm?: Component
): Function {
  if (!vm) {
    if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) {
      process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;
      warn(
        &#39;The &quot;data&quot; option should be a function &#39; +
        &quot;that returns a per-instance value in component &quot; +
        &quot;definitions.&quot;,
        vm
      );

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }
  return mergeDataOrFn(parentVal, childVal, vm);
};
</code></pre><p><strong>结论</strong></p><ul><li>根实例对象<code>data</code>可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li><li>组件实例对象<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新<code>data</code>对象</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>