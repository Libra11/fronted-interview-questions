<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何做 promise 缓存？上一次调用函数的 promise 没有返回， 那么下一次调用函数依然返回上一个 promise - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h3&gt;基础实现&lt;/h3&gt;&lt;p&gt;可以使用闭包实现 promise 缓存的功能。下面是一个示例代码：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;function cachedPromise(promiseFunctio" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="如何做 promise 缓存？上一次调用函数的 promise 没有返回， 那么下一次调用函数依然返回上一个 promise" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h3&gt;基础实现&lt;/h3&gt;&lt;p&gt;可以使用闭包实现 promise 缓存的功能。下面是一个示例代码：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;function cachedPromise(promiseFunction) { let lastPromise = null; return function() { if (lastPro" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/350" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>如何做 promise 缓存？上一次调用函数的 promise 没有返回， 那么下一次调用函数依然返回上一个 promise</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-05-06T16:22:53Z · 更新：2023-05-06T16:22:54Z</div>
    </div>
    <article class="content markdown-body"><h3>基础实现</h3><p>可以使用闭包实现 promise 缓存的功能。下面是一个示例代码：</p><pre class="code-block"><code class="language-js">function cachedPromise(promiseFunction) {
  let lastPromise = null;
  
  return function() {
    if (lastPromise !== null) {
      return lastPromise;
    }
    
    lastPromise = promiseFunction();
    return lastPromise;
  }
}

const promiseFunction = () =&gt; {
  // 这里可以是任何一个返回 Promise 的异步函数
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(&#39;Resolved!&#39;);
    }, 2000)
  })
}

const cachedPromiseFunction = cachedPromise(promiseFunction);

cachedPromiseFunction().then(result =&gt; {
  console.log(result); // Resolved!
});

// 因为上次调用函数的 Promise 还未 resolve，所以这里直接返回上次的 Promise
cachedPromiseFunction().then(result =&gt; {
  console.log(result); // Resolved!
});
</code></pre><p>在上面的代码中，我们先定义了一个 <code>cachedPromise</code> 函数，它接收一个返回 Promise 的异步函数 <code>promiseFunction</code>，并返回一个新的函数。这个新函数会维护一个 <code>lastPromise</code> 变量，用来记录上一次调用 <code>promiseFunction</code> 函数返回的 Promise。</p><p>当第一次调用 <code>cachedPromiseFunction</code> 时，<code>lastPromise</code> 变量还没有值，因此会调用 <code>promiseFunction</code>，并将返回的 Promise 赋值给 <code>lastPromise</code> 变量。同时，返回这个 Promise。</p><p>当第二次调用 <code>cachedPromiseFunction</code> 时，由于 <code>lastPromise</code> 变量已经被赋值，表示上一次调用 <code>promiseFunction</code> 返回的 Promise 还没有返回，因此直接返回 <code>lastPromise</code> 变量，而不再调用 <code>promiseFunction</code>。</p><p>当第一个 Promise 返回时，会将 <code>lastPromise</code> 重置为空，这样下一次调用 <code>cachedPromiseFunction</code> 就会重新执行 <code>promiseFunction</code>。</p><p>通过这种方式，我们就实现了 promise 缓存的功能，即如果上一次调用的 Promise 没有返回，那么下一次调用函数依然会返回上一个 Promise。</p><h3>如果上一次的函数调用 promise 已经返回，下一次调用就是一个新的 promise</h3><p>修改上述的代码，让 <code>cachedPromise</code> 函数可以检测上一次的 Promise 是否已经完成，如果已经完成，则返回新的 Promise 对象。</p><p>下面是修改后的代码：</p><pre class="code-block"><code>function cachedPromise(promiseFunction) {
  let lastPromise = null;
  
  return function() {
    if (lastPromise !== null) {
      if (lastPromise.isFulfilled()) { // 如果上一次 Promise 已经完成
        lastPromise = null; // 重置上一次 Promise
      } else {
        return lastPromise; // 直接返回上一次 Promise
      }
    }
    
    lastPromise = promiseFunction();
    return lastPromise;
  }
}

const promiseFunction = () =&gt; {
  // 这里可以是任何一个返回 Promise 的异步函数
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(&#39;Resolved!&#39;);
    }, 2000)
  })
}

const cachedPromiseFunction = cachedPromise(promiseFunction);

cachedPromiseFunction().then(result =&gt; {
  console.log(result); // Resolved!
});

// 因为上次调用函数的 Promise 还未 resolve，所以这里直接返回上次的 Promise
cachedPromiseFunction().then(result =&gt; {
  console.log(result); // Resolved!
});

setTimeout(() =&gt; {
  // 上一次 Promise 已经完成，这里会返回新的 Promise 对象
  cachedPromiseFunction().then(result =&gt; {
    console.log(result); // Resolved!
  });
}, 3000);
</code></pre><p>在这段代码中，我们在闭包函数中判断上一次的 Promise 是否已经完成，如果已经完成，则将其重置为空，在下一次调用时会再次执行 <code>promiseFunction</code>，并返回新的 Promise 对象。</p><p>请注意，由于 <code>lastPromise</code> 变量被修改了，我们使用了一个名为 <code>isFulfilled()</code> 的方法来检测 Promise 是否已经完成。这个方法可以使用任何一个符合 Promises/A+ 规范的 Promise 库（如 bluebird.js）来实现。如果你使用的是原生的 Promise 对象，可以使用 <code>then()</code> 方法代替 <code>isFulfilled()</code>，如下所示：</p><pre class="code-block"><code>if (typeof lastPromise.then !== &#39;function&#39;) {
  lastPromise = null; // 重置上一次 Promise
} else {
  return lastPromise; // 直接返回上一次 Promise
}
</code></pre><p>这样，我们就实现了一个可以检测 Promise 完成状态的 promise 缓存函数。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>