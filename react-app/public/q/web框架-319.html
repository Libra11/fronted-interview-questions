<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] React16 是什么样的架构特点？【热度: 2,403】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 渲染器、react 协调器&lt;/p&gt;&lt;p&gt;React16架构可以分为三层：&lt;/p&gt;&lt;p&gt;Scheduler（调度器）—— 调度任务的优先级，高" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] React16 是什么样的架构特点？【热度: 2,403】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 渲染器、react 协调器&lt;/p&gt;&lt;p&gt;React16架构可以分为三层：&lt;/p&gt;&lt;p&gt;Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler&lt;/p&gt;&lt;p&gt;Reconciler（协调器）—— 负责找出变化的组件&lt;/p&gt;&lt;p&gt;Re" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/319" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] React16 是什么样的架构特点？【热度: 2,403】</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-04-27T15:12:52Z · 更新：2023-04-27T15:13:45Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：react16 架构、react Reconciler、react fiber、react 渲染器、react 协调器</p><p>React16架构可以分为三层：</p><p>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler</p><p>Reconciler（协调器）—— 负责找出变化的组件</p><p>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</p><p>可以看到，相较于React15，React16中新增了Scheduler（调度器）。</p><h3>Scheduler（调度器）</h3><p>以浏览器是否有剩余时间作为任务中断的标准，那么<strong>需要一种机制，当浏览器有剩余时间时通知我们</strong>。</p><p>其实部分浏览器已经实现了这个API，这就是 <code>requestIdleCallback</code> (opens new window)。但是由于以下因素，React放弃使用：</p><ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的 <code>requestIdleCallback</code> 触发的频率会变得很低</li></ul><p>基于以上原因，React实现了功能更完备的 <code>requestIdleCallback polyfill</code>，这就是<code>Scheduler</code>。除了在空闲时触发回调的功能外，<code>Scheduler</code> 还提供了多种调度优先级供任务设置。</p><p>Scheduler (opens new window) 是独立于React的库</p><h3>Reconciler（协调器）</h3><p>在 React15 中 <code>Reconciler</code> 是递归处理虚拟DOM的</p><p>在 React16 中更新工作从递归变成了可以中断的循环过程。每次循环都会调用 <code>shouldYield</code> 判断当前是否有剩余时间。</p><pre class="code-block"><code class="language-js">/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
</code></pre><p><strong>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</strong></p><p>在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记；</p><p>全部标记可以见这里： https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js</p><p>整个Scheduler与 Reconciler 的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。</p><p>可以看这里 react16 对 Reconciler 的解释：https://zh-hans.legacy.reactjs.org/docs/codebase-overview.html#fiber-reconciler</p><p>Reconciler 内部采用了 <code>Fiber</code> 的架构。</p><h3>Renderer（渲染器）</h3><p>Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。</p><h3>参考资料</h3><ul><li>https://react.iamkasong.com/preparation/newConstructure.html#react16%E6%9E%B6%E6%9E%84</li></ul><pre class="code-block"><code class="language-js">
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>