<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008595101&quot; target=&quot;_blank&quot; rel=&quot;n" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008595101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端碎碎念 之 nextTick, setTimeout 以及 setImmediate 三者的执行顺" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/52" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序？</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-09T16:30:06Z · 更新：2023-03-09T16:30:07Z</div>
    </div>
    <article class="content markdown-body"><h2>process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序</h2><p><a href="https://segmentfault.com/a/1190000008595101" target="_blank" rel="noopener">前端碎碎念 之 nextTick, setTimeout 以及 setImmediate 三者的执行顺序</a></p><p>首先来看一个非常经典的例子：</p><pre class="code-block"><code class="language-javascript">setImmediate(function(){
    console.log(1);                         // 7
},0);
setTimeout(function(){
    console.log(2);                         // 8
},0);
new Promise(function(resolve){
    console.log(3);                         // 1
    resolve();
    console.log(4);                         // 2
}).then(function(){
    console.log(5);                         // 6
});
console.log(6);                             // 3
process.nextTick(function(){
    console.log(7);                         // 5
});
console.log(8);                             // 4
//输出结果是3 4 6 8 7 5 2 1
</code></pre><p>macro-task(宏任务): script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering.</p><p>micro-task(微任务): process.nextTick, Promise(原生)，Object.observe，MutationObserver</p><p>除了script整体代码，micro-task的任务优先级高于macro-task的任务优先级。其中，script(整体代码) ，可以理解为待执行的所有代码。</p><p>所以执行顺序如下：</p><p>第一步. script整体代码被执行，执行过程为</p><ul><li>创建setImmediate macro-task</li><li>创建setTimeout macro-task</li><li>创建micro-task Promise.then 的回调，并执行script console.log(3); resolve(); console.log(4); 此时输出3和4，虽然resolve调用了，执行了但是整体代码还没执行完，无法进入Promise.then 流程。</li><li>console.log(6)输出6</li><li>process.nextTick 创建micro-task</li><li>console.log(8) 输出8</li></ul><p>第一个过程过后，已经输出了3 4 6 8</p><p>第二步. 由于其他micro-task 的 优先级高于macro-task。</p><p>此时micro-task 中有两个任务按照优先级 process.nextTick 高于 Promise。</p><p>所以先输出7，再输出5</p><p>第三步，micro-task 任务列表已经执行完毕，家下来执行macro-task. 由于setTimeout的优先级高于setIImmediate，所以先输出2，再输出1。</p><p>整个过程描述起来像是同步操作，实际上是基于Event Loop的事件循环。</p><p>关于micro-task和macro-task的执行顺序，可看下面这个例子(来自《深入浅出Node.js》)：</p><pre class="code-block"><code class="language-javascript">//加入两个nextTick的回调函数
process.nextTick(function () {
    console.log(&#39;nextTick延迟执行1&#39;);
});
process.nextTick(function () { 
    console.log(&#39;nextTick延迟执行2&#39;);
});
// 加入两个setImmediate()的回调函数
setImmediate(function () {
    console.log(&#39;setImmediate延迟执行1&#39;); 
    // 进入下次循环 
    process.nextTick(function () {
        console.log(&#39;强势插入&#39;);
    });
});
setImmediate(function () {
    console.log(&#39;setImmediate延迟执行2&#39;); 
});
console.log(&#39;正常执行&#39;);
</code></pre><p>书中给出的执行结果是：</p><pre class="code-block"><code>正常执行
nextTick延迟执行1
nextTick延迟执行2
setImmediate延迟执行1
强势插入
setImmediate延迟执行2
</code></pre><p>朴老师写那本书的时候，node最新版本为0.10.13，而我的版本是6.x</p><p>老版本的Node会优先执行process.nextTick。</p><p>当process.nextTick队列执行完后再执行一个setImmediate任务。</p><p>然后再次回到新的事件循环。所以执行完第一个setImmediate后，队列里只剩下第一个setImmediate里的process.nextTick和第二个setImmediate。</p><p>所以process.nextTick会先执行。</p><p>而在新版的Node中，process.nextTick执行完后，会循环遍历setImmediate，将setImmediate都执行完毕后再跳出循环。</p><p>所以两个setImmediate执行完后队列里只剩下第一个setImmediate里的process.nextTick。最后输出"强势插入"。</p><p><strong>关于优先级的另一个比较清晰的版本：</strong></p><p>观察者优先级</p><p>在每次轮训检查中，各观察者的优先级分别是：</p><p>idle观察者 > I/O观察者 > check观察者。</p><p>idle观察者：process.nextTick</p><p>I/O观察者：一般性的I/O回调，如网络，文件，数据库I/O等</p><p>check观察者：setImmediate，setTimeout</p><p><strong>setImmediate 和 setTimeout 的优先级</strong></p><p>看下面这个例子：</p><pre class="code-block"><code class="language-javascript">setImmediate(function () {
    console.log(&#39;1&#39;); 
});
setTimeout(function () {
    console.log(&#39;2&#39;); 
}, 0);
console.log(&#39;3&#39;);
//输出结果是3 2 1
</code></pre><p>我们知道现在HTML5规定setTimeout的最小间隔时间是4ms，也就是说0实际上也会别默认设置为最小值4ms。我们把这个延迟加大</p><p>上面说到setTimeout 的优先级比 setImmediate的高，其实这种说法是有条件的。</p><p>再看下面这个例子，为setTimeout增加了一个延迟20ms的时间：</p><pre class="code-block"><code class="language-javascript">setImmediate(function () {
    console.log(&#39;1&#39;); 
});
setTimeout(function () {
    console.log(&#39;2&#39;); 
}, 20);
console.log(&#39;3&#39;);
//输出结果是3 2 1
</code></pre><p>试试打印出这个程序的执行时间：</p><pre class="code-block"><code class="language-javascript">var t1 = +new Date();
setImmediate(function () {
    console.log(&#39;1&#39;); 
});
setTimeout(function () {
    console.log(&#39;2&#39;); 
},20);

console.log(&#39;3&#39;);
var t2 = +new Date();
console.log(&#39;time: &#39; + (t2 - t1));
//输出
3 
time: 23 
2 
1
</code></pre><p>程序执行用了23ms, 也就是说，在script(整体代码)执行完之前，setTimeout已经过时了，所以当进入macro-task的时候setTimeout依然优先于setImmediate执行。如果我们把这个值调大一点呢？</p><pre class="code-block"><code class="language-javascript">var t1 = +new Date();
setImmediate(function () {
    console.log(&#39;1&#39;); 
});
setTimeout(function () {
    console.log(&#39;2&#39;); 
},30);

console.log(&#39;3&#39;);
var t2 = +new Date();
console.log(&#39;time: &#39; + (t2 - t1));
//输出
3 
time: 23 
1 
2
</code></pre><p>setImmediate早于setTimeout执行了，因为进入macro-task 循环的时候，setTimeout的定时器还没到。</p><p>以上实验是基于6.6.0版本Node.js测试，实际上在碰到类似这种问题的时候，最好的办法是参考标准，并查阅源码，不能死记概念和顺序，因为标准也是会变的。包括此文也是自学总结，经供参考。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>