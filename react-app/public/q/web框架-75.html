<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[vue]: 手写 vue 双向绑定？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;双向绑定核心知识点&lt;/h2&gt;&lt;p&gt;如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;langua" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[vue]: 手写 vue 双向绑定？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;双向绑定核心知识点&lt;/h2&gt;&lt;p&gt;如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示：&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot; " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/75" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[vue]: 手写 vue 双向绑定？</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-03-11T08:32:37Z · 更新：2023-03-11T08:32:38Z</div>
    </div>
    <article class="content markdown-body"><h2>双向绑定核心知识点</h2><p>如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示：</p><pre class="code-block"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;MVVM 双项绑定&lt;/title&gt;
      &lt;style&gt;
        #app {
        text-align: center;
        margin-top: 100px;
        color: #888;
      }

        h1 {
        color: #aaa;
      }

        input {
        padding: 0 10px;
        width: 600px;
        line-height: 2.5;
        border: 1px solid #ccc;
        border-radius: 2px;
      }

        .bind {
        color: #766;
      }

        strong {
        color: #05BC00;
      }

        button {
        padding: 5px 10px;
        border: 1px solid #777777;
        border-radius: 5px;
        background: #ffffff;
        color: #777777;
        cursor: pointer;

      }
      &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;h1&gt;Hi，MVVM&lt;/h1&gt;
      &lt;input v-model=&quot;name&quot; placeholder=&quot;请输入内容&quot; type=&quot;text&quot;&gt;
        &lt;h1 class=&quot;bind&quot;&gt;{{name}} &#39;s age is &lt;strong&gt;{{age}}&lt;/strong&gt;&lt;/h1&gt;
        &lt;button v-on:click=&quot;sayHi&quot;&gt;点击欢迎您&lt;/button&gt;
    &lt;/div&gt;
    &lt;script&gt;
      function observe(data) {
      //如果不是一个对象，直接终止程序
      if (!data || typeof data !== &#39;object&#39;) {
      return false;
    }
      for (let key in data) {
      let val = data[key];
      let subject = new Subject();
      Object.defineProperty(data, key, {
      enumerable: true,
      configurable: true,
      get: function () {
      if (currentObserver) {
      currentObserver.subscribeTo(subject)
    }
      return val
    },
      set: function (newVal) {
      val = newVal;
      subject.notify()
    }
    });
      if (typeof val === &#39;object&#39;) {
      observe(val)
    }
    }
    }

      let id = 0;
      let currentObserver = null;

      /**
      * 订阅者对象
      */
      class Subject {
      constructor() {
      this.id = id++;
      this.observers = []
    }

      addObserver(observer) {
      this.observers.push(observer)
    }

      removeObserver(observer) {
      let index = this.observers.indexOf(observer)
      if (index &gt; -1) {
      this.observers.splice(index, 1)
    }
    }

      notify() {
      this.observers.forEach(observer =&gt; {
      observer.update()
    })
    }
    }

      /**
      * 观察者对象
      */
      class Observer {
      constructor(vm, key, cb) {
      this.subjects = {};
      this.vm = vm;
      this.key = key;
      this.cb = cb;
      this.value = this.getValue()
    }

      //如果新旧数据不相同，就直接调用cb方法
      update() {
      let oldVal = this.value;
      let value = this.getValue();
      if (value !== oldVal) {
      this.value = value;
      this.cb.bind(this.vm)(value, oldVal)
    }
    }

      //添加观察者
      subscribeTo(subject) {
      if (!this.subjects[subject.id]) {       //如果当前换擦着中不存在这个当前id的一个对象，那么吧这个对象添加为观察者
      subject.addObserver(this);
      this.subjects[subject.id] = subject     //放在观察者对象中，根据自增id来区分
    }
    }

      getValue() {
      currentObserver = this;
      let value = this.vm.$data[this.key];    //获取vm实例兑现中的data数据
      currentObserver = null;
      return value
    }
    }

      /**
      * 编译对象
      */
      class Compile {
      constructor(vm) {
      this.vm = vm; //vm对象
      this.node = vm.$el; //获取挂载的元素dom
      this.compile();//执行核心功能
    }

      compile() {
      this.traverse(this.node);//传入的参数是挂载元素dom
    }

      traverse(node) {
      if (node.nodeType === 1) {      //节点类型1：element元素
      this.compileNode(node);     //触发节点事件 双向绑定和事件触发
      node.childNodes.forEach(childNode =&gt; {
      this.traverse(childNode);       // 递归调用，如果是有子节点，重新递归
    })
    } else if (node.nodeType === 3) {       // 节点类型3： 文本元素
      this.compileText(node);     // 处理文本元素的编译
    }
    }

      // 文本编译入口
      compileText(node) {
      let reg = /{{(.+?)}}/g;
      let match;
      while (match = reg.exec(node.nodeValue)) {      //获取到文本内容
      let raw = match[0]
      let key = match[1].trim()
      node.nodeValue = node.nodeValue.replace(raw, this.vm.$data[key]);
      new Observer(this.vm, key, function (val, oldVal) {     // 订阅者核心方法
      node.nodeValue = node.nodeValue.replace(oldVal, val)
    })
    }
    }

      // 节点编译入口
      compileNode(node) {
      let attrs = [...node.attributes];//获取标签属性
      attrs.forEach(attr =&gt; {
      if (this.isModelDirective(attr.name)) { //截取是绑定数据的情况
      this.bindModel(node, attr); //绑定数据
    } else if (this.isEventDirective(attr.name)) { //截取是绑定事件的情况
      this.bindEventHander(node, attr); //触发事件
    }
    })
    }

      /**
       * 双向绑定数据
       * @param node  标签节点
       * @param attr  标签节点的属性名
       */
      bindModel(node, attr) {
      let key = attr.value;// 获取到传递过来的属性的key的值
      node.value = this.vm.$data[key]; //给节点绑定值，对应的值就是vm实例里面data对应key的值
      new Observer(this.vm, key, function (newVal) {
      node.value = newVal
    });
      node.oninput = (e) =&gt; { //监听节点的input事件
      this.vm.$data[key] = e.target.value //过去输入框中输入的value值，把这个值放入到vm的data实例中去
    }
    }

      /**
       *
       * @param node
       * @param attr
       */
      bindEventHander(node, attr) {
      let eventType = attr.name.substr(5); //获取节点属性,从第五个下标开始截取后面的字符串作为：key(事件类型)
      let methodName = attr.value; //获取节点的属性的value
      node.addEventListener(eventType, this.vm.$methods[methodName]);//通过事件类型，来触发事件，事件就是vm实例中方法
    }

      //赛选出传入的node属性是v-model的情况
      isModelDirective(attrName) {
      return attrName === &#39;v-model&#39;
    }

      //赛选出传入的node属性是 v-on的情况
      isEventDirective(attrName) {
      return attrName.indexOf(&#39;v-on&#39;) === 0
    }
    }

      class mvvm {
      constructor(opts) {     //这里面的函数是实例化的时候执行的
      this.init(opts);
      observe(this.$data);
      new Compile(this);      //变异当前对象
    }

      init(opts) {
      if (opts.el.nodeType === 1) {
      this.$el = opts.el
    } else {
      this.$el = document.querySelector(opts.el)
    }

      this.$data = opts.data || {};
      this.$methods = opts.methods || {};
      //把$data 中的数据直接代理到当前 vm 对象
      for (let key in this.$data) {
      Object.defineProperty(this, key, {
      enumerable: true,
      configurable: true,
      get: () =&gt; {
      return this.$data[key]
    },
      set: newVal =&gt; {
      this.$data[key] = newVal
    }
    })
    }
      //让 this.$methods 里面的函数中的 this，都指向当前的 this，也就是 vm对象实例
      for (let key in this.$methods) {
      this.$methods[key] = this.$methods[key].bind(this);
    }
    }
    }


      /**
      * 实例化MVVM对象， 主入口
      * @type {mvvm}
      */
      let vm = new mvvm({
      el: &#39;#app&#39;,
      data: {
      name: &#39;YanLe&#39;,
      age: 3
    },
      methods: {
      sayHi: function () {
      alert(`hi ${this.name}`)
    }
    }
    });

      let clock = setInterval(function () {
      vm.age++;  //等同于 vm.$data.age

      if (vm.age === 10) clearInterval(clock)
    }, 1000)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>