<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>闭包有哪些使用场景，请举例【热度: 679】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：闭包使用场景&lt;/p&gt;&lt;p&gt;闭包在 JavaScript 中有很多实用的使用场景，以下是一些主要的场景：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一、数据隐藏和封装&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;保护变量：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="闭包有哪些使用场景，请举例【热度: 679】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：闭包使用场景&lt;/p&gt;&lt;p&gt;闭包在 JavaScript 中有很多实用的使用场景，以下是一些主要的场景：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一、数据隐藏和封装&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;保护变量：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;闭包可以创建一个私有作用域，将变量封装在函数内部，防止外部直接访问和修改。只有通过特定的函数接口才能访问和操作这些" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/1022" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>闭包有哪些使用场景，请举例【热度: 679】</h1>
      <div class="subtitle">小米 · JavaScript · 小米</div>
      <div class="meta">创建：2024-10-26T06:43:59Z · 更新：2024-10-26T06:56:04Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：闭包使用场景</p><p>闭包在 JavaScript 中有很多实用的使用场景，以下是一些主要的场景：</p><p><strong>一、数据隐藏和封装</strong></p><ol><li>保护变量：</li></ol><ul><li>闭包可以创建一个私有作用域，将变量封装在函数内部，防止外部直接访问和修改。只有通过特定的函数接口才能访问和操作这些变量。</li><li>例如：</li></ul><p>```javascript</p><p>function createCounter() {</p><p>let count = 0;</p><p>return {</p><p>increment() {</p><p>count++;</p><p>},</p><p>getCount() {</p><p>return count;</p><p>},</p><p>};</p><p>}</p><p>const counter = createCounter();</p><p>counter.increment();</p><p>console.log(counter.getCount()); // 1</p><p>```</p><ul><li>在这个例子中，<code>count</code>变量被封装在<code>createCounter</code>函数内部，外部无法直接访问，只能通过返回的对象上的方法来操作<code>count</code>。</li></ul><ol><li>模拟私有方法：</li></ol><ul><li>在面向对象编程中，可以使用闭包来模拟私有方法。私有方法只能在对象内部被访问，外部无法直接调用。</li><li>例如：</li></ul><p>```javascript</p><p>const myObject = (function () {</p><p>let privateVariable = 0;</p><p>function privateMethod() {</p><p>privateVariable++;</p><p>console.log(privateVariable);</p><p>}</p><p>return {</p><p>publicMethod() {</p><p>privateMethod();</p><p>},</p><p>};</p><p>})();</p><p>myObject.publicMethod(); // 1</p><p>```</p><ul><li>在这个例子中，<code>privateMethod</code>和<code>privateVariable</code>只能在内部函数中被访问，外部通过调用<code>publicMethod</code>间接访问了私有方法。</li></ul><p><strong>二、函数柯里化（Currying）</strong></p><ol><li>逐步参数化：</li></ol><ul><li>闭包可以用于实现函数柯里化，将一个多参数的函数转换为一系列单参数的函数。每次调用只接受一部分参数，并返回一个新的函数，直到所有参数都被提供。</li><li>例如：</li></ul><p>```javascript</p><p>function add(a) {</p><p>return function (b) {</p><p>return function (c) {</p><p>return a + b + c;</p><p>};</p><p>};</p><p>}</p><p>const addFiveAndSixAndSeven = add(5)(6)(7);</p><p>console.log(addFiveAndSixAndSeven); // 18</p><p>```</p><ul><li>在这个例子中，<code>add</code>函数通过闭包逐步接受参数，最后返回一个计算结果。</li></ul><ol><li>灵活的参数传递：</li></ol><ul><li>函数柯里化可以使函数的参数传递更加灵活，特别是在需要部分应用参数或者延迟参数传递的情况下。</li><li>例如，可以先创建一个部分应用参数的函数，然后在需要的时候再传递剩余的参数。</li></ul><p><strong>三、回调函数和事件处理</strong></p><ol><li>保存外部环境：</li></ol><ul><li>在异步编程或者事件处理中，闭包可以保存外部函数的变量和状态，使得回调函数能够访问这些信息。</li><li>例如：</li></ul><p>```javascript</p><p>function setTimeoutWithMessage(message) {</p><p>setTimeout(function () {</p><p>console.log(message);</p><p>}, 1000);</p><p>}</p><p>setTimeoutWithMessage("Hello after 1 second!");</p><p>```</p><ul><li>在这个例子中，回调函数内部的<code>message</code>变量是通过闭包从外部函数中获取的，即使外部函数已经执行完毕，回调函数仍然能够访问到这个变量。</li></ul><ol><li>事件处理程序：</li></ol><ul><li>在 DOM 事件处理中，闭包可以用于保存与事件相关的状态和数据。</li><li>例如：</li></ul><p>```html</p><p><button id="myButton">Click me</button></p><p><script></p><p>document.getElementById("myButton").addEventListener("click", function () {</p><p>const buttonText = this.textContent;</p><p>console.log(<code>Button clicked: ${buttonText}</code>);</p><p>});</p><p></script></p><p>```</p><ul><li>在这个例子中，事件处理程序内部的<code>buttonText</code>变量是通过闭包从外部环境中获取的，每次点击按钮时，都能正确地打印出按钮的文本内容。</li></ul><p><strong>四、记忆化（Memoization）</strong></p><ol><li>缓存计算结果：</li></ol><ul><li>闭包可以用于实现记忆化，将函数的计算结果缓存起来，避免重复计算。如果相同的参数再次被传入，直接返回缓存的结果，而不是重新计算。</li><li>例如：</li></ul><p>```javascript</p><p>function memoizedAdd() {</p><p>let cache = {};</p><p>return function (a, b) {</p><p>const key = <code>${a},${b}</code>;</p><p>if (cache[key]) {</p><p>return cache[key];</p><p>} else {</p><p>const result = a + b;</p><p>cache[key] = result;</p><p>return result;</p><p>}</p><p>};</p><p>}</p><p>const memoizedAddFunction = memoizedAdd();</p><p>console.log(memoizedAddFunction(2, 3)); // 5</p><p>console.log(memoizedAddFunction(2, 3)); // 5（直接从缓存中获取结果）</p><p>```</p><ul><li>在这个例子中，<code>memoizedAdd</code>函数内部的<code>cache</code>对象用于缓存计算结果，通过闭包保存了这个缓存对象，使得每次调用函数时都能访问到它。</li></ul><ol><li>提高性能：</li></ol><ul><li>对于计算复杂或者频繁调用的函数，记忆化可以显著提高性能，减少不必要的计算。</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>