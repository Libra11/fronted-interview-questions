<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>async/await 函数到底要不要加 try catch ?【热度: 645】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：async/await函数、async/await函数 是否需要 try/catch、async/await函数 与 try/catch 关系、try/catch 使用场景&lt;/p&gt;&lt;p&gt;当使用 async 函数的时候，很多文章都说建" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="async/await 函数到底要不要加 try catch ?【热度: 645】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：async/await函数、async/await函数 是否需要 try/catch、async/await函数 与 try/catch 关系、try/catch 使用场景&lt;/p&gt;&lt;p&gt;当使用 async 函数的时候，很多文章都说建议用 &lt;code&gt;try catch&lt;/code&gt; 来捕获异常, 可是实际上很多项目的代码，遵循的并不是严谨，很多都没有" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/481" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>async/await 函数到底要不要加 try catch ?【热度: 645】</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-07-23T03:56:33Z · 更新：2024-03-21T08:17:20Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：async/await函数、async/await函数 是否需要 try/catch、async/await函数 与 try/catch 关系、try/catch 使用场景</p><p>当使用 async 函数的时候，很多文章都说建议用 <code>try catch</code> 来捕获异常, 可是实际上很多项目的代码，遵循的并不是严谨，很多都没有用，甚至 catch 函数都没写，这是为什么呢？</p><h3>示例1 ：使用 try catch</h3><pre class="code-block"><code class="language-javascript">function getUserInfo () {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
                reject(&#39;请求异常&#39;)
        }, 1000)
    })
}

async function logined () {
    try {
        let userInfo = await getUserInfo()
        // 执行中断
        let pageInfo = await getPageInfo(userInfo?.userId)
    } catch(e) {
        console.warn(e)
    }
}

logined()
</code></pre><p>执行后会在 catch 里捕获 <code>请求异常</code>，然后 getUserInfo 函数中断执行，这是符合逻辑的，对于有依赖关系的接口，中断执行可以避免程序崩溃，这里唯一的问题是 try catch 貌似占据了太多行数，如果每个接口都写的话看起来略显冗余。</p><h3>示例2： 直接 catch</h3><p>鉴于正常情况下，<code>await</code> 命令后面是一个 Promise 对象, 所以上面代码可以很自然的想到优化方案：</p><pre class="code-block"><code class="language-javascript">function getUserInfo () {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
                reject(&#39;请求异常&#39;)
        }, 1000)
    })
}

async function logined () {
    let userInfo = await getUserInfo().catch(e =&gt; console.warn(e))
    // 执行没有中断，userInfo 为 undefined
    if (!userInfo) return // 需要做非空校验
    let pageInfo = await getPageInfo(userInfo?.userId)
}

logined()
</code></pre><p>执行后 catch 可以正常捕获异常，但是程序没有中断，返回值 <code>userInfo</code> 为 <code>undefined</code>, 所以如果这样写的话，就需要对返回值进行非空校验, <code>if (!userInfo) return</code> 我觉得这样有点反逻辑，异常时就应该中断执行才对；</p><h3>示例3：在 catch 里 reject</h3><p>可以继续优化，在 catch 里面加一行 <code>return Promise.reject(e)</code>, 可以使 await 中断执行；</p><p>完整代码：</p><pre class="code-block"><code class="language-javascript">function getUserInfo () {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            reject(&#39;请求异常&#39;)
        }, 1000)
    })
}

async function logined () {
    let userInfo = await getUserInfo().catch(e =&gt; {
        console.warn(e)
        return Promise.reject(e) // 会导致控制台出现 uncaught (in promise) 报错信息
    })
    // 执行中断
    let pageInfo = await getPageInfo(userInfo?.userId)
}

logined()
</code></pre><p>一般我们在项目里都是用 axios 或者 fetch 之类发送请求，会对其进行一个封装，也可以在里面进行 catch 操作，对错误信息先一步处理，</p><p>至于是否需要 reject，就看你是否想要在 await 命令异常时候中断了；</p><p>不使用 reject 则不会中断，但是需要每个接口拿到 response 后先 非空校验， 使用 reject 则会在异常处中断，并且会在控制台暴露 <code>uncaught (in promise)</code> 报错信息。</p><h3>建议</h3><p>不需要在 await 处异常时中断，可以这样写，需要做非空校验，控制台不会有报错信息</p><pre class="code-block"><code class="language-javascript">let userInfo = await getUserInfo().catch(e =&gt; console.warn(e))
if (!userInfo) return
</code></pre><p>需要在 await 处异常时中断，并且在意控制台报错，可以这样写</p><pre class="code-block"><code class="language-javascript">try {
    let userInfo = await getUserInfo()
    // 执行中断
    let pageInfo = await getPageInfo(userInfo?.userId)
} catch(e) {
    console.warn(e)
}

</code></pre><p>需要在 await 处异常时中断，但是不在意控制台报错，则可以这样写</p><pre class="code-block"><code class="language-javascript">
let userInfo = await getUserInfo().catch(e =&gt; {
    console.warn(e)
    return Promise.reject(e) // 会导致控制台出现 uncaught (in promise) 报错信息
})
// 执行中断
let pageInfo = await getPageInfo(userInfo?.userId)

</code></pre><h3>总结</h3><p>几种写法，初看可能觉得第三种 catch 这种写法是最好的，但是细想下，从用户体验上来看，我觉得 try catch 是最好的，逻辑直观、符合同步编程思维，控制台不会暴露 <code>uncaught (in promise)</code> 报错信息；</p><p>而链式调用的 catch (里面再 reject)，是传统 promise 的回调写法，既然已经用 async await 这种同步编程写法了，再用 catch 链式写法，感觉没必要。</p><h2>Comments / Answers</h2><hr /><p><strong>java6688</strong> at 2024-03-21T08:17:19Z</p><p>let userInfo = await getUserInfo()</p><p>//  上面getUserInfo方法已经reject，根本就不会向下执行了，为啥还要像下面这样写</p><p>let userInfo = await getUserInfo().catch(e => {</p><p>console.warn(e)</p><p>return Promise.reject(e) // 会导致控制台出现 uncaught (in promise) 报错信息</p><p>})</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>