<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] render 阶段的执行过程【热度: 1,793】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 协调器&lt;/p&gt;&lt;p&gt;render阶段开始于&lt;code&gt;performSyncWorkOnRoot&lt;/code&gt;或&lt;code&gt;performC" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] render 阶段的执行过程【热度: 1,793】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 协调器&lt;/p&gt;&lt;p&gt;render阶段开始于&lt;code&gt;performSyncWorkOnRoot&lt;/code&gt;或&lt;code&gt;performConcurrentWorkOnRoot&lt;/code&gt;方法的调用。这取决于本次更新是同步更新还是异步更新。&lt;/p&gt;&lt;pre" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/324" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] render 阶段的执行过程【热度: 1,793】</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-04-30T15:45:51Z · 更新：2023-04-30T15:45:52Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：react16 架构、react Reconciler、react fiber、react 协调器</p><p>render阶段开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p><pre class="code-block"><code class="language-js">// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null &amp;&amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
</code></pre><p>可以看到，他们唯一的区别是是否调用shouldYield。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。</p><p>workInProgress代表当前已创建的workInProgress fiber。</p><p>performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。</p><p>通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。</p><h3>创建节点</h3><p>首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用<code>beginWork</code>方法 (opens new window)。</p><p>该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。</p><p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p><p>在“归”阶段会调用<code>completeWork</code> (opens new window)处理Fiber节点。</p><p>当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。</p><p>如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。</p><p>“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。</p><p><strong>举例</strong></p><p>代码如下：</p><pre class="code-block"><code class="language-js">function App() {
  return (
    &lt;div&gt;
      i am
      &lt;span&gt;KaSong&lt;/span&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;root&quot;));
</code></pre><p>对应的 fiber 树结构如下</p><p><img alt="image" src="https://user-images.githubusercontent.com/22188674/235359287-0f448fa3-657d-40b4-8cff-92327ef5414c.png" /></p><p>render 阶段会依次执行</p><pre class="code-block"><code>1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. &quot;i am&quot; Fiber beginWork
5. &quot;i am&quot; Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
</code></pre><h3>beginWork</h3><p>源码链接： https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075</p><p>工作流程图：</p><p><img alt="image" src="https://user-images.githubusercontent.com/22188674/235361451-6440499a-09dc-4478-81e4-e0585e815f0b.png" /></p><p>beginWork的工作是传入当前Fiber节点，创建子Fiber节点，我们从传参来看看具体是如何做的。</p><p><strong>传参</strong></p><pre class="code-block"><code class="language-ts">function beginWork(
  current: Fiber | null, // 当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate
  workInProgress: Fiber, // 当前组件对应的Fiber节点
  renderLanes: Lanes, // 优先级相关，在讲解Scheduler时再讲解
): Fiber | null {
  // ...省略函数体
}
</code></pre><p>beginWork的工作可以分为两部分:</p><ul><li><code>update</code>时：如果current存在，在满足一定条件时可以复用current节点，这样就能克隆current.child作为workInProgress.child，而不需要新建workInProgress.child。</li><li><code>mount</code>时：除fiberRootNode以外，current === null。会根据fiber.tag不同，创建不同类型的子Fiber节点</li></ul><pre class="code-block"><code class="language-ts">function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {

  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）
  if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }

  // mount时：根据tag不同，创建不同的子Fiber节点
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    // ...省略
    case LazyComponent:
    // ...省略
    case FunctionComponent:
    // ...省略
    case ClassComponent:
    // ...省略
    case HostRoot:
    // ...省略
    case HostComponent:
    // ...省略
    case HostText:
    // ...省略
    // ...省略其他类型
  }
}
</code></pre><h4>update时</h4><p>满足如下情况时didReceiveUpdate === false（即可以直接复用前一次更新的子Fiber，不需要新建子Fiber）</p><pre class="code-block"><code class="language-ts">if (current !== null) {
  const oldProps = current.memoizedProps;
  const newProps = workInProgress.pendingProps;

  if (
    oldProps !== newProps ||
    hasLegacyContextChanged() ||
    (__DEV__ ? workInProgress.type !== current.type : false)
  ) {
    didReceiveUpdate = true;
  } else if (!includesSomeLane(renderLanes, updateLanes)) {
    didReceiveUpdate = false;
    switch (workInProgress.tag) {
      // 省略处理
    }
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceiveUpdate = false;
  }
} else {
  didReceiveUpdate = false;
}
</code></pre><ol><li><code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即props与fiber.type不变</li><li><code>!includesSomeLane(renderLanes, updateLanes)</code>，即当前Fiber节点优先级不够，会在讲解Scheduler时介绍</li></ol><h4>mount</h4><p>当不满足优化路径时，我们就进入第二部分，新建子Fiber。</p><pre class="code-block"><code class="language-ts">// mount时：根据tag不同，创建不同的Fiber节点
switch (workInProgress.tag) {
  case IndeterminateComponent:
  // ...省略
  case LazyComponent:
  // ...省略
  case FunctionComponent:
  // ...省略
  case ClassComponent:
  // ...省略
  case HostRoot:
  // ...省略
  case HostComponent:
  // ...省略
  case HostText:
  // ...省略
  // ...省略其他类型
}
</code></pre><p>我们可以看到，根据fiber.tag不同，进入不同类型Fiber的创建逻辑。</p><p>对于我们常见的组件类型，如<code>（FunctionComponent/ClassComponent/HostComponent）</code>，最终会进入<code>reconcileChildren</code> (opens new window)方法。</p><h4>reconcileChildren</h4><ul><li>对于mount的组件，他会创建新的子Fiber节点</li><li>对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点</li></ul><pre class="code-block"><code class="language-ts">export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  if (current === null) {
    // 对于mount的组件
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 对于update的组件
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
</code></pre><p>从代码可以看出，和beginWork一样，他也是通过current === null ?区分mount与update。</p><p>不论走哪个逻辑，最终他会生成新的子Fiber节点并赋值给workInProgress.child，作为本次beginWork返回值 (opens new window)</p><p>，并作为下次performUnitOfWork执行时workInProgress的传参</p><h4>effectTag</h4><p>我们知道，render阶段的工作是在内存中进行，当工作结束后会通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型就保存在fiber.effectTag中。</p><pre class="code-block"><code class="language-ts">// DOM需要插入到页面中
export const Placement = /*                */ 0b00000000000010;
// DOM需要更新
export const Update = /*                   */ 0b00000000000100;
// DOM需要插入到页面中并更新
export const PlacementAndUpdate = /*       */ 0b00000000000110;
// DOM需要删除
export const Deletion = /*                 */ 0b00000000001000;
</code></pre><p>通过二进制表示effectTag，可以方便的使用位操作为fiber.effectTag赋值多个effect。</p><p>那么，如果要通知Renderer将Fiber节点对应的DOM节点插入页面中，需要满足两个条件：</p><ol><li><code>fiber.stateNode</code>存在，即Fiber节点中保存了对应的DOM节点</li></ol><ol><li><code>(fiber.effectTag &amp; Placement) !== 0</code>，即 <code>Fiber节点存在Placement effectTag</code></li></ol><p>我们知道，mount时，fiber.stateNode === null，且在reconcileChildren中调用的mountChildFibers不会为Fiber节点赋值effectTag。那么首屏渲染如何完成呢？</p><p>针对第一个问题，<code>fiber.stateNode</code>会在<code>completeWork</code>中创建，我们会在下一节介绍。</p><p>第二个问题的答案十分巧妙：假设<code>mountChildFibers</code>也会赋值effectTag，那么可以预见mount时整棵Fiber树所有节点都会有Placement</p><p>effectTag。那么commit阶段在执行DOM操作时每个节点都会执行一次插入操作，这样大量的DOM操作是极低效的。</p><p>为了解决这个问题，<strong>在mount时只有rootFiber会赋值Placement effectTag</strong>，在commit阶段只会执行一次插入操作。</p><h3>completeWork</h3><p>流程图：</p><p><img alt="image" src="https://user-images.githubusercontent.com/22188674/235362048-ce278ddf-b944-4ed6-a6af-e3b1502fb6c7.png" /></p><p>类似beginWork，completeWork也是针对不同fiber.tag调用不同的处理逻辑。</p><pre class="code-block"><code class="language-ts">function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;
    case ClassComponent: {
      // ...省略
      return null;
    }
    case HostRoot: {
      // ...省略
      updateHostContainer(workInProgress);
      return null;
    }
    case HostComponent: {
      // ...省略
      return null;
    }
    // ...省略
  }
  // ...省略
}
</code></pre><p>我们重点关注页面渲染所必须的 <code>HostComponent</code>（即原生DOM组件对应的Fiber节点），其他类型Fiber的处理留在具体功能实现时讲解。</p><h4>处理 HostComponent</h4><p>和<code>beginWork</code>一样，我们根据 <code>current === null</code> ?判断是mount还是<code>update</code>。</p><p>同时针对 <code>HostComponent</code>，判断 <code>update</code> 时我们还需要考虑 <code>workInProgress.stateNode != null</code> ?（即该Fiber节点是否存在对应的DOM节点）</p><pre class="code-block"><code class="language-ts">case
HostComponent: {
  popHostContext(workInProgress);
  const rootContainerInstance = getRootHostContainer();
  const type = workInProgress.type;

  if (current !== null &amp;&amp; workInProgress.stateNode != null) {
    // update的情况
    // ...省略
  } else {
    // mount的情况
    // ...省略
  }
  return null;
}
</code></pre><h4>update 时</h4><p>当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：</p><ul><li><code>onClick、onChange</code> 等回调函数的注册</li><li>处理 <code>style prop</code></li><li>处理 <code>DANGEROUSLY_SET_INNER_HTML prop</code></li><li>处理 <code>children prop</code></li></ul><p>我们去掉一些当前不需要关注的功能（比如ref）。可以看到最主要的逻辑是调用updateHostComponent方法。</p><pre class="code-block"><code class="language-ts">if (current !== null &amp;&amp; workInProgress.stateNode != null) {
  // update的情况
  updateHostComponent(
    current,
    workInProgress,
    type,
    newProps,
    rootContainerInstance,
  );
}
</code></pre><p>在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。</p><p><code>workInProgress.updateQueue = (updatePayload: any);</code></p><p>其中updatePayload为数组形式，他的偶数索引的值为变化的prop key，奇数索引的值为变化的prop value。</p><h4>mount 时</h4><p>同样，我们省略了不相关的逻辑。可以看到，mount时的主要逻辑包括三个：</p><ul><li>为Fiber节点生成对应的DOM节点</li><li>将子孙DOM节点插入刚生成的DOM节点中</li><li>与update逻辑中的updateHostComponent类似的处理props的过程</li></ul><pre class="code-block"><code class="language-ts">// mount的情况

// ...省略服务端渲染相关逻辑

const currentHostContext = getHostContext();
// 为fiber创建对应DOM节点
const instance = createInstance(
    type,
    newProps,
    rootContainerInstance,
    currentHostContext,
    workInProgress,
  );
// 将子孙DOM节点插入刚生成的DOM节点中
appendAllChildren(instance, workInProgress, false, false);
// DOM节点赋值给fiber.stateNode
workInProgress.stateNode = instance;

// 与update逻辑中的updateHostComponent类似的处理props的过程
if (
  finalizeInitialChildren(
    instance,
    type,
    newProps,
    rootContainerInstance,
    currentHostContext,
  )
) {
  markUpdate(workInProgress);
}
</code></pre><p>mount时只会在rootFiber存在Placement effectTag。那么commit阶段是如何通过一次插入DOM操作（对应一个Placement effectTag）将整棵DOM树插入页面的呢？</p><p>原因就在于 <code>completeWork中的appendAllChildren</code> 方法。</p><p>由于<code>completeWork</code>属于“归”阶段调用的函数，每次调用<code>appendAllChildren</code>时都会将已生成的子孙DOM节点插入当前生成的DOM节点下。那么当“归”到rootFiber时，我们已经有一个构建好的离屏DOM树。</p><h4>effectList</h4><p>至此render阶段的绝大部分工作就完成了。</p><p>还有一个问题：作为DOM操作的依据，commit阶段需要找到所有有effectTag的Fiber节点并依次执行effectTag对应操作。难道需要在commit阶段再遍历一次Fiber树寻找effectTag !== null的Fiber节点么？</p><p>这显然是很低效的。</p><p>为了解决这个问题，在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。</p><p>effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。</p><p>类似appendAllChildren，在“归”阶段，所有有effectTag的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表。</p><pre class="code-block"><code>                       nextEffect         nextEffect
rootFiber.firstEffect -----------&gt; fiber -----------&gt; fiber
</code></pre><p>这样，在commit阶段只需要遍历<code>effectList</code>就能执行所有<code>effect</code>了。</p><h3>流程结尾</h3><p>至此，render阶段全部工作完成。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。</p><p><code>commitRoot(root);</code></p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>