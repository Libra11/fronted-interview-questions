<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Service Worker 是如何缓存 http 请求资源的？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;Service Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。&lt;/p&gt;&lt;p&gt;Service Worker 可以通过以下步骤来缓存 http 请求资源：&lt;/p&gt;&lt;ol&gt;&lt;li" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="Service Worker 是如何缓存 http 请求资源的？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;Service Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。&lt;/p&gt;&lt;p&gt;Service Worker 可以通过以下步骤来缓存 http 请求资源：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;注册 Service Worker：通过在页面中注册 Service Worker，可以告诉浏览器使用 Service" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/254" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>Service Worker 是如何缓存 http 请求资源的？</h1>
      <div class="subtitle">web应用场景 · web应用场景 · 京东</div>
      <div class="meta">创建：2023-04-05T13:53:20Z · 更新：2023-04-05T13:53:21Z</div>
    </div>
    <article class="content markdown-body"><p>Service Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。</p><p>Service Worker 可以通过以下步骤来缓存 http 请求资源：</p><ol><li>注册 Service Worker：通过在页面中注册 Service Worker，可以告诉浏览器使用 Service Worker 来处理网络请求。</li></ol><ol><li>安装 Service Worker：一旦 Service Worker 被注册，浏览器就会下载并安装它。在安装过程中，Service Worker 可以缓存一些静态资源（如 HTML、CSS 和 JavaScript 文件）。</li></ol><ol><li>激活 Service Worker：一旦 Service Worker 安装成功，它就可以被激活。在激活过程中，Service Worker 可以删除旧版本的缓存，或者执行其他一些操作。</li></ol><ol><li>拦截网络请求：一旦 Service Worker 被激活，它就可以拦截浏览器发送的网络请求。</li></ol><ol><li>处理网络请求：当 Service Worker 拦截到网络请求时，它可以执行一些自定义的逻辑来处理这些请求。例如，它可以检查缓存中是否已经存在该请求的响应，如果存在，则直接返回缓存中的响应，否则，它可以将请求发送到服务器并缓存服务器的响应。</li></ol><ol><li>更新缓存：如果缓存中的资源发生了变化，Service Worker 可以自动更新缓存。例如，它可以在后台下载最新的资源，并更新缓存中的文件。</li></ol><p>需要注意的是，使用 Service Worker 来缓存 http 请求资源需要一些额外的工作。例如，<strong>需要编写 Service Worker 脚本来处理请求，并且需要将该脚本注册到浏览器中</strong>。此外，还需要考虑一些缓存策略，以确保缓存的数据与服务器上的数据保持同步。</p><p><strong>下面是一个使用 Service Worker 实现缓存的示例代码：</strong></p><pre class="code-block"><code class="language-js">// 注册 Service Worker
if (&#39;serviceWorker&#39; in navigator) {
  window.addEventListener(&#39;load&#39;, function() {
    navigator.serviceWorker.register(&#39;/service-worker.js&#39;).then(function(registration) {
      console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);
    }, function(err) {
      console.log(&#39;ServiceWorker registration failed: &#39;, err);
    });
  });
}

// 安装 Service Worker
self.addEventListener(&#39;install&#39;, function(event) {
  console.log(&#39;ServiceWorker install&#39;);
  event.waitUntil(
    caches.open(&#39;my-cache&#39;).then(function(cache) {
      return cache.addAll([
        &#39;/&#39;,
        &#39;/index.html&#39;,
        &#39;/styles.css&#39;,
        &#39;/script.js&#39;,
        &#39;/image.png&#39;
      ]);
    })
  );
});

// 激活 Service Worker
self.addEventListener(&#39;activate&#39;, function(event) {
  console.log(&#39;ServiceWorker activate&#39;);
});

// 拦截网络请求
self.addEventListener(&#39;fetch&#39;, function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      if (response) {
        console.log(&#39;ServiceWorker fetch from cache:&#39;, event.request.url);
        return response;
      } else {
        console.log(&#39;ServiceWorker fetch from network:&#39;, event.request.url);
        return fetch(event.request);
      }
    })
  );
});

// 更新缓存
self.addEventListener(&#39;activate&#39;, event =&gt; {
  event.waitUntil(
    caches.keys().then(cacheNames =&gt; {
      return Promise.all(
        cacheNames.filter(cacheName =&gt; {
          return cacheName.startsWith(&#39;my-cache&#39;) &amp;&amp;
            cacheName !== &#39;my-cache&#39;;
        }).map(cacheName =&gt; {
          return caches.delete(cacheName);
        })
      );
    })
  );
});
</code></pre><p>当网络请求到来时，会首先在缓存中查找对应的资源，如果有则直接返回缓存中的资源，否则从网络中获取资源并返回。这样就可以实现基本的离线缓存功能。</p><p>在这个示例中，当 Service Worker 被安装时，我们打开一个新的缓存并将应用程序的静态资源添加到缓存中。在 fetch 事件中，我们拦截每个网络请求并尝试匹配它们到我们的缓存中，如果匹配到了则返回缓存的响应，否则通过 fetch 方法从网络中获取资源。在 activate 事件中，我们可以更新缓存，删除旧的缓存项并将新的缓存项添加到缓存中。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>