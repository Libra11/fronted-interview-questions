<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[Vue] 响应式原理中 Object.defineProperty 有什么缺陷 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;Vue 2 中使用&lt;code&gt;Object.defineProperty&lt;/code&gt;来实现其响应式系统存在一些限制和问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;深度检测&lt;/strong&gt;：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Vue 2中对于对象的处理是递归的；对于每个属性，Vue" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[Vue] 响应式原理中 Object.defineProperty 有什么缺陷" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;Vue 2 中使用&lt;code&gt;Object.defineProperty&lt;/code&gt;来实现其响应式系统存在一些限制和问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;深度检测&lt;/strong&gt;：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Vue 2中对于对象的处理是递归的；对于每个属性，Vue会逐层使用&lt;code&gt;Object.defineProperty&lt;/code&gt;将其转换成 getter/setter。这" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/217" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[Vue] 响应式原理中 Object.defineProperty 有什么缺陷</h1>
      <div class="subtitle">腾讯 · web框架 · 腾讯</div>
      <div class="meta">创建：2023-03-28T14:43:24Z · 更新：2024-04-13T14:00:17Z</div>
    </div>
    <article class="content markdown-body"><p>Vue 2 中使用<code>Object.defineProperty</code>来实现其响应式系统存在一些限制和问题：</p><ol><li><strong>深度检测</strong>：</li></ol><p>Vue 2中对于对象的处理是递归的；对于每个属性，Vue会逐层使用<code>Object.defineProperty</code>将其转换成 getter/setter。这样，当你访问或修改嵌套较深的属性时（如<code>a.b.c</code>），Vue已经提前将<code>a</code>、<code>a.b</code>和<code>a.b.c</code>的属性转换为响应式，能够追踪它们的变化。</p><ol><li><strong>数组限制</strong>：</li></ol><p><code>Object.defineProperty</code>无法检测到数组索引的变化，因此Vue重写了数组的变异方法（如<code>push</code>、<code>pop</code>、<code>splice</code>等）来实现对数组的响应式监听。</p><ol><li><strong>对象属性添加或删除的限制</strong>：</li></ol><p>因为<code>Object.defineProperty</code>只能在初始化的时候应用于属性，当你在一个已经创建的Vue实例上添加新属性时，这个新属性是非响应式的。如果你想要它是响应式的，需要使用<code>Vue.set()</code>或<code>this.$set()</code>方法添加新属性。</p><ol><li><strong>性能问题</strong>：</li></ol><p>因为<code>Object.defineProperty</code>是递归地对对象的每一个属性进行处理，所以在处理具有大量属性或深层嵌套对象时，可能会有较大的性能开销。</p><p>关于处理<code>a.b.c</code>类型的属性，Vue 2内部会递归地遍历对象<code>a</code>的所有属性，为它们各自使用<code>Object.defineProperty</code>定义getter和setter。如果<code>b</code>是<code>a</code>的属性，那么同样会针对<code>b</code>做这样的处理，以及它的所有属性，包括<code>c</code>等。这样，在访问或修改<code>a.b.c</code>时，Vue可以追踪到这些变化并触发相关的更新。</p><pre class="code-block"><code class="language-javascript">function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      // 依赖收集等操作
      return val;
    },
    set: function reactiveSetter(newVal) {
      if (newVal === val) return;
      val = newVal;
      // 触发更新视图等操作
    }
  });

  // 如果val本身还是对象，则递归处理
  if (typeof val === &#39;object&#39;) {
    reactive(val);
  }
}

function reactive(obj) {
  for (let key in obj) {
    defineReactive(obj, key, obj[key]);
  }
}
</code></pre><p>在上面的<code>reactive</code>函数中，我们将一个对象转换成响应式对象。这是Vue内部实现响应式的简化版原理。不过，Vue的响应式系统要复杂得多，它还涉及依赖收集和派发更新等机制。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>