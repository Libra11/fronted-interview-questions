<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>websocket 断联之后如何重连，且保证断链期间数据不丢失【热度: 200】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：websocket 断联数据不丢失&lt;/p&gt;&lt;p&gt;实现 WebSocket 的自动重连并保证断连期间数据不丢失，通常需要在客户端实现一些机制来管理连接状态、定时重试以及缓存未成功发送的消息。以下是一个简单的步骤和策略指南：&lt;/p&gt;&lt;h" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="websocket 断联之后如何重连，且保证断链期间数据不丢失【热度: 200】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：websocket 断联数据不丢失&lt;/p&gt;&lt;p&gt;实现 WebSocket 的自动重连并保证断连期间数据不丢失，通常需要在客户端实现一些机制来管理连接状态、定时重试以及缓存未成功发送的消息。以下是一个简单的步骤和策略指南：&lt;/p&gt;&lt;h3&gt;1. 监听连接状态&lt;/h3&gt;&lt;p&gt;首先，你需要监听 WebSocket 连接的各种事件，以便知道何时发生了断连，并根" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/882" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>websocket 断联之后如何重连，且保证断链期间数据不丢失【热度: 200】</h1>
      <div class="subtitle">web应用场景 · web应用场景 · 腾讯</div>
      <div class="meta">创建：2024-09-15T07:26:21Z · 更新：2024-09-17T12:28:20Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：websocket 断联数据不丢失</p><p>实现 WebSocket 的自动重连并保证断连期间数据不丢失，通常需要在客户端实现一些机制来管理连接状态、定时重试以及缓存未成功发送的消息。以下是一个简单的步骤和策略指南：</p><h3>1. 监听连接状态</h3><p>首先，你需要监听 WebSocket 连接的各种事件，以便知道何时发生了断连，并根据这些事件来触发重连逻辑。</p><ul><li><code>onclose</code>: 当 WebSocket 连接关闭时，触发重连逻辑。</li><li><code>onerror</code>: 出现错误时，也可视为一个触发重连的信号。</li><li><code>onopen</code>: 连接成功时，清除重试计数器和缓存的数据（如果之前成功发送了）。</li></ul><h3>2. 实现重连逻辑</h3><ul><li><strong>使用指数退避算法</strong>来延迟重连尝试，避免短时间内频繁重连。</li><li>例如，第一次重连延迟 1 秒，第二次 2 秒，然后 4 秒，最大延迟设置为 1 分钟。</li><li>在每次重连时，重置 WebSocket 对象并重新发起连接。</li></ul><h3>3. 缓存数据</h3><ul><li><strong>发送数据前检查连接状态</strong>：如果 WebSocket 处于非开放状态，将数据缓存起来，待连接恢复后再发送。</li><li><strong>使用队列存储待发送数据</strong>：便于按顺序发送，保证数据的完整性和顺序。</li></ul><h3>4. 发送缓存数据</h3><ul><li>在连接成功的回调（<code>onopen</code>事件）中，检查是否有缓存的数据，如果有，则遍历队列发送。</li></ul><h3>示例代码</h3><p>下面是一个示范代码片段：</p><pre class="code-block"><code class="language-javascript">var ws;
var retryInterval = 1000; // 初始重连间隔为 1 秒
const maxInterval = 60000; // 最大间隔为 1 分钟
var messageQueue = []; // 数据缓存队列

function connect() {
  ws = new WebSocket(&quot;wss://your-websocket-url&quot;);

  ws.onopen = function () {
    console.log(&quot;WebSocket connected&quot;);
    retryInterval = 1000; // 重置重连间隔
    sendMessageQueue(); // 尝试发送缓存中的数据
  };

  ws.onclose = function () {
    console.log(&quot;WebSocket disconnected, attempting to reconnect...&quot;);
    setTimeout(connect, retryInterval);
    retryInterval = Math.min(retryInterval * 2, maxInterval); // 指数退避
  };

  ws.onerror = function (error) {
    console.error(&quot;WebSocket error:&quot;, error);
    ws.close(); // 确保触发 onclose 事件
  };

  ws.onmessage = function (message) {
    // 处理接收到的数据
  };
}

function sendMessage(data) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(data);
  } else {
    console.log(&quot;WebSocket is not open. Queuing message.&quot;);
    messageQueue.push(data); // 缓存待发送数据
  }
}

function sendMessageQueue() {
  while (messageQueue.length &gt; 0) {
    const data = messageQueue.shift(); // 获取并移除队列中的第一个元素
    sendMessage(data); // 尝试再次发送
  }
}

connect(); // 初始化连接
</code></pre><p>这个示例实现了基本的重连逻辑和数据缓存策略。在实际应用中，根据实际需求对这些逻辑进行扩展和定制化是很有必要的，尤其是数据缓存和发送逻辑，可能需要结合业务特点进行更复杂的处理。</p><p>特别是数据缓存这个场景， 如果有多个 webscoket 数据， 建议使用 <code>indexedDB</code> 做一个系统级别的数据管理。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>