[{"id":"1147","title":"前端静态资源加载超时，Nginx 可通过哪些配置优化？【热度: 190】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1147","page":"q/阿里巴巴-1147.html","excerpt":"**关键词**：nginx 加载超时优化 前端静态资源（如 JS、CSS、图片、视频等）加载超时，通常与**网络传输效率**、**服务器响应速度**或**资源处理策略**相关。Nginx 可通过针对性配置优化传输效率、延长超时阈值、减少阻塞风险，从而解决超时问题。以下是具体优化方案： 一、延长关键超时时间（避免传输中断"},{"id":"1143","title":"Nginx 配置 gzip/brotli 压缩时需考虑哪些因素？为何不建议对所有前端资源开启压缩？【热度: 106】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1143","page":"q/阿里巴巴-1143.html","excerpt":"**关键词**：nginx 配置资源压缩 在 Nginx 中配置 gzip 或 brotli 压缩时，需综合考虑**压缩效率、服务器性能开销、客户端兼容性**等核心因素；而不建议对所有前端资源开启压缩，本质是避免“无效压缩”（压缩后体积无明显减小）和“反向损耗”（压缩耗时 > 传输耗时）。以下是具体分析： 一、配置 g"},{"id":"1142","title":"Nginx 如何按资源类型（如.js/.png）分发到不同服务器？配置策略是什么？【热度: 159】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1142","page":"q/阿里巴巴-1142.html","excerpt":"**关键词**：nginx 转发 Nginx 可以通过 location 指令匹配不同资源类型（如 .js、.png），并将请求分发到不同服务器，实现资源的分类部署和负载均衡。这种配置策略适合将静态资源（JS、图片）与动态资源（API）分离部署，提升整体服务性能。 一、核心配置策略：按文件后缀匹配并转发 通过 loca"},{"id":"1126","title":"JS 里面， 对于对象的读写， 是使用 object 好，还是 Map，性能差异如何？【热度: 610】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1126","page":"q/阿里巴巴-1126.html","excerpt":"**关键词**：Object 与 Map 在 JavaScript 中，Object 和 Map 都可以用于存储键值对，但它们的设计目标和性能特性存在差异，选择哪一种取决于具体使用场景。 **核心差异与性能对比** 1. **内存占用** **Object**： 本质是原型链继承的对象，会默认一些额外属性（如 __pr"},{"id":"1118","title":"很多web前端框架里面会有约定式路由， 他们是如何实现的【热度: 331】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1118","page":"q/阿里巴巴-1118.html","excerpt":"**关键词**：约定是路由 约定式路由（Convention over Configuration，CoC）是现代前端框架（如 Next.js、Nuxt.js、VitePress 等）广泛采用的路由实现方式，其核心思想是**根据文件目录结构自动生成路由配置**，无需手动编写冗长的路由表。下面介绍其实现原理和关键技术： "},{"id":"1116","title":"scrollIntoView、scrollIntoViewIfNeeded、scrollTo 有何区别？【热度: 320】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1116","page":"q/阿里巴巴-1116.html","excerpt":"scrollIntoView()、scrollIntoViewIfNeeded() 和 scrollTo() 是 JavaScript 中用于滚动的三个方法，它们的功能和适用场景有所不同： **1. Element.scrollIntoView()** **所属对象**：DOM 元素（Element）。 **作用**："},{"id":"1115","title":"让元素滚动到可视区， 有那些办法【热度: 320】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1115","page":"q/阿里巴巴-1115.html","excerpt":"在前端开发中，使元素滚动到可视区域是常见需求。以下是几种实现方式，从简单到复杂逐步介绍： **1. Element.scrollIntoView()** 这是最简单的原生方法，支持平滑滚动和对齐方式： **优点**：简单易用，兼容性好（IE11+）。 **缺点**：无法精确控制滚动速度或添加自定义动画。 **2. Wi"},{"id":"1114","title":"前端倒计时有误差怎么解决【热度: 454】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1114","page":"q/阿里巴巴-1114.html","excerpt":"前端倒计时出现误差是常见问题，主要由 JavaScript 的单线程特性、浏览器优化（如标签页切换时的节流）以及事件循环调度延迟引起。以下是几种解决方案： **1. 使用高精度时间戳（performance.now()）** Date.now() 依赖系统时间，可能被用户或系统修改；而 performance.now("},{"id":"1089","title":"vite 与 esbuild 是关系【热度: 55】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1089","page":"q/阿里巴巴-1089.html","excerpt":"**关键词**：vite 与 esbuild **Vite 对 Esbuild 的依赖关系（构建阶段）** **代码转换和打包工具**：在 Vite 的构建过程（vite build）中，Esbuild 扮演了重要的角色。Esbuild 是一个超高速的 JavaScript 打包器，Vite 利用 Esbuild 来进"},{"id":"1088","title":"vite 在开发过程中， 是如何处理 TS 文件的【热度: 112】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1088","page":"q/阿里巴巴-1088.html","excerpt":"**关键词**：vite、开发、TS **即时编译 TS 文件** **原理**：在 Vite 开发过程中，它利用浏览器原生 ES 模块（ESM）的支持，对于 TypeScript（TS）文件，Vite 会在浏览器请求时即时将其编译为 JavaScript。这个编译过程是由 Vite 内部的插件机制和 TypeScri"},{"id":"1087","title":"vite 开发和构建有何不同？【热度: 292】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1087","page":"q/阿里巴巴-1087.html","excerpt":"**关键词**：vite、开发、构建 **开发阶段** **快速的模块加载** **原理**：在开发阶段，Vite 充分利用浏览器对原生 ES 模块（ESM）的支持。当浏览器请求一个模块时，Vite 直接将对应的 ES 模块文件发送给浏览器，而不需要像传统构建工具那样先进行打包。这使得模块加载速度非常快，因为浏览器可以"},{"id":"1024","title":"如何使用 node 做一个全局命令行工具【热度: 141】","category":"阿里巴巴","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1024","page":"q/阿里巴巴-1024.html","excerpt":"作者备注 这个问题， 其实本质就是一个 package.json 配置里面的 bin 配置， 没有多大的价值 以下是使用 Node.js 创建一个全局命令行工具的步骤： **一、创建项目结构** 创建一个新的文件夹作为项目目录，例如my-cli-tool。 在项目目录中，初始化一个新的 Node.js 项目，可以使用n"},{"id":"981","title":"[React] 如何实践数据不可变状态【热度: 114】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/981","page":"q/阿里巴巴-981.html","excerpt":"**关键词**：react 数据不可变 在 React 中，可以通过以下几种方式来实践数据不可变状态： **一、使用不可变数据结构库（如 Immutable.js）** **安装和导入 Immutable.js**： 首先，安装 Immutable.js 库：npm install immutable。 然后，在 Re"},{"id":"980","title":"[React] 对象数据状态不可变是什么概念【热度: 113】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/980","page":"q/阿里巴巴-980.html","excerpt":"**关键词**：react 数据不可变 在 React 中，“对象数据状态不可变”是一个重要的概念，它主要有以下几个方面的含义： **一、保证数据的稳定性和可预测性** **避免意外的副作用**： 当 React 组件的状态是可变的时，在复杂的应用中很容易出现意外的副作用。例如，如果多个组件共享一个可变的状态对象，一个"},{"id":"973","title":"https 中如何保证证书是可信任的【热度: 210】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/973","page":"q/阿里巴巴-973.html","excerpt":"**关键词**：https 证书可信保证 在 HTTPS 中，保证证书是可信任的主要通过以下几个方面实现： **一、证书颁发机构（CA）的信任体系** **根证书的信任**： 操作系统和浏览器内置了一些受信任的根证书颁发机构（Root CA）的证书。这些根证书是整个信任体系的基础。 当浏览器接收到一个服务器的 SSL/"},{"id":"970","title":"对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗【热度: 108】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/970","page":"q/阿里巴巴-970.html","excerpt":"**关键词**：tree-shaking 使用 在使用 Webpack 进行打包时，对于已经导入（import）但未实际使用的模块，通常情况下不会被打包进去，但这也取决于具体的配置和使用场景。 **一、默认行为** 在默认情况下，Webpack 会进行“树摇”（tree shaking）操作。树摇是一种优化技术，它可以"},{"id":"964","title":"http 静态文件缓存 Last-Modified 是根据什么生成的【热度: 85】","category":"阿里巴巴","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/964","page":"q/阿里巴巴-964.html","excerpt":"**关键词**：静态文件缓存 作者备注 冷门， 当做只是了解即可 在 HTTP 服务中，静态文件的Last-Modified（最后修改时间）通常是根据以下几个因素生成的： **一、文件系统的修改时间** **来源**： 服务器在提供静态文件时，通常会读取文件所在文件系统中的最后修改时间作为Last-Modified的值"},{"id":"962","title":"http ETag 值改变了，是否意味着文件内容一定已经更改【热度: 138】","category":"阿里巴巴","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/962","page":"q/阿里巴巴-962.html","excerpt":"**关键词**：ETag 值 如果 HTTP 响应头中的 ETag 值改变了，通常意味着资源（文件或其他内容）很可能发生了变化，但并不绝对意味着文件内容一定已经更改。 **一、可能导致 ETag 变化但文件内容未更改的情况** 生成方式的变化： 如果服务器更改了生成 ETag 的方式，即使文件内容没有变化，ETag 也"},{"id":"961","title":"http 响应头中的 ETag 值是如何生成的【热度: 37】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/961","page":"q/阿里巴巴-961.html","excerpt":"**关键词**：ETag 值 作者备注 没有啥价值， 当做科普吧 HTTP 响应头中的 ETag（Entity Tag）是服务器生成的用于标识资源的一个字符串。ETag 的生成方式通常有以下几种： **一、基于资源内容生成** 哈希算法： 服务器可以计算资源内容的哈希值，例如使用 MD5、SHA-1 等哈希算法。将资源"},{"id":"952","title":"mobx 和 redux 有什么区别【热度: 277】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/952","page":"q/阿里巴巴-952.html","excerpt":"**关键词**：mobx 和 redux 区别 作者备注 这里知识一个间比较， 没有深入去对比 api 等， 如果需要深入对比请自行查看下面的文档 参考文档：https://juejin.cn/post/6924572729886638088 MobX 和 Redux 都是流行的 JavaScript 状态管理库，广泛"},{"id":"944","title":"[webpack] 发中使用的是 esm 和 webpack, 是否可以直接调用 commonjs 模块化的三方包【热度: 359】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/944","page":"q/阿里巴巴-944.html","excerpt":"**关键词**：模块化混用 在使用 Webpack 作为构建工具的项目中，ESM (ECMAScript Modules) 和 CommonJS 模块系统可以混用。 Webpack 提供了对两种模块化标准的支持，能够理解和处理它们之间的差异，使得这两种不同类型的模块可以在同一个项目中共存。 混用时的考虑因素 虽然 ES"},{"id":"940","title":"防止对象被篡改有哪些方式【热度: 260】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/940","page":"q/阿里巴巴-940.html","excerpt":"**关键词**：防止对象篡改 在 JavaScript 中，可以通过以下几种方式防止对象被篡改： **一、使用Object.freeze()** 功能： 完全冻结一个对象，使其不能添加新属性、删除现有属性或修改现有属性的值。 对嵌套对象也会进行深度冻结。 示例： **二、使用Object.seal()** 功能： 密封"},{"id":"889","title":"pnpm install 和 npm install 有何区别","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/889","page":"q/阿里巴巴-889.html","excerpt":"pnpm install 和 npm install 都是用于安装 JavaScript 项目依赖的命令，但它们背后的包管理器（分别是 pnpm 和 npm）在处理依赖安装、存储和优化方面有一些关键区别。 1. **存储方式的区别** **npm**：在每个项目的 node_modules 文件夹中分别存储其依赖。这意"},{"id":"888","title":"monorepo 工程有哪些工具架构， 该如何选型【热度: 450】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/888","page":"q/阿里巴巴-888.html","excerpt":"**关键词**：monorepo 技术选项 工具推荐 | 工具 | **Turborepo** | **Rush** | **Nx** | **Lerna** | **Pnpm Workspace** | | -------- | ------------- | -------- | ------ | --------"},{"id":"887","title":"[webpack] 如何优化产物大小【热度: 521】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/887","page":"q/阿里巴巴-887.html","excerpt":"**关键词**：webpack 产物大小优化 在使用 Webpack 进行项目构建时，减少包体积是提升加载速度、改善用户体验的关键措施之一。以下是一些通用的方法和技巧来减小构建结果的包体积： 1. **使用 Tree Shaking** Tree Shaking 是一个通过清除未引用代码（dead-code）的过程，可"},{"id":"886","title":"[webpack] 代码分割中，让所有的外部依赖打成一个包，源码 source 打成一个包，该如何配置【热度: 352】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/886","page":"q/阿里巴巴-886.html","excerpt":"**关键词**：webpack 代码分割 为了实现你的需求，即将所有外部依赖（node_modules 中的依赖）打包成一个单独的包，而你自己的源码打包成另一个包，可以通过配置 Webpack 的 optimization.splitChunks 选项来实现。下面是具体的实施方案： 1. 编辑 webpack.conf"},{"id":"875","title":"请求数量过多，该如何治理【热度: 418】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/875","page":"q/阿里巴巴-875.html","excerpt":"**关键词**：治理请求数量 作者备注 很多同学我有 http2 ， 可以多路复用， 所以请求再多都不会影响页面性能。 实际上是错误的。 在作者知道的很多超大型项目（千万行级别的项目）里面， 太多的网络并发（首屏可能就有好大几百的请求发出去）， 会因为 IO 问题到时吃掉很多的 CPU 与网络带宽， 用户依然会觉得非常"},{"id":"873","title":"tsconfig.json 中有哪些重用的配置项【热度: 289】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/873","page":"q/阿里巴巴-873.html","excerpt":"**关键词**：TS 配置项 tsconfig.json是 TypeScript 项目的配置文件，它指定了用于编译该项目的根文件及编译器选项。以下是一些重要的配置项和它们的作用： compilerOptions 这部分包含了一系列用来告诉 TypeScript 编译器如何编译代码的标志。 **target**: 设置编"},{"id":"872","title":"JS 项目逐步迁移到 TS 项目，该如何做【热度: 870】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/872","page":"q/阿里巴巴-872.html","excerpt":"**关键词**：TS 项目迁移 在 JavaScript 项目迁移到 TypeScript 的过程中确实会出现大量 JS 和 TS 文件共存的情况。要配置项目以使它们兼容并顺利运行，你需要进行以下设置： 1. 初始化 TypeScript 配置 首先，创建tsconfig.json文件来配置 TypeScript 编译"},{"id":"864","title":"统计全站每一个静态资源加载耗时， 该如何做【热度: 564】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/864","page":"q/阿里巴巴-864.html","excerpt":"**关键词**：统计资源加载耗时、PerformanceObserver PerformanceResourceTiming api 使用 要统计全站每一个静态资源（如图片、JS 脚本、CSS 样式表等）的加载耗时，你可以借助浏览器的 Performance API，特别是利用 PerformanceResourceT"},{"id":"862","title":"[React] 性能调优中，如何确定哪个数据变化引起的组件渲染【热度: 500】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/862","page":"q/阿里巴巴-862.html","excerpt":"**关键词**：react 渲染性能调优 帮助开发者排查是哪个属性改变导致了组件的 rerender。 直接接受 ahooks 里面的一个方法： $1 源码实现："},{"id":"861","title":"长文本溢出，展开/收起如何实现【热度: 895】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/861","page":"q/阿里巴巴-861.html","excerpt":"**关键词**：长文本溢出 长文本溢出展开/收起功能通常需要使用一些 JavaScript 来动态控制文本的显示状态，及 CSS 来处理文本的默认显示样式。以下是一个基本实现示例，展示了如何结合 HTML、CSS 和 JavaScript 来实现这个功能。 HTML 结构 我们定义一个容器来显示文本，并添加一个用于触发"},{"id":"854","title":"如何组织工程项目【热度: 517】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/854","page":"q/阿里巴巴-854.html","excerpt":"**关键词**：组织工程项目 该话题是开放性话题，难度系数可高可低，请自己探索答案吧。"},{"id":"850","title":"如何判断用户设备【热度: 551】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/850","page":"q/阿里巴巴-850.html","excerpt":"**关键词**：判断设备 在 Web 前端开发中，判断用户设备类型（如手机、平板、桌面电脑）主要依赖于用户代理字符串（User-Agent）和/或视口（Viewport）的尺寸。以下是一些常用方法： 使用用户代理字符串（User-Agent） 用户代理字符串包含了浏览器类型、版本、操作系统等信息，可以通过分析这些信息来"},{"id":"841","title":"[webpack] 多个 loader 对同一个资源进行处理， 他们之间如何通信？【热度: 134】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/841","page":"q/阿里巴巴-841.html","excerpt":"**关键词**：webpack loader 通信 在 webpack 中，loader 之间传递数据的常见方式是通过资源文件（即要处理的源文件本身）的内容。每个 loader 接收上一个 loader 的处理结果作为输入，并提供自己的输出给下一个 loader。这种方式适用于大多数使用场景。然而，在某些情况下，loa"},{"id":"840","title":"[webpack] 手写 webpack loader 有哪些重要 api 与注意事项？【热度: 718】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/840","page":"q/阿里巴巴-840.html","excerpt":"**关键词**：手写 webpack loader 在开发一个 webpack loader 时，除了理解 loader 的基本概念和功能之外，还有一些重要的 API 和注意事项是必需了解的。这些能够帮助你更高效地编写和调试 loader。 重要 API **this.callback**: 在 loader 函数内部"},{"id":"839","title":"[webpack] 手写 loader: 我要在方法调用的时候， 上报调用源文件地址【热度: 117】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/839","page":"q/阿里巴巴-839.html","excerpt":"**关键词**：手写 webpack loader 要在方法调用时上报调用源文件的地址，并且希望通过 webpack 编译时来实现，你可以通过编写一个自定义的 webpack loader 来操作源代码，为特定的方法调用插入上报的代码。自定义 loader 本质上是一个函数，该函数接收源码作为输入，对源码进行处理后返回"},{"id":"822","title":"【git] 当项目报错，你想定位是哪个 commit 引入的错误的时候，该怎么做【热度: 650】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/822","page":"q/阿里巴巴-822.html","excerpt":"**关键词**：二分法查找错误 commit 确实，当你不确定哪个提交(commit)引入了错误时，Git 提供了一个非常强大的工具 git bisect 来帮助你通过二分法快速定位出问题的提交。这个命令通过逐步缩小导致问题的提交范围，最终帮助你找出导致错误的具体提交。使用方法如下： 如何使用 git bisect *"},{"id":"821","title":"【git] 如何移除一个指定的 commit【热度: 762】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/821","page":"q/阿里巴巴-821.html","excerpt":"**关键词**：commit 移除 移除某一个指定的 commit 通常意味着要在版本控制系统如 Git 中更改历史记录，这通常涉及到一些操作风险，尤其是当这个 commit 已经被推送到远程仓库且被其他人使用。下面是几种常见的移除指定 commit 的方法，但在进行这些操作前，请确保备份你的代码，以防不测： 使用 g"},{"id":"820","title":"手写瀑布流布局【热度: 551】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/820","page":"q/阿里巴巴-820.html","excerpt":"**关键词**：瀑布流布局 作者备注， 此文章属于转载 原文作者：有机后脑 链接：https://juejin.cn/post/7360534173718167579 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 --- 瀑布流布局 当前主流的一些软件当中我们常常可以看见这样的一"},{"id":"808","title":"日志监控问题：可有办法将请求的调用源码地址包括代码行数也上报上去？【热度: 814】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/808","page":"q/阿里巴巴-808.html","excerpt":"**关键词**：日志监控问题 在使用了代码混淆（例如 Webpack 的 mina-hash、chunkhash 或 contenthash）的前端代码中，即使执行了混淆，依然可以通过以下方法在日志监控时提供足够的上下文信息，主要包括被请求的源代码地址以及代码行数： 源码映射(Source Maps) **生成 Sou"},{"id":"782","title":"[微前端] 为何通常在 微前端 应用隔离， 不选择 iframe 方案【热度: 280】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/782","page":"q/阿里巴巴-782.html","excerpt":"**关键词**：iframe 隔离方案弊端 在微前端架构中，虽然iframe能提供很好的应用隔离（包括 JavaScript 和 CSS 隔离），确保微前端应用之间不会相互干扰，但一般不把它作为首选方案，原因包括： 1. 性能开销 iframe会创建一个全新的浏览器上下文环境，每个iframe都有自己的文档对象模型（D"},{"id":"781","title":"[微前端] Qiankun 是如何做 JS 隔离的【热度: 228】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/781","page":"q/阿里巴巴-781.html","excerpt":"**关键词**：JS 隔离 Qiankun 是一个基于 Single-SPA 的微前端实现库，它提供了比较完善的 JS 隔离能力，确保微前端应用间的独立运行，避免了全局变量污染、样式冲突等问题。Qiankun 实现 JS 隔离的主要机制包括： 1. JS 沙箱 Qiankun 使用 JS 沙箱技术为每个子应用创建一个独"},{"id":"780","title":"[微前端] 微前端架构一般是如何做 JavaScript隔离【热度: 127】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/780","page":"q/阿里巴巴-780.html","excerpt":"**关键词**：JS 隔离 在微前端架构中，JavaScript 隔离是核心之一，用以确保各个子应用间代码运行时不互相干扰、变量不冲突，以及能够安全地卸载应用。为了实现这一目标，主要采用以下几种方法： 1. 使用沙箱技术： **iframe**：最直接的隔离方式是将子应用运行在iframe中。这种方式提供了良好的隔离性"},{"id":"769","title":"[Webpack] ts 编写的库， 在使用 webpack 构建的时候， 如何对外提供 d.ts【热度: 224】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/769","page":"q/阿里巴巴-769.html","excerpt":"**关键词**：对外提供 d.ts 在 TypeScript (TS) 中使用 Webpack 构建并为库提供 .d.ts 类型声明文件，需要遵循以下步骤： **配置 TypeScript 编译选项**： 在库项目的根目录下创建或编辑 tsconfig.json 文件，确保编译器配置选项如下： declaration:"},{"id":"768","title":"测试前端代码覆盖率一般有什么手段？【热度: 550】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/768","page":"q/阿里巴巴-768.html","excerpt":"**关键词**：覆盖率 前端代码的测试覆盖率通常是指衡量在测试过程中有多少代码被执行了的一个指标。测试覆盖率有助于了解测试的全面性，以下是测试前端代码覆盖率常用的手段： **单元测试**： 使用测试框架（例如 Jest, Mocha, Jasmine 等）编写单元测试。 利用测试框架或插件生成覆盖率报告（例如 Ista"},{"id":"730","title":"mouseEnter、mouseLeave、mouseOver、mouseOut 有什么区别？【热度: 266】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/730","page":"q/阿里巴巴-730.html","excerpt":"**关键词**：mouseEnter、mouseLeave、mouseOver、mouseOut 区别 这四个事件都与鼠标指针与元素的交互有关，不过它们之间有一些关键的差异： **mouseEnter 和 mouseLeave**： mouseEnter 事件当鼠标指针进入元素时触发，但不冒泡，即只有指定的元素可以触发"},{"id":"729","title":"tsconfig 配置中 types 和 typeRoots 作用是什么， 有什么区别？【热度: 378】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/729","page":"q/阿里巴巴-729.html","excerpt":"**关键词**：ts 类型配置 作者备注 这个问题很冷门， 没有价值， 当做科普即可 在 TypeScript 的 tsconfig.json 配置文件中，types 和 typeRoots 是两个与类型声明相关的选项，它们用于控制 TypeScript 编译器如何处理类型声明文件。这两个选项的主要区别在于它们控制的范"},{"id":"728","title":"ts 项目中，如何使用 node_modules 里面定义的全局类型包到自己项目 src 下面使用？【热度: 377】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/728","page":"q/阿里巴巴-728.html","excerpt":"**关键词**：ts 类型配置 **关键点在 types 属性配置** 在 TypeScript 项目中导入 node_modules 中定义的全局包，并在你的 src 目录下使用它，通常遵循以下步骤： 安装包： 使用包管理器如 npm 或 yarn 来安装你需要的全局包。 类型声明： 确保该全局包具有类型声明。如果该"},{"id":"727","title":"介绍一下 MutationObserver【热度: 632】","category":"阿里巴巴","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/727","page":"q/阿里巴巴-727.html","excerpt":"**关键词**：MutationObserver api MutationObserver 是一种能够响应 DOM 树变动的 Web API，它可以监听几乎所有类型的 DOM 变动，比如元素被添加、删除或修改。你可以通过它执行 callback 来应对这些变化。 下面是 MutationObserver 的基本用法： "},{"id":"721","title":"前端渲染和后端渲染各有啥优缺点， 为何现在技术大方向又逐渐往【后端渲染】方向靠了呢？【热度: 470】","category":"阿里巴巴","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/721","page":"q/阿里巴巴-721.html","excerpt":"**关键词**：前端渲染优缺点、后端渲染优缺点 前端渲染（Client-Side Rendering，CSR）和后端渲染（Server-Side Rendering，SSR）是两种不同的网页渲染策略，每种方法都有其固有的优势和劣势。近几年来，后端渲染之所以又开始受到重视，主要是由于它在某些方面更加适应了新的技术需求和趋"},{"id":"720","title":"express 里面的 中间件 和 插件， 是一个意思吗？【热度: 469】","category":"阿里巴巴","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/720","page":"q/阿里巴巴-720.html","excerpt":"**关键词**：express 中间件、express 插件 在 Express.js 中，\"中间件\" 和 \"插件\" 这两个术语有时被交替使用，但实际上它们可能指向不同类型的组件，其差异取决于上下文。 中间件 (Middleware) 中间件是 Express 架构的核心部分，它是具有访问请求对象（req），响应对象（"},{"id":"719","title":"[Vue] Vue2 中双向绑定是通过 Object.defineProperty() 实现的， 那么它是如何监控数组的？【热度: 447】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/719","page":"q/阿里巴巴-719.html","excerpt":"**关键词**：Vue2 中双向绑、Vue2 中双向绑监控数组 在 Vue 2 中，双向数据绑定的核心是 Object.defineProperty()，它允许 Vue 对每个属性进行 getter 和 setter 的拦截，从而实现响应式系统。对于普通的响应式属性来说，这一切都很简单，因为属性的 getter 和 s"},{"id":"718","title":"介绍一下 requestIdleCallback api【热度: 290】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/718","page":"q/阿里巴巴-718.html","excerpt":"**关键词**：requestIdleCallback api、requestIdleCallback 使用场景 requestIdleCallback 是一个 Web API，它允许开发者请求浏览器在主线程空闲时执行一些低优先级的后台任务，这对于执行如分析、整理状态和数据等不紧急的任务是理想的。这种方法可以提高用户的"},{"id":"717","title":"[React] 为何要自己实现调度器， 而不是直接使用 requestIdleCallback ？【热度: 236】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/717","page":"q/阿里巴巴-717.html","excerpt":"**关键词**：react 调度器 Scheduler、requestIdleCallback 使用场景 React 在性能优化方面的一个关键组件是调度器（Scheduler），它负责在渲染的过程中合理安排工作，以减少用户的等待时间以及避免单个任务占用过多的主线程时间，从而提高渲染性能。React 在 18.0 版本后"},{"id":"699","title":"你在开发过程中， 使用过哪些 TS 的特性或者能力？【热度: 670】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/699","page":"q/阿里巴巴-699.html","excerpt":"**关键词**：TS 特性和能力 这个为何被作者列为了高阶范围的问题 原因如下：大多数纯写业务的同学， 可能就用到了 interface 和 type 最多加上 enum 和 泛型； TS 很多牛掰的特性， 是伴随做复杂的工具库， 或者处理复杂业务场景来的。 这里直接上干货： **Utility Types（工具类型）"},{"id":"698","title":"开发过程中为什么会选择使用 ts , 相比于 JS 开发， 有哪些优点？【热度: 318】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/698","page":"q/阿里巴巴-698.html","excerpt":"**关键词**：TS 开发优势 使用 TypeScript（简称 TS）而不是纯 JavaScript（JS）进行开发，是因为 TypeScript 提供了一些特性和优势，这些可以帮助开发者提高代码质量、可维护性以及开发效率。以下是使用 TypeScript 的一些主要优点： **静态类型检查**： TypeScrip"},{"id":"684","title":"Eslint 代码检查的过程是啥？【热度: 111】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/684","page":"q/阿里巴巴-684.html","excerpt":"**关键词**：eslint 代码检测、eslint 代码检测 执行过程 ESLint 是一个插件化的静态代码分析工具，用于识别 JavaScript 代码中的问题。它在代码质量和编码风格方面有助于保持一致性。代码检查的过程通常如下： **配置**： 首先需要为 ESLint 提供一套规则，这些规则可以在.eslint"},{"id":"683","title":"void 和 never 区别【热度: 410】","category":"阿里巴巴","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/683","page":"q/阿里巴巴-683.html","excerpt":"**关键词**：typescript void、typescript never、void 和 never 区别 在 TypeScript 中，void和never类型都代表没有值，但用途和含义却有所不同。以下是它们之间的主要区别： **void**： void类型用于标记函数没有任何返回值。这意呑着函数可能执行了一些"},{"id":"677","title":"JS 放在 head 里和放在 body 里有什么区别？【热度: 420】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/677","page":"q/阿里巴巴-677.html","excerpt":"将 JavaScript 代码放在 <head> 标签内部和放在 <body> 标签内部有一些区别： **加载顺序**：放在 <head> 里会在页面加载之前执行 JavaScript 代码，而放在 <body> 里会在页面加载后执行。 **页面渲染**：如果 JavaScript 代码影响了页面的布局或样式，放在 <"},{"id":"676","title":"列表分页， 快速翻页下的竞态问题【热度: 444】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/676","page":"q/阿里巴巴-676.html","excerpt":"**关键词**：翻页场景竞态问题 **列表分页， 快速翻页下的竞态问题** 问题描述：比如在前端分页请求的时候， 因为翻页很快， 所以请求还没有来得及回来的时候， 就发起了下一次请求， 且请求返回的时间也是不固定的。 如何保证最后一次请求结果和其请求页码是对应上的。 在处理这种情况时，一种常见的方法是使用请求标记或唯一"},{"id":"675","title":"CORS 请求中，是如何触发预检请求【热度: 229】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/675","page":"q/阿里巴巴-675.html","excerpt":"**关键词**：CORS 预检请求条件 其动机是，HTML 4.0 中的 <form> 元素（早于跨站 XMLHttpRequest 和 fetch）可以向任何来源提交简单请求，所以任何编写服务器的人一定已经在保护跨站请求伪造攻击（CSRF）。 在这个假设下，服务器不必选择加入（通过响应预检请求）来接收任何看起来像表单"},{"id":"674","title":"http 中 HSTS 是什么【热度: 374】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/674","page":"q/阿里巴巴-674.html","excerpt":"**关键词**：http HSTS HTTP Strict-Transport-Security（HSTS）是一种安全策略，它通过 HTTP 头部告诉浏览器只能通过安全的 HTTPS 连接访问网站，从而增加网站的安全性。HSTS 有助于防止恶意攻击者通过中间人攻击（如SSL剥离攻击）窃取敏感信息。 HSTS 的主要作用"},{"id":"673","title":"http 中 CSP 是什么【热度: 323】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/673","page":"q/阿里巴巴-673.html","excerpt":"**关键词**：http CSP 在 HTTP 协议中，CSP 指的是 \"Content Security Policy\"（内容安全策略）。CSP 是一种用于增强网站安全性的安全策略机制，通过指定浏览器只能加载指定来源的资源，以减少恶意攻击的风险。 CSP 的主要目标是防止和减缓特定类型的攻击，例如跨站脚本攻击 (XS"},{"id":"667","title":"Protobuf 相关知识【热度: 216】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/667","page":"q/阿里巴巴-667.html","excerpt":"**关键词**：Protobuf 基本概念 Protobuf（Protocol Buffers）是由 Google 开发的一种轻量级、高效的数据交换格式，它被用于结构化数据的序列化、反序列化和传输。相比于 XML 和 JSON 等文本格式，Protobuf 具有更小的数据体积、更快的解析速度和更强的可扩展性。 Prot"},{"id":"641","title":"nodejs 如何充分利用多核 CPU?【热度: 725】","category":"阿里巴巴","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/641","page":"q/阿里巴巴-641.html","excerpt":"**关键词**：nodejs 多CPU使用 总所周知， NodeJS 是单线程执行任务， 不同于 浏览器还可以使用 web worker 等手段多线程执行任务。那么 NodeJS 中， 是如何充分利用物理机的多核 CPU 呢？ 有三种方式 在 Node.js 中，JS 也是单线程的，只有一个主线程用于执行任务。但是，在"},{"id":"635","title":"前端日志埋点 SDK 设计思路【热度: 755】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/635","page":"q/阿里巴巴-635.html","excerpt":"**关键词**：前端埋点监控、埋点 SDK 设计 前端日志埋点 SDK 设计思路 既然涉及到了日志和埋点，分析一下需求是啥： 自动化上报 页面 PV、UV。 如果能自动化上报页面性能， 用户点击路径行为，就更好了。 自动上报页面异常。 发送埋点信息的时候， 不影响性能， 不阻碍页面主流程加载和请求发送。 能够自定义日志"},{"id":"632","title":"在前端应用如何进行权限设计？【热度: 329】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/632","page":"q/阿里巴巴-632.html","excerpt":"**关键词**：权限设计 在前端应用的权限设计中，以下是一些建议： 角色与权限分离 将用户的权限分为不同的角色，每个角色拥有特定的权限。 这样可以简化权限管理，并且当需求变化时，只需要调整角色的权限，而不需要逐个修改用户的权限。 **在角色与权限分离的设计中，可以按照以下几个步骤进行** 确定权限集合：首先，需要确定系"},{"id":"630","title":"[低代码] 代码平台一般渲染是如何设计的？【热度: 399】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/630","page":"q/阿里巴巴-630.html","excerpt":"**关键词**：代码平台渲染设计 **渲染设计** 渲染核心本质就是： [schema] + [组件] = [页面] 整体架构如下 **协议层**：基于《低代码引擎搭建协议规范》 产出的 Schema 作为我们的规范协议。 **能力层**：提供组件、区块、页面等渲染所需的核心能力，包括 Props 解析、样式注入、条件"},{"id":"629","title":"[低代码] 代码平台一般底层协议是怎么设计的【热度: 263】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/629","page":"q/阿里巴巴-629.html","excerpt":"**关键词**：代码平台协议设计 低代码引擎体系基于三份协议来构建: $1 $1 $1 **参考文档** https://lowcode-engine.cn/site/docs/guide/design/specs"},{"id":"628","title":"[低代码] 代码平台一般架构设计如何【热度: 517】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/628","page":"q/阿里巴巴-628.html","excerpt":"**关键词**：代码平台 代码平台 - 架构综述 **分层架构描述** 自下而上分别是协议 - 引擎 - 生态 - 平台。 底层协议栈定义的是标准，标准的统一让上层产物的互通成为可能。 引擎是对协议的实现，同时通过能力的输出，向上支撑生态开放体系，提供各种生态扩展能力。 生态就好理解了，是基于引擎核心能力上扩展出来的，"},{"id":"623","title":"对 babel 的理解？【热度: 551】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/623","page":"q/阿里巴巴-623.html","excerpt":"**关键词**：babel 作用、为何要使用 babel Babel 是一个非常流行的 JavaScript 编译器，用于将最新版本的 ECMAScript 代码转换为向后兼容的 JavaScript 代码，以便在旧版浏览器或环境中运行。 以下是对 Babel 的理解： 语法转换：Babel 可以将使用了最新 ECMA"},{"id":"622","title":"[Webpack] 有哪些优化项目的手段？【热度: 1,163】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/622","page":"q/阿里巴巴-622.html","excerpt":"**关键词**：打包优化 围绕 webpack 做性能优化，分为两个方面：构建时间优化、构建产物优化 <!-- toc --> 优化构建时间 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 <!-- tocstop --> 构建时间优化 缩小范围 我们在使用 loa"},{"id":"612","title":"[Webpack] 全面了解 tree shaking【热度: 790】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/612","page":"q/阿里巴巴-612.html","excerpt":"webpack 如何做 tree shaking Webpack通过tree shaking技术实现了JavaScript代码的优化和精简。Tree shaking是指通过静态代码分析，识别和移除未被使用的代码（被称为\"dead code\"），从而减小最终打包后的文件大小。 下面是Webpack如何进行tree sha"},{"id":"610","title":"[Webpack] 如何打包运行时 chunk ， 且在项目工程中， 如何去加载这个运行时 chunk ?【热度: 421】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/610","page":"q/阿里巴巴-610.html","excerpt":"Webpack打包运行时chunk的方式可以通过optimization.runtimeChunk选项来配置。下面是一个示例的配置： 上述配置中，通过设置optimization.runtimeChunk为'single'，将会把所有的webpack运行时代码打包为一个单独的chunk。 在项目工程中加载运行时chun"},{"id":"609","title":"[Webpack] 如何配置多入口应用， 且区分公共依赖的？【热度: 124】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/609","page":"q/阿里巴巴-609.html","excerpt":"在Webpack中配置多入口应用并区分公共依赖，可以通过以下步骤进行配置： 在Webpack配置文件中，使用entry属性指定多个入口文件，并为每个入口文件命名一个唯一的键名。例如： 上面的配置指定了两个入口文件app1.js和app2.js，并为它们分别指定了键名app1和app2。 使用SplitChunks插件进"},{"id":"608","title":"[Webpack] 有哪些基础概念【热度: 595】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/608","page":"q/阿里巴巴-608.html","excerpt":"**关键词**：webpack 作用、webpack 概念 Webpack是一个现代的JavaScript模块打包工具，它的核心概念包括以下几个方面： 入口（Entry）：指定Webpack开始构建依赖图谱的起点。可以通过配置文件中的entry属性来指定入口文件，也可以指定多个入口文件。 输出（Output）：指定We"},{"id":"607","title":"[Webpack] 为什么选择 webpack？【热度: 515】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/607","page":"q/阿里巴巴-607.html","excerpt":"**关键词**：webpack 作用 **为什么选择 webpack** 想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。 在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因"},{"id":"606","title":"[Webpack] chunk 是什么概念，介绍一下？【热度: 1,100】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/606","page":"q/阿里巴巴-606.html","excerpt":"在Webpack中，Chunk（代码块）是指Webpack在构建过程中生成的一个或多个独立的文件，它包含了一组相关的模块。每个Chunk都有一个唯一的标识符，可以通过该标识符来访问和加载对应的Chunk。 Webpack根据指定的入口文件和依赖关系图来确定需要生成哪些Chunk。入口文件是Webpack构建的起点，而依"},{"id":"605","title":"[微前端] 路由加载流程是如何的？【热度: 971】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/605","page":"q/阿里巴巴-605.html","excerpt":"**关键词**：微前端路由加载 微前端是一种架构模式，旨在将大型前端应用程序拆分为更小、更容易维护的独立部分。微前端的路由原理可以通过以下步骤概括： 主应用加载：用户访问主应用时，主应用负责加载，并决定加载哪些微前端应用。 路由分发：主应用根据当前URL路径，将请求分发给相应的微前端应用。 微前端应用加载：被分发的微前"},{"id":"604","title":"[微前端] 设计原则有哪些？【热度: 1,060】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/604","page":"q/阿里巴巴-604.html","excerpt":"**关键词**：微前端设计原则 《微前端设计与实现》一书中作者卢卡·梅扎利拉提出的关于微前端的实践原则。一共有七条原则， 这些原则可以帮助团队更好地设计和实施微前端架构。 围绕业务领域建模：将前端应用程序按照业务领域进行划分，每个微前端子应用负责一个特定的业务领域。这样可以提高团队的独立性和聚焦性，降低开发和维护的复杂"},{"id":"603","title":"为何现在市面上做表格渲染可视化技术的，大多数都是 canvas ， 而很少用 svg 的？【热度: 302】","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/603","page":"q/阿里巴巴-603.html","excerpt":"**关键词**：canvas使用场景、canvas可视化、svg使用场景 都用上了可视化技术做渲染， 在这个场景下， 大多数考虑的是性能； 所以主要基于几个方面去衡量技术方案的选择： 性能、动态交互、复杂图形支持 性能：Canvas 通常比 SVG 具有更好的性能。Canvas 是基于像素的绘图技术，而 SVG 是基于"},{"id":"601","title":"[代码实现] 手写数组降维flat方法【热度: 244】","category":"阿里巴巴","labels":["阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/601","page":"q/阿里巴巴-601.html","excerpt":"**关键词**：JS数组降维、reduce数组降维 原生Array.prototype.flat方法接受一个depth参数，默认值为1，depth表示要降维的维数： 输出结果： reduce + 递归实现方案"},{"id":"600","title":"[代码实现] 手写 dom 分段渲染【热度: 280】","category":"阿里巴巴","labels":["阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/600","page":"q/阿里巴巴-600.html","excerpt":"**关键词**：dom 分段渲染 分时函数案例：把1秒创建1000个DOM节点，改成每隔200毫秒创建10个节点，这样不用短时间在页面中创建大量的DOM。"},{"id":"595","title":"[Vue] 响应式为何要从 Object.defineProperty 改为 proxy?【热度: 352】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/595","page":"q/阿里巴巴-595.html","excerpt":"**关键词**：vue Object.defineProperty、vue proxy 使用 Vue 在早期版本中使用了 Object.defineProperty 来实现响应式系统。但是，在 Object.defineProperty 中存在一些限制和局限性，导致在某些场景下无法完全满足需求。因此，Vue 在最新的版"},{"id":"594","title":"在你的项目中， 使用过哪些 webpack plugin, 说一下他们的作用【热度: 361】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/594","page":"q/阿里巴巴-594.html","excerpt":"下表列出了常见的 Webpack 插件及其作用： | 插件名称 | 作用 | | ------------------------------------------------ | --------------------------------------------------------------------"},{"id":"593","title":"在你的项目中， 使用过哪些 webpack loader, 说一下他们的作用【热度: 361】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/593","page":"q/阿里巴巴-593.html","excerpt":"| Loader 名称 | 作用 | | --------------------------- | -------------------------------------------------------------------------------------------------------------"},{"id":"587","title":"[React] 如何实现转场动画？","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/587","page":"q/阿里巴巴-587.html","excerpt":"这个问题非常复杂， 我这边用白话文解释一下原理， 若有不对的地方， 请大家更正： 如果没有专场动画， 那么在路由切换的一瞬间， 加载下一个路由页面的组件， 注销上一个路由页面的组件； 但是如果加上专场动画， 比如专场动画时间为 500ms， 那么， 在咋合格 500ms 过程中， 首先要加载下一个路由页面的组件， 然后"},{"id":"586","title":"[React] react router 主要包有哪些，主要 api 有哪些？","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/586","page":"q/阿里巴巴-586.html","excerpt":"React Router是React官方提供的用于构建单页应用的路由库，主要包括以下几个主要包和API： 主要包： react-router-dom：用于Web应用的路由库。 react-router-native：用于原生应用（如React Native）的路由库。 react-router-config：用于配置静"},{"id":"585","title":"[React] 是如何进行渲染的？【热度: 623】","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/585","page":"q/阿里巴巴-585.html","excerpt":"**关键词**：jsx渲染、react渲染过程 在 React 中，JSX 最终被转换为真实的 DOM 经历了以下步骤： 1. 解析 JSX：在编译阶段，React 会使用 Babel 等工具将 JSX 转换为 JavaScript 对象。 在编译阶段，React 使用 Babel 等工具将 JSX 转换为 JavaS"},{"id":"575","title":"XHR 和 Fetch 是否支持取消请求【热度: 122】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/575","page":"q/阿里巴巴-575.html","excerpt":"**关键词**：XHR 取消请求、Fetch 取消请求 **XHR 支持取消请求** XHR（XMLHttpRequest）对象支持取消请求。你可以使用 xhr.abort() 方法来取消正在进行的请求。 下面是一个使用 XHR 取消请求的示例代码： 使用 xhr.abort() 方法会导致 XHR 请求被中止，并触发"},{"id":"574","title":"axios 是如何区分是 nodejs 环境还是 浏览器环境 的？【热度: 113】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/574","page":"q/阿里巴巴-574.html","excerpt":"**关键词**：nodejs与浏览器环境判定 Axios 是一个跨平台的 HTTP 客户端库，可以在浏览器和 Node.js 中使用。Axios 通过判断当前环境来确定是在浏览器还是在 Node.js 环境中运行。 在浏览器环境中，Axios 默认会使用浏览器提供的 XMLHttpRequest 对象来发送 HTTP "},{"id":"573","title":"axios 有哪些特性？【热度: 464】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/573","page":"q/阿里巴巴-573.html","excerpt":"**关键词**：axios特性 直接可以参考官网链接： https://axios-http.com/docs/intro 特点 从浏览器创建XMLHttpRequest 从node.js生成http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 超时时间 支持嵌套项的查询参数序列化 "},{"id":"562","title":"JavaScript 和 BOM、DOM 、ECMAScript、Nodejs 之间是什么关系","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/562","page":"q/阿里巴巴-562.html","excerpt":"**ECMAScript** ECMAScript是JavaScript的标准化规范，它定义了JavaScript的语法、数据类型、函数、控制流等。ECMAScript最早在1997年发布，由欧洲计算机制造商协会（ECMA）负责制定和维护。 ECMAScript的目的是为了确保不同厂商的JavaScript实现在语法和"},{"id":"561","title":"weakSet 是什么数据结构， 有什么应用场景【热度: 161】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/561","page":"q/阿里巴巴-561.html","excerpt":"**关键词**：weakSet 数据、weakSet 结构、weakSet 作用 WeakSet 是一种特殊的集合数据结构，它只能存储对象引用，并且这些对象是弱引用。WeakSet 中的对象是被弱引用的，意味着如果没有其他引用指向这个对象，垃圾回收机制就会自动将其回收，即使该对象存在于 WeakSet 中。与 Set "},{"id":"547","title":"前端架构和前端工程化有什么区别？","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/547","page":"q/阿里巴巴-547.html","excerpt":"先说说对这两个概念的看法： $1 $1 **区别** 前端架构和前端工程化是两个不同的概念，但它们之间有一些相互关联的特点。 前端架构是指在前端开发中，对整个前端应用程序的组织结构、模块划分、框架选择等方面的设计和规划。前端架构的目标是为了提高代码的可维护性、可扩展性和可重用性，以及优化前端应用程序的性能和用户体验。常"},{"id":"546","title":"如何理解前端工程化？","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/546","page":"q/阿里巴巴-546.html","excerpt":"前端工程化是指将前端开发过程中的各种工具、技术和流程进行规范化和自动化，以提高前端开发效率、代码质量和团队协作能力的一种方法。前端工程化主要涵盖以下几个方面： 代码管理：使用版本控制系统（如Git）对前端项目进行代码管理，实现代码的版本控制、协作开发和代码回滚等功能。 代码规范：制定和遵循统一的前端代码规范，包括缩进、"},{"id":"545","title":"如何理解前端架构？","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/545","page":"q/阿里巴巴-545.html","excerpt":"前端架构是指在开发前端应用程序时，为了提高开发效率、代码可维护性和可扩展性，将前端代码组织和设计的一种架构体系。它涵盖了前端项目的整体结构、代码组织方式、技术选型、模块化开发、数据管理、状态管理、网络请求、路由管理等方面的规划和设计。 前端架构的目标是使前端开发更加规范、高效和可持续。良好的前端架构可以帮助团队成员更好"},{"id":"523","title":"webpack tree-shaking 在什么情况下会失效？【热度: 171】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/523","page":"q/阿里巴巴-523.html","excerpt":"**关键词**：tree shaking 失效 在以下情况下，webpack 的 tree-shaking 可能会失效： 使用了 sideEffects 属性：在 webpack 的配置文件中，如果设置了 sideEffects: true，则 webpack 会假设所有模块都有副作用，因此不会进行 tree-shak"},{"id":"499","title":"如何封装一个请求，让其多次调用的时候，实际只发起一个请求的时候，返回同一份结果【热度: 636】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/499","page":"q/阿里巴巴-499.html","excerpt":"**关键词**：defer函数、请求结果缓存在JS内存 最优解： **使用deferred思想来实现请求的等待队列，可以借助Promise和async/await语法**。 下面是使用deferred思想来实现的代码示例： 在上述代码中，Deferred类用于创建一个延迟对象，其中promise属性是一个Promise"},{"id":"498","title":"一般项目里面对请求 request 都会做哪些统一封装？【热度: 916】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/498","page":"q/阿里巴巴-498.html","excerpt":"**关键词**：request封装、request封装功能、request封装作用 统一处理错误：可以在请求封装中统一处理错误，例如网络错误、超时等，并进行统一的错误提示或处理逻辑。 统一处理认证和授权：可以在请求中添加认证信息，例如在请求头中添加 token，或者在每个请求中验证用户权限。 统一处理请求配置：可以在请"},{"id":"439","title":"escape、encodeURI、encodeURIComponent 区别【热度: 367】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/439","page":"q/阿里巴巴-439.html","excerpt":"**关键词**：js URL 编码解码 在 JavaScript 中，escape()、encodeURI() 和 encodeURIComponent() 都是用于编码 URL 或字符串的函数，但它们有一些区别： escape() 函数用于编码字符串中的特殊字符，使其能够安全地传输。它对字符进行编码，包括非 ASCI"},{"id":"410","title":"在浏览器内多个标签页之间实现通信有哪些方式【热度: 897】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/410","page":"q/阿里巴巴-410.html","excerpt":"**关键词**：跨页面通信、Broadcast Channel API 通信、SharedWorker 基本通信方式 在浏览器内多个标签页之间实现通信可以通过以下几种方式： 使用 Broadcast Channel API：Broadcast Channel API 是 HTML5 提供的一种跨页面通信的机制。通过该 "},{"id":"398","title":"有哪些场景的 http header","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/398","page":"q/阿里巴巴-398.html","excerpt":"常见的 HTTP Header 在请求头（Request Header）和响应头（Response Header）中有许多不同的字段，它们具有各自的作用。下面是一些常见的 HTTP Header 字段及其作用的简要说明： **Request Header：** **Host**：指定目标服务器的域名或 IP 地址。 *"},{"id":"386","title":"不使用任何中间件， koa 如何解析 post 请求参数【热度: 1,359】","category":"阿里巴巴","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/386","page":"q/阿里巴巴-386.html","excerpt":"**关键词**：koa 请求、koa 解析、koa body-parser 如果你不想使用任何中间件来解析 POST 请求参数，你可以手动解析请求体数据。在 Koa 中，你可以通过以下步骤来解析 POST 请求的参数： 使用 ctx.req 获取原始的 Node.js 请求对象。 将请求对象的数据流通过 ctx.req"},{"id":"374","title":"Antd（Ant Design）的 Tooltip 组件是如何实现的？","category":"阿里巴巴","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/374","page":"q/阿里巴巴-374.html","excerpt":"Antd（Ant Design）的 Tooltip 组件是通过 CSS 和 JavaScript 结合实现的。 在 CSS 方面，Tooltip 组件使用了绝对定位和一些样式规则来定义 Tooltip 的外观。它通常包括一个触发元素和一个浮动在触发元素旁边的提示框。通过设置样式属性，如 position: absolu"},{"id":"364","title":"如何优化大规模 dom 操作的场景【热度: 1,012】","category":"阿里巴巴","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/364","page":"q/阿里巴巴-364.html","excerpt":"**关键词**：dom 操作性能、dom 操作优化 在处理大规模DOM操作的场景中，可以采取以下一些优化策略： 使用批量操作：避免频繁地进行单个DOM操作，而是将多个操作合并为一个批量操作。例如，使用DocumentFragment来创建一个离线的DOM片段，将多个元素一次性添加到片段中，然后再将整个片段插入到文档中。"},{"id":"363","title":"模版引擎实现原理【热度: 1,241】","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/363","page":"q/阿里巴巴-363.html","excerpt":"**关键词**：模版引擎 前端模板引擎实现原理 前端模板引擎是一种用于处理 HTML 字符串的工具，它允许开发人员在 HTML 中嵌入特殊语法，然后使用模板引擎把数据与这些语法结合，生成最终的 HTML 字符串。这种方式有助于实现数据与表示的分离，使得代码更易于维护。 前端模板引擎的实现原理通常包括以下几个步骤： **"},{"id":"357","title":"如何将JavaScript代码解析成抽象语法树(AST)【热度: 1,169】","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/357","page":"q/阿里巴巴-357.html","excerpt":"**关键词**：解析为 AST、抽象语法树、AST 词法分析、AST 语法分析 如何将JavaScript代码解析成抽象语法树 要将JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST），你可以使用工具或库来实现。以下是几种常用的方法： Esprima: Esprima 是一个流行"},{"id":"352","title":"HTML5 中 meta 标签作用是啥【热度: 1,562】","category":"阿里巴巴","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/352","page":"q/阿里巴巴-352.html","excerpt":"**关键词**：html5 meta HTML 5 中的 meta 标签是一个非常常用的标签，它可以用来描述一个 HTML 文档的一些基本信息与配置，包括字符编码、页面关键词、作者、视口大小等。具体来说，meta 标签可用于以下几个方面： 1.描述文档内容：通过设置 meta 标签中的一些属性，可以描述文档的主体内容、"},{"id":"335","title":"HTTP 304 状态码表达的请求过程是什么【热度: 459】","category":"阿里巴巴","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/335","page":"q/阿里巴巴-335.html","excerpt":"**关键词**：304状态码、304请求过程、304过程、304请求 HTTP 304 状态码是表示所请求的资源未修改，可以直接使用客户端缓存的版本。当客户端发送 GET 请求时，服务器会检查该资源的 ETag（实体标签）或 Last-Modified（最后修改时间）等信息，与客户端缓存中的相应信息进行比较。如果这些信"},{"id":"252","title":"设计一套全站请求耗时统计工具","category":"阿里巴巴","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/252","page":"q/阿里巴巴-252.html","excerpt":"首先我们要知道有哪些方式可以统计前端请求耗时 从代码层面上统计全站所有请求的耗时方式主要有以下几种： Performance API：Performance API 是浏览器提供的一组 API，可以用于测量网页性能。通过 Performance API，可以获取页面各个阶段的时间、资源加载时间等。其中，Performa"},{"id":"247","title":"[webpack] 是如何实现 treeShaking 的","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/247","page":"q/阿里巴巴-247.html","excerpt":"webpack实现tree shaking的原理是基于ES6模块化语法的静态特性。 在编译阶段，Webpack会根据模块的依赖关系，通过AST（抽象语法树）进行静态分析，识别出那些代码块（函数、变量、对象等）被引用并且使用了。然后将这些代码块打包输出到最终的打包文件中。在这个过程中，Webpack会自动将未被引用的代码"},{"id":"246","title":"[webpack] loader 和 plugin 有啥区别","category":"阿里巴巴","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/246","page":"q/阿里巴巴-246.html","excerpt":"在Webpack中，Loader和Plugin是两个不同的概念，它们的作用和使用方式也有所不同。 Loader用于对源代码文件进行转换和处理，而Plugin用于对Webpack的编译过程进行扩展和增强。 **Loader** Loader是Webpack中的一个核心概念，它用于处理源代码文件，将它们转换成Webpack"},{"id":"226","title":"前端动画有哪些实现方式？","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/226","page":"q/阿里巴巴-226.html","excerpt":"主要的实现方式 **JS 的实现方式** 通过定时器(setTimeout, setInterval)来间隔改变元素样式 requestAnimationFrame **CSS 3** 过度动画：transition animation 动画 **HTML 5** Canvas WebGL svg requestAni"},{"id":"225","title":"ES6 代码转成 ES5 代码的实现思路是什么？","category":"阿里巴巴","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/225","page":"q/阿里巴巴-225.html","excerpt":"ES6 代码转成 ES5 代码的实现思路主要是通过使用 Babel 这样的工具来实现。Babel 是一个广泛使用的 JavaScript 编译器，可以将 ES6 代码转换成向后兼容的 ES5 代码，从而在现有的浏览器和环境中运行。其主要实现思路如下： 词法分析：Babel 首先会将输入的代码进行词法分析，将代码分割成一"},{"id":"200","title":"手写订阅-发布模式","category":"阿里巴巴","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/200","page":"q/阿里巴巴-200.html","excerpt":"订阅-发布模式是一种常用的设计模式，它可以实现对象间的解耦，让它们不需要相互知道对方的存在，只需要关注自己需要订阅的事件即可。当一个对象的状态发生变化时，它可以发布一个事件通知其他对象，其他对象可以订阅该事件，当事件发生时得到通知并执行相应的处理。 在 JavaScript 中，订阅-发布模式也被称为事件模型。事件模型"},{"id":"199","title":"手写 观察者模式","category":"阿里巴巴","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/199","page":"q/阿里巴巴-199.html","excerpt":"观察者模式（又称发布-订阅模式）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，其相关的依赖对象都能够得到通知并被自动更新。 在 JavaScript 中实现观察者模式，可以分为以下几个步骤： 创建一个主题对象（Subject），用来存储观察者对象，并提供添加、删除、通知观察者的"},{"id":"198","title":"介绍下观察者模式和订阅-发布模式的区别？","category":"阿里巴巴","labels":["JavaScript","网易","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/198","page":"q/阿里巴巴-198.html","excerpt":"观察者模式和订阅-发布模式都属于事件模型，它们都是为了解耦合而存在，但是它们之间还是有一些不同之处的： 观察者模式中，主题（被观察者）和观察者之间是直接联系的，观察者订阅主题，主题状态发生变化时会直接通知观察者；而订阅-发布模式中，发布者和订阅者之间没有直接的联系，发布者发布消息到消息中心，订阅者从消息中心订阅消息。 "},{"id":"1067","title":"项目部署更新之后，如何提醒用户去刷新更新页面资源【热度: 340】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/1067","page":"q/百度-1067.html","excerpt":"**使用版本号查询参数** **原理**：在 HTML 文件中，对于引用的静态资源（如 JavaScript 文件、CSS 文件），可以在 URL 后面添加一个版本号查询参数。每次更新项目后，更新这个版本号。这样，浏览器会将带有新的版本号的资源视为一个新的请求，从而强制刷新资源。 **示例**： 原始的 JavaScr"},{"id":"938","title":"localStorage 是同步还是异步【热度: 210】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/938","page":"q/百度-938.html","excerpt":"在大多数现代浏览器中，localStorage的操作是同步的。 当你使用localStorage.setItem()来存储数据或者localStorage.getItem()来获取数据时，这些操作会立即执行并且不会返回一个 Promise 或者使用回调函数来处理异步操作。 例如： 在上面的代码中，设置和获取localS"},{"id":"937","title":"如何限制 input 框只能输入正整数【热度: 230】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/937","page":"q/百度-937.html","excerpt":"在前端，可以通过以下几种方式来限制 <input> 框只能输入正整数： **一、使用 HTML5 的输入类型和属性** 使用 type=\"number\" 属性： <input type=\"number\"> 设置输入框的类型为数字。然而，这并不能完全确保只输入正整数，因为用户仍然可以输入小数。 添加 step=\"1\" 和"},{"id":"883","title":"在开发过程中，想做 git 代码暂存，该如何做【热度: 342】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/883","page":"q/百度-883.html","excerpt":"**关键词**：git stash 使用 作者备注 这个问题的指向性非常明显， 就是在问 git stash 的使用 在 Git 中，如果你想要暂存当前的工作进度，可以使用git stash命令。这个命令会将你的工作目录中的修改（已追踪文件的修改和暂存的改动）保存到一个未完成工作的栈中，同时将你的工作目录恢复到上次提交"},{"id":"879","title":"JS 如何计算一段文本渲染之后的长度【热度: 648】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/879","page":"q/百度-879.html","excerpt":"**关键词**：计算文本长度 追加描述 需要根据这个长度来动态计算文本是否折叠， 所以这个文本没有计算出长度是否折叠之前，还不能在用户可视区域渲染出来 要在 JavaScript 中计算一段文本渲染之后的长度，可以通过几种方法来实现。这里的“长度”可以是文本渲染后的像素宽度，它取决于具体的字体、字号、文本内容等因素。以"},{"id":"868","title":"flex 布局中，有哪些常用的属性，分别作用是啥【热度: 300】","category":"百度","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/868","page":"q/百度-868.html","excerpt":"**关键词**：flex 属性 Flex 布局（即 Flexible Box 布局）提供了一种更有效的方式来布置、对齐和分布容器内项目的空间，即使它们的大小是未知或者动态变化的。以下是 Flex 布局中一些常用属性及其作用的简介： 容器属性（应用于 flex 容器） **display**： 设置为flex或inlin"},{"id":"860","title":"如何统计用户 pv 访问的发起请求数量（所有域名的）【热度: 469】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/860","page":"q/百度-860.html","excerpt":"统计用户 PV（页面访问量）期间发起的请求数量（涵盖所有域名）可以通过几种方法实现，包括使用浏览器的 Performance API、监听网络请求、或者通过服务端日志分析。每种方法有其优点和适用场景。下面是一些方法的简要说明和示例： 方法 1: 使用 Performance API Performance API 提供"},{"id":"858","title":"大文件切片上传的时候，确定切片数量的时候，有那些考量因素【热度: 366】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/858","page":"q/百度-858.html","excerpt":"**关键词**：文件切片上传 大文件切片上传时，切片数量取决于几个关键因素：文件总大小、每个切片的大小（即切片大小），以及任何特定于应用或服务的限制。计算切片数量的过程包括确定合理的切片大小，然后根据文件总大小来计算需要多少个这样大小的切片。以下是一些步骤和考虑因素，可以帮助你确定切片数量： 1. 确定切片大小 **切"},{"id":"856","title":"如果在网络带宽一定的情况下， 切片上传感觉和整体上传， 消费的时间应该是差不多的。 这种说法正确吗【热度: 363】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/856","page":"q/百度-856.html","excerpt":"**关键词**：切换上传合理性 这种说法在某些情况下是正确的，但实际上，切片上传相较于整体上传，在多种情况下可能更加高效，即使网络带宽固定。切片上传的优势并不仅仅在于可能节约的时间，还包括以下几点： 1. **提高上传的可靠性** 切片上传允许在遇到网络中断或其他传输错误时只重新上传失败的那一部分，而不是重新上传整个文"},{"id":"855","title":"如何判断页签是否为活跃状态【热度: 153】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/855","page":"q/百度-855.html","excerpt":"**关键词**：页签活跃状态 判断页面页签（Tab）是否为活跃状态，可以通过监听 visibilitychange 事件来实现。这个事件是由 document 对象触发的，可以用来判断页面是否对用户可见。当用户切换到其他标签页、最小化浏览器窗口、或是锁屏时，页面就会变为不可见状态。如果页面对用户可见，那么页面就处于活跃"},{"id":"852","title":"PerformanceObserver 如何测量页面性能【热度: 190】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/852","page":"q/百度-852.html","excerpt":"**关键词**：PerformanceObserver api 使用 PerformanceObserver API 是一个强大的浏览器接口，允许开发者订阅性能相关的事件，实时收集和分析用户当前浏览器会话中的性能数据。这个 API 是 Web 性能监测工具箱的一部分，与 window.performance 对象紧密协"},{"id":"842","title":"在创建对象的时候， new class 和 new function 可有什么区别【热度: 447】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/842","page":"q/百度-842.html","excerpt":"**关键词**：创建对象实例 在 JavaScript 中，使用new操作符创建对象时，既可以使用类（class）也可以使用构造函数（function）。二者都可以用来实例化新的对象，但它们之间存在一些关键的区别和相似之处： 使用new操作符 当使用new操作符时，JavaScript 会执行以下步骤： 创建一个全新的"},{"id":"834","title":"实现一个函数，支持深度遍历 JS 对象，且允许再遍历的时候，修改对象的数据，得到新的对象【热度: 441】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/834","page":"q/百度-834.html","excerpt":"**关键词**：深度遍历对象 实现一个这样的函数，我们需要考虑几个关键点： **深度遍历**：使用递归遍历对象的所有层级。 **修改数据**：在遍历过程中允许修改对象的数据。 **返回新对象**：保持原对象不变，对每个属性或值进行操作，将修改后的结果存储在新的对象中返回。 以下是一个简单示例，展示了如何实现上述功能： "},{"id":"833","title":"[git] 将多次提交压缩成一次提交【热度: 412】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/833","page":"q/百度-833.html","excerpt":"**关键词**：多次提交压缩成一次提交 将多次提交压缩成一次提交在 Git 中被称为“squash”。这通常在你完成一段工作后，想要将这段时间内的多个提交整理为一个更干净、更整洁的提交记录时使用。Git 提供了几种方法来实现提交的压缩，最常用的是通过 git rebase 命令配合交互模式（interactive mo"},{"id":"832","title":"CSS 中隐藏元素的方法有哪些？【热度: 273】","category":"百度","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/832","page":"q/百度-832.html","excerpt":"**关键词**：CSS 隐藏元素 在 CSS 中，隐藏元素可以通过多种方式实现，每种方式有其特定的使用场景。这里列出了一些常用的方法： 1. display: none; 完全移除元素，使其不占据任何空间，也不会在文档流中占位。元素及其所有子元素都不会显示。 2. visibility: hidden; 使元素不可见，"},{"id":"787","title":"flex：1 代表什么【热度: 400】","category":"百度","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/787","page":"q/百度-787.html","excerpt":"**关键词**：flex 布局相关属性问题 在 CSS 的弹性盒模型（Flexbox）中，flex: 1表示子项（flex 子项）的伸缩性。 具体来说，flex: 1是flex-grow、flex-shrink和flex-basis三个属性的简写。其默认值等同于flex: 1 1 0%，分别代表以下含义： flex-g"},{"id":"735","title":"git pull 和 git fetch 有啥区别？【热度: 355】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/735","page":"q/百度-735.html","excerpt":"**关键词**：git pull 和 git fetch git pull 和 git fetch 是 Git 版本控制系统中的两个基本命令，它们都用于从远程仓库更新本地仓库的信息，但执行的具体操作不同。 git fetch git fetch 下载远程仓库最新的内容到你的本地仓库，但它并不自动合并或修改你当前的工作。"},{"id":"734","title":"站点如何防止爬虫？【热度: 554】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/734","page":"q/百度-734.html","excerpt":"**关键词**：反爬虫 站点防止爬虫通常涉及一系列技术和策略的组合。以下是一些常用的方法： 1. 修改 robots.txt 在站点的根目录下创建或修改 robots.txt 文件，用来告知遵守该协议的爬虫应该爬取哪些页面，哪些不应该爬取。例如： 然而，需要注意的是遵守 robots.txt 不是强制性的，恶意爬虫可以"},{"id":"733","title":"什么是DNS劫持？【热度: 165】","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/733","page":"q/百度-733.html","excerpt":"**关键词**：DNS劫持 DNS 劫持（DNS Hijacking），也称为 DNS 重定向，是一种通过篡改原本的 DNS 解析流程，使得用户在尝试访问特定网址时被非法重定向到其他（通常是恶意的、广告相关的或者钓鱼的）网站的行为。这种攻击可以发生在用户的个人电脑、网络设备、甚至是直接在 DNS 服务器上。 DNS 劫"},{"id":"726","title":"[React] 介绍一下 HOC【热度: 789】","category":"百度","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/726","page":"q/百度-726.html","excerpt":"**关键词**：React HOC React 中的 HOC（高阶组件，Higher-Order Components）是一种基于 React 的组合特性而形成的设计模式，用于重用组件逻辑。一个高阶组件是一个函数，它接受一个组件并返回一个新组件。 HOC 允许你为组件添加额外的功能而无需更改组件自身的实现。这种模式可以"},{"id":"724","title":"扁平数据通过 parent 关联, 实现扁平结构转嵌套 tree 结构【热度: 218】","category":"百度","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/724","page":"q/百度-724.html","excerpt":"**关键词**：扁平结构转嵌套结构 **题目** **解** 解法非常有意思， 自己好好体会"},{"id":"723","title":"树结构查找， 实现一个函数， 通过 id 来查找 tree 数据结构对应的节点【热度: 867】","category":"百度","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/723","page":"q/百度-723.html","excerpt":"**关键词**：树结构查找 树结构查找， 实现一个函数， 通过 id 来查找 tree 数据结构对应的节点 **题目如下** **实现**"},{"id":"709","title":"Husky 和 lint-staged 有什么区别？【热度: 387】","category":"百度","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/709","page":"q/百度-709.html","excerpt":"**关键词**：Husky 和 lint-staged、git hooks Husky 和 lint-staged 都是与 Git 钩子 (hooks) 配合使用的 Node.js 库，但它们的用途和工作方式有所不同： **Husky**： Husky 是一个 Git 钩子管理器，它允许你触发自定义脚本在 git 事件"},{"id":"679","title":"如何检测网页空闲状态(一定时间内无操作)【热度: 329】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/679","page":"q/百度-679.html","excerpt":"如何判断页面是否空闲 首先，我们要知道什么是空闲？用户一定时间内，没有对网页进行任何操作，则当前网页为空闲状态。 用户操作网页，无非就是通过鼠标、键盘两个输入设备(暂不考虑手柄等设备)。因而我们可以监听相应的输入事件，来判断网页是否空闲(用户是否有操作网页)。 监听鼠标移动事件mousemove； 监听键盘按下事件mo"},{"id":"550","title":"[代码实现] JS 中如何实现大对象深度对比【热度: 906】","category":"百度","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/550","page":"q/百度-550.html","excerpt":"**关键词**：JS对象对比 在JavaScript中，可以使用递归的方式实现大对象的深度对比。以下是一个示例函数，用于比较两个大对象的每个属性是否相等： 使用示例： 在上述示例中，deepEqual函数会递归比较两个对象的每个属性的值，包括嵌套的对象或数组。如果两个对象是相等的，则返回true，否则返回false。注"},{"id":"541","title":"副作用是什么概念【热度: 230】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/541","page":"q/百度-541.html","excerpt":"**关键词**：js副作用 在 JavaScript 中，副作用（side effect）是指函数或表达式在执行过程中对外部环境产生的影响，而不仅仅是返回一个值。副作用可能包括但不限于对全局变量、参数、数据结构、文件系统、网络请求等进行修改。 副作用可以是有意为之，也可以是无意之间发生的。在函数式编程中，减少副作用是一"},{"id":"531","title":"Http 状态码 301 和 302 的应用场景分别是什么","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/531","page":"q/百度-531.html","excerpt":"HTTP状态码301和302都是重定向状态码，用于将客户端请求重定向到另一个URL。 301（Moved Permanently）：表示请求的资源已永久移动到新位置。服务器发送301状态码时，还会在响应头中包含一个Location字段，指示新的资源位置。客户端接收到301响应后，会自动重定向到新的URL，并且搜索引擎也"},{"id":"530","title":"http 常见状态码有哪些【热度: 1,410】","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/530","page":"q/百度-530.html","excerpt":"**关键词**：http常见状态码 HTTP（超文本传输协议）中常见的状态码包括： 1xx（信息性状态码）：表示请求已被接收并正在处理。 100（Continue）：请求已接收，客户端应继续发送请求的剩余部分。 101（Switching Protocols）：服务器要求客户端切换协议。 2xx（成功状态码）：表示请求"},{"id":"519","title":"[代码执行] 关于 this 的指向问题：下面代码执行结果是什么, 原因？","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/519","page":"q/百度-519.html","excerpt":"代码如下，请问执行结果是多少？ **执行结果** 解释如下： obj.getName()：在箭头函数getName中，this指向的是全局对象（在浏览器中是window对象，Node.js 中是Global对象）。因此this.getName输出undefined。 obj.getAge()：在普通函数getAge中，"},{"id":"497","title":"onpopstate可以监听到一个pushstate的事件吗【热度: 546】","category":"百度","labels":["浏览器","百度"],"url":"https://github.com/pro-collection/interview-question/issues/497","page":"q/百度-497.html","excerpt":"**关键词**：popstate **onpopstate 事件只能监听到浏览器历史记录的前进和后退操作，无法直接监听到 pushState 或 replaceState 的调用**。这是因为 pushState 和 replaceState 方法可以修改浏览器历史记录而不触发 onpopstate 事件。 但是，您可"},{"id":"496","title":"[React] 如何进行路由变化监听【热度: 698】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/496","page":"q/百度-496.html","excerpt":"**关键词**：React 路由、React 路由监听 在 React 中，你可以使用 React Router 库来进行路由变化的监听。React Router 是 React 的一个常用路由库，它提供了一组组件和 API 来帮助你在应用中管理路由。 下面是一个示例代码，演示如何使用 React Router 监听路"},{"id":"466","title":"[react] constructor 和 getInitialState 的区别?【热度: 785】","category":"百度","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/466","page":"q/百度-466.html","excerpt":"**关键词**：react constructor 作用、react getInitialState 作用、初始化 state 在 React 中，constructor 是一个类的构造函数，用于初始化类的成员变量和方法，这个函数不仅会在组件实例化时调用，还会在后续的组件更新时调用。而 getInitialState "},{"id":"458","title":"如何判断dom元素是否在可视区域【热度: 846】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/458","page":"q/百度-458.html","excerpt":"**关键词**：元素是否在可视区域 判断 DOM 元素是否在可视区域可以使用以下方法： getBoundingClientRect() 方法 该方法返回元素的大小及其相对于视口的位置，包括 top、right、bottom、left 四个属性。我们可以根据这四个属性来判断元素是否在可视区域内。 Intersection"},{"id":"449","title":"JS 执行上下文的生命周期阶段有哪些【热度: 713】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/449","page":"q/百度-449.html","excerpt":"**关键词**：JS 执行阶段、JS执行上下文生命周期 在JavaScript中，执行上下文的生命周期可以分为三个阶段：创建阶段（Creation phase）、执行阶段（Execution phase）和回收阶段（Cleanup phase）。 创建阶段（Creation phase）： 在创建阶段，JavaScri"},{"id":"437","title":"类数组转换成数组的方法有哪些【热度: 1,094】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/437","page":"q/百度-437.html","excerpt":"**关键词**：类数组对象转换为真正的数组 有几种常见的方法可以将类数组对象转换为真正的数组： Array.from()：使用 Array.from() 方法可以将可迭代对象或类数组对象转换为数组。 Array.prototype.slice.call()：通过调用 Array.prototype.slice() 方法"},{"id":"412","title":"什么是同源策略【热度: 1,430】","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/412","page":"q/百度-412.html","excerpt":"**关键词**：同源策略限制了什么资源 同源策略（Same-Origin Policy）是一种浏览器安全机制，用于限制不同源（域名、协议、端口）之间的交互。它是一种重要的安全措施，用于保护用户的隐私和安全，防止恶意网站通过跨域请求获取用户的敏感信息或进行恶意操作。 同源策略要求网页资源（如JavaScript、CSS、"},{"id":"400","title":"介绍一下 XMLHTTPRequest 对象【热度: 453】","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/400","page":"q/百度-400.html","excerpt":"**关键词**：XMLHTTPRequest 对象、XMLHTTPRequest 特点、XMLHTTPRequest 属性、封装发送 GET 请求 介绍 XMLHttpRequest 是一个在浏览器中用于发送 HTTP 请求的 JavaScript 对象。它提供了一种在客户端与服务器之间进行数据交互的方式，可以异步地发"},{"id":"387","title":"Generator 是如何做到中断和恢复的【热度: 1,558】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/387","page":"q/百度-387.html","excerpt":"**关键词**：Generator 中断、Generator 回复 Generator 是 JavaScript 中一种特殊的函数，它能够通过迭代器协议（Iterator Protocol）实现中断和恢复的功能。 Generator 函数使用 function* 声明，内部可以使用 yield 关键字来定义中断点。当调"},{"id":"384","title":"source map 了解多少【热度: 396】","category":"百度","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/384","page":"q/百度-384.html","excerpt":"**关键词**：source map 原理 Source Map（源映射）作用 Source Map（源映射）是一种文件，用于将压缩、混淆或编译后的代码映射回原始的源代码，以便在调试过程中能够直接查看和调试源代码。它提供了压缩文件和源文件之间的映射关系，包括每个压缩文件中的代码位置、原始文件的路径和行号等信息。 Sou"},{"id":"379","title":"如何定制前端项目代码规范【热度: 1,155】","category":"百度","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/379","page":"q/百度-379.html","excerpt":"**关键词**：定制前端代码规范 当按照上述步骤定制前端代码规范时，可以按照以下详细步骤执行： 选择代码规范工具： 研究可用的代码规范工具，如 ESLint、Prettier 等。 比较各工具的功能、灵活性和社区支持，并选择最适合你团队和项目的工具。 定义规范： 针对项目的需求和团队的编码风格，制定代码规范的具体规则和"},{"id":"375","title":"深度 SEO 优化的方式有哪些， 从技术层面来说","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/375","page":"q/百度-375.html","excerpt":"深度 SEO 优化涉及到一些技术层面的优化策略，以下是一些常见的方式： 网站结构优化：优化网站的结构，确保每个页面都可以被搜索引擎爬取和索引。使用合适的 HTML 标签和语义化的内容结构，使搜索引擎能够更好地理解页面的内容。 网站速度优化：提升网站的加载速度对 SEO 很重要。通过压缩和合并 CSS 和 JavaScr"},{"id":"370","title":"[React] createContext 和 useContext 有什么区别， 是做什么用的【热度: 367】","category":"百度","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/370","page":"q/百度-370.html","excerpt":"**关键词**：createContext useContext、useContext 使用、createContext 使用 createContext 和 useContext createContext和useContext是React中用于处理上下文（Context）的两个钩子函数，它们用于在组件之间共享数据。"},{"id":"360","title":"WebSocket 协议的底层原理是什么【热度: 1,805】","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/360","page":"q/百度-360.html","excerpt":"**关键词**：WebSocket 协议、WebSocket 与 http 区别、全双工通信的协议 WebSocket 通信原理 WebSocket 是一种在Web浏览器和服务器之间进行全双工通信的协议，它通过一个长久的、双向的通信通道来实现实时数据传输。 下面是WebSocket协议的底层原理： 握手（Handsha"},{"id":"359","title":"DNS解析过程","category":"百度","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/359","page":"q/百度-359.html","excerpt":"DNS（Domain Name System，域名系统）解析是将域名转换为对应的IP地址的过程。下面是DNS解析的一般步骤： 用户输入域名：用户在浏览器或其他应用程序中输入要访问的域名，例如 \"$1 本地缓存查找：操作系统首先会检查本地的DNS缓存，看是否已经缓存了该域名的IP地址。如果有匹配的缓存记录，且仍在有效期内"},{"id":"337","title":"函数式编程了解多少？【热度: 1,789】","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/337","page":"q/百度-337.html","excerpt":"**关键词**：函数式编程 函数式编程的核心概念 函数式编程是一种编程范式，它将程序看做是一系列函数的组合，函数是应用的基础单位。函数式编程主要有以下核心概念： 纯函数：函数的输出只取决于输入，没有任何副作用，不会修改外部变量或状态，所以对于同样的输入，永远返回同样的输出值。因此，纯函数可以有效地避免副作用和竞态条件等"},{"id":"300","title":"canvas 性能为何会比 html/css 好？【热度: 242】","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/300","page":"q/百度-300.html","excerpt":"Canvas 和 HTML/CSS 是两种不同的技术，各自有着自己的优势和适用场景。 Canvas 是一种基于 JavaScript 的 2D/3D 绘图技术，它允许开发者直接操作像素，可以实现复杂的图形、动画和游戏等效果，其性能比 HTML/CSS 要好的原因主要有以下几点： 直接操作像素：Canvas 允许开发者直"},{"id":"294","title":"如何实现网页加载进度条？","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/294","page":"q/百度-294.html","excerpt":"监听静态资源加载情况 可以通过 window.performance 对象来监听页面资源加载进度。该对象提供了各种方法来获取资源加载的详细信息。 可以使用 performance.getEntries() 方法获取页面上所有的资源加载信息。可以使用该方法来监测每个资源的加载状态，计算加载时间，并据此来实现一个资源加载进"},{"id":"293","title":"站点一键换肤的实现方式有哪些？","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/293","page":"q/百度-293.html","excerpt":"网站一键换肤实现方式有以下几种 使用 CSS 变量：通过定义一些变量来控制颜色、字体等，然后在切换主题时动态修改这些变量的值。 使用 class 切换：在 HTML 的根元素上添加不同的 class 名称，每个 class 名称对应不同的主题样式，在切换主题时切换根元素的 class 名称即可。 使用 JavaScri"},{"id":"292","title":"H5 如何解决移动端适配问题","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/292","page":"q/百度-292.html","excerpt":"移动端适配问题是指如何让网页在不同的移动设备上显示效果相同。下面是一些常见的 H5 移动端适配方案： 使用 viewport 标签 通过设置 viewport 标签的 meta 属性，来控制页面的缩放比例和宽度，以适配不同的设备。例如： 其中 width=device-width 表示设置 viewport 的宽度为设"},{"id":"291","title":"promise 是否可以取消？","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/291","page":"q/百度-291.html","excerpt":"在原生的 JavaScript Promise 中，它没有内建的取消机制。一旦一个 Promise 被创建并开始执行，就无法直接取消它。 通常情况下，Promise 一旦被创建，就会一直执行直到成功(resolve)或失败(reject)。但是，你可以通过一些手动的方式来模拟取消 Promise 的效果。下面是几种常见"},{"id":"285","title":"[React] Hooks 实现原理是什么, 简单描述一下","category":"百度","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/285","page":"q/百度-285.html","excerpt":"在探索 useEffect 原理的时候，一直被一个问题困扰：useEffect 作用和用途是什么？当然，用于函数的副作用这句话谁都会讲。举个例子吧： 这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。**但这并不是必要的**。完全可以不使用useEffect，直接使用setTimeout，并且它的"},{"id":"278","title":"大文件上传了解多少","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/278","page":"q/百度-278.html","excerpt":"大文件分片上传 如果太大的文件，比如一个视频1g 2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分 比如2M。 Blob 它表示原始数据, 也就是二进制数据，同时提供了对数据截取的方法 sli"},{"id":"260","title":"介绍下 BFC、IFC、GFC 和 FFC？","category":"百度","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/260","page":"q/百度-260.html","excerpt":"BFC（Block Formatting Contexts）块级格式化上下文 什么是BFC？ BFC 全称：Block Formatting Context， 名为 **块级格式化上下文**。 W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block F"},{"id":"245","title":"react 中是如何实现 下拉菜单场景， 点击区域外关闭下拉组件？","category":"百度","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/245","page":"q/百度-245.html","excerpt":"在 React 中，要实现点击区域外关闭下拉组件，一般可以使用以下几种方法： 在下拉组件的根元素上监听点击事件，当点击区域不在下拉组件内时，触发关闭下拉组件的操作。这可以通过添加全局点击事件，然后在事件处理程序中判断点击区域是否在下拉组件内来实现。具体实现如下： 在下拉组件的父元素上监听点击事件，当点击区域不在下拉组件"},{"id":"243","title":"[webpack] webpack 是如何给 web 应用注入环境变量的， 原理是啥","category":"百度","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/243","page":"q/百度-243.html","excerpt":"Webpack 可以通过 DefinePlugin 插件给 web 应用注入环境变量。该插件会在编译过程中替换掉代码中指定的变量，以实现在运行时替换成环境变量的值。 在 webpack 的配置文件中，需要先引入该插件，然后将需要注入的环境变量通过该插件进行配置。例如： 上述配置中，定义了两个需要注入的变量，分别是 pr"},{"id":"218","title":"对象引用类问题：以下代码的执行结果是什么，并解释原因","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/218","page":"q/百度-218.html","excerpt":"代码如下， 请问执行结果 执行结果和原因 结果是 undefined 和 {n: 2}。 这段代码可以分解为以下步骤： 创建一个对象 a，属性 n 的值为 1。 将变量 b 指向 a，b 现在也引用了这个对象。 执行赋值语句 a.x = a = {n: 2}，其中 a.x 引用的是对象 a 的 x 属性，但是此时 a "},{"id":"216","title":"实现 (5).add(3).minus(2) 功能","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/216","page":"q/百度-216.html","excerpt":"可以通过在 Number 原型上定义 add 和 minus 方法来实现该功能，代码如下： 上述代码中，通过在 Number.prototype 上定义 add 和 minus 方法，实现了将数字类型的值转换为 Number 对象，并且可以链式调用这两个方法。最终返回的结果是一个数值类型的值。"},{"id":"209","title":"[Redux] 为什么 Redux 的 reducer 中不能做异步操作？","category":"百度","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/209","page":"q/百度-209.html","excerpt":"Redux 的 reducer 是纯函数，它的作用是接收一个旧的状态和一个操作，返回一个新的状态，是一个纯粹的状态转换函数，因此在 reducer 中不能执行异步操作，否则会破坏 reducer 的纯函数特性。如果在 reducer 中执行异步操作，会导致 reducer 不可预测和不可重现，因为异步操作的结果是不确定"},{"id":"208","title":"使用迭代的方式实现 flatten 函数？","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/208","page":"q/百度-208.html","excerpt":"可以使用迭代的方式实现 flatten 函数，具体思路如下： 创建一个新数组 result 来存放结果。 创建一个栈 stack，将原数组作为第一个元素压入栈中。 当栈不为空时，取出栈顶元素，如果该元素是一个数组，则将其展开后的每个元素压入栈中。 如果该元素不是一个数组，则将其加入到 result 中。 重复步骤 3 "},{"id":"207","title":"使用 虚拟DOM 一定会比直接操作 真实 DOM 快吗？","category":"百度","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/207","page":"q/百度-207.html","excerpt":"大家惯有的思维模式下，我们普遍的认为，虚拟DOM一定会比原生DOM要快的多。 但实际上并不是这样。 **仅从React的角度来说 : React的官网可从来都没有说过虚拟DOM会比原生操作DOM更快。** 虚拟DOM和原生操作DOM谁更快这个问题。如果要我来回答的话，**一定是原生DOM比虚拟DOM更快性能更好。** "},{"id":"205","title":"全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？","category":"百度","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/205","page":"q/百度-205.html","excerpt":"用 const 或 let 声明的变量不会挂在在 window 对象上，而是在一个称为块级作用域（block scope）的作用域内。这个作用域可以是一个函数、一个代码块（比如 {} 之间的语句），或者全局作用域。 在块级作用域中声明的变量无法通过 window 对象访问，只能在当前作用域内访问。如果要在全局作用域中访"},{"id":"1123","title":"深层清理对象中的空值属性【热度: 234】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1123","page":"q/代码实现-1123.html","excerpt":"请实现一个函数 deepOmitNil，要求如下： 功能：递归处理一个可能包含嵌套结构的对象（或数组），移除所有层级中值为 null 或 undefined 的属性 要求： 支持对象和数组的嵌套结构 对于对象：移除值为 null/undefined 的属性，保留其他属性并继续递归处理属性值 对于数组：递归处理每个元素，"},{"id":"1083","title":"前端两个 dom 元素是可以拖拽的， 要实现两个 dom 之间的连接线，如何实现【热度: 55】","category":"代码实现","labels":["web应用场景","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1083","page":"q/代码实现-1083.html","excerpt":"**关键词**：拖拽元素连线实现 **基本思路和技术选择** **思路**：要实现两个可拖拽 DOM 元素之间的连接线，关键在于获取两个元素的位置信息，并根据这些位置动态地绘制连线。通常可以使用 HTML5 的 Canvas 或者 SVG 来实现连线的绘制。 **技术对比**： **Canvas**：它是一个通过 Ja"},{"id":"1079","title":"实现一个加法函数sum，支持sum(1)(2)(3,4)(5,6,7....)【热度: 116】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1079","page":"q/代码实现-1079.html","excerpt":"**关键词**：sum 函数实现 举例： 以下是使用 JavaScript 实现满足要求的sum函数的代码： 在上述代码中： 首先定义了外部的sum函数，它接受任意数量的参数（可以是单个数字或数字数组），并将这些参数的值累加到total变量中。 然后在sum函数内部定义了一个名为innerSum的内部函数，它同样接受任"},{"id":"1053","title":"实现一个处理长字符串的函数【热度: 200】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1053","page":"q/代码实现-1053.html","excerpt":"描述 实现一个处理字符串的函数: 字符串长度不能超过 256，如果超过 256， 字符串中间字符 【...】处理，且处理结果字符串长度还是为 256 以下是使用 JavaScript 实现的函数： 这个函数首先检查输入字符串的长度是否超过 256。如果不超过，则直接返回原字符串。如果超过，它会计算出前后两端保留的字符长"},{"id":"1040","title":"创建一个禁止修改的对象， 只能通过指定方法去修改属性【热度: 410】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1040","page":"q/代码实现-1040.html","excerpt":"具体描述如下 **实现** 以下是使用 JavaScript 实现的createObject函数： 你可以使用以下方式测试这个函数："},{"id":"1014","title":"如何把一个数组随机打乱【热度: 550】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1014","page":"q/代码实现-1014.html","excerpt":"**关键词**：数组随机打乱 在 JavaScript 中，可以使用以下几种方法来随机打乱一个数组： **一、使用sort方法结合随机函数** **基本原理**： JavaScript 的数组sort方法可以接受一个比较函数作为参数。通过提供一个随机的比较函数，可以实现对数组的随机排序，从而打乱数组的顺序。 **示例代"},{"id":"1007","title":"JS 如何翻转一个数组【热度: 327】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1007","page":"q/代码实现-1007.html","excerpt":"**关键词**：翻转数组 在 JavaScript 中，可以通过以下几种方法来翻转一个数组： **一、使用循环和数组拼接** 原理： 通过从数组的末尾开始遍历每个元素，并将其依次添加到一个新的数组中，实现数组的翻转。 首先确定数组的长度，然后从最后一个元素开始，逐个将元素添加到新数组中。 代码示例： **二、使用数组的"},{"id":"1006","title":"JS 如何翻转一个字符串【热度: 442】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1006","page":"q/代码实现-1006.html","excerpt":"**关键词**：翻转字符串 在 JavaScript 中，可以通过以下几种方式翻转一个字符串： **一、使用循环和字符串拼接** 原理： 通过从字符串的末尾开始遍历每个字符，并将其依次拼接起来，从而实现字符串的翻转。 首先获取字符串的长度，然后从最后一个字符开始，逐个将字符添加到一个新的字符串中。 代码示例： **二、"},{"id":"869","title":"实现阿拉伯数字转中文【热度: 673】","category":"代码实现","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/869","page":"q/代码实现-869.html","excerpt":"**关键词**：数字转中文 将阿拉伯数字转换成中文数字，主要考虑到以下几个转换规则： **基本数字**：0-9 对应的汉字数字。 **单位**：十、百、千、万、亿等。 **规则**：数字从右到左，每 4 位一小节，小节内部和小节之间的转换规则。 实现思路 将阿拉伯数字分解成单个数字，从右到左进行处理。 对每 4 位数字"},{"id":"724","title":"扁平数据通过 parent 关联, 实现扁平结构转嵌套 tree 结构【热度: 218】","category":"代码实现","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/724","page":"q/代码实现-724.html","excerpt":"**关键词**：扁平结构转嵌套结构 **题目** **解** 解法非常有意思， 自己好好体会"},{"id":"723","title":"树结构查找， 实现一个函数， 通过 id 来查找 tree 数据结构对应的节点【热度: 867】","category":"代码实现","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/723","page":"q/代码实现-723.html","excerpt":"**关键词**：树结构查找 树结构查找， 实现一个函数， 通过 id 来查找 tree 数据结构对应的节点 **题目如下** **实现**"},{"id":"644","title":"封装一个请求超时， 发起重试的代码【热度: 789】","category":"代码实现","labels":["Shopee","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/644","page":"q/代码实现-644.html","excerpt":"**关键词**：请求重试 看过很多请求超时重试的样例， 很多都是基于 axios interceptors 实现的。 但是有没有牛逼的原生方式实现呢？ 最近在看 fbjs 库里面的代码， 发现里面有一个超时重试的代码， 只有一百多行代码， 封装的极其牛逼。 不过这里的代码是 Flow 类型检测的代码， 而且有一些外部小"},{"id":"601","title":"[代码实现] 手写数组降维flat方法【热度: 244】","category":"代码实现","labels":["阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/601","page":"q/代码实现-601.html","excerpt":"**关键词**：JS数组降维、reduce数组降维 原生Array.prototype.flat方法接受一个depth参数，默认值为1，depth表示要降维的维数： 输出结果： reduce + 递归实现方案"},{"id":"600","title":"[代码实现] 手写 dom 分段渲染【热度: 280】","category":"代码实现","labels":["阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/600","page":"q/代码实现-600.html","excerpt":"**关键词**：dom 分段渲染 分时函数案例：把1秒创建1000个DOM节点，改成每隔200毫秒创建10个节点，这样不用短时间在页面中创建大量的DOM。"},{"id":"599","title":"[代码实现] 不使用 setTimeout 来实现 setInterval【热度: 231】","category":"代码实现","labels":["腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/599","page":"q/代码实现-599.html","excerpt":"**关键词**：实现setInterval、requestAnimationFrame实现setInterval、setTimeout实现setInterval 如果不使用 setTimeout 来实现 setInterval，可以使用 requestAnimationFrame 函数和时间戳来实现定时循环。下面是实现"},{"id":"568","title":"实现日期格式化 format 函数【热度: 489】","category":"代码实现","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/568","page":"q/代码实现-568.html","excerpt":"**关键词**：日期format函数、日期format实现 **问题** **解答** 以下是使用JavaScript实现日期格式化的format函数： 上述代码中，我们通过在Date对象的原型上定义format函数，使得所有的Date对象都可以调用format函数进行日期格式化。在函数内部，我们使用getFullYe"},{"id":"567","title":"实现一个函数， 计算两个日期之间的天数差","category":"代码实现","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/567","page":"q/代码实现-567.html","excerpt":"以下是使用JavaScript实现计算两个日期之间的天数差的函数： 上述函数首先将两个日期字符串转换为Date对象，然后计算两个日期对象之间的时间差（以毫秒表示），最后将时间差转换为天数。通过调用calculateDateDifference函数，可以获取两个日期之间的天数差。"},{"id":"551","title":"[代码实现] JS 中数组深对比实现【热度: 985】","category":"代码实现","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/551","page":"q/代码实现-551.html","excerpt":"**关键词**：JS数组对比 在JavaScript中，可以使用递归的方式实现数组的深度对比。以下是一个示例函数，用于比较两个数组是否相等： 使用示例： 在上述示例中，deepArrayEqual函数会递归比较两个数组的每个元素的值，包括嵌套的数组和对象。如果两个数组是相等的，则返回true，否则返回false。注意，"},{"id":"550","title":"[代码实现] JS 中如何实现大对象深度对比【热度: 906】","category":"代码实现","labels":["百度","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/550","page":"q/代码实现-550.html","excerpt":"**关键词**：JS对象对比 在JavaScript中，可以使用递归的方式实现大对象的深度对比。以下是一个示例函数，用于比较两个大对象的每个属性是否相等： 使用示例： 在上述示例中，deepEqual函数会递归比较两个对象的每个属性的值，包括嵌套的对象或数组。如果两个对象是相等的，则返回true，否则返回false。注"},{"id":"521","title":"[代码实现] 实现一个可以用for...of遍历的对象【热度: 653】","category":"代码实现","labels":["腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/521","page":"q/代码实现-521.html","excerpt":"**关键词**：for...in遍历、for...of遍历 普通对象因为没有迭代器，所以无法使用for...of遍历，一般使用for...in或者Object.keys()来遍历 但是如果我们手动给对象设置一个迭代器，对象也是可以使用for...of来遍历的;"},{"id":"500","title":"[代码实现] 根据 path 来解析数组，生成多维度的数组对象","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/500","page":"q/代码实现-500.html","excerpt":"请手写一个函数， 将下面的树形结构， 进行转换： 输入数据结构 输出数据结构 **实现如下**： `"},{"id":"492","title":"[代码实现] 实现管道函数【热度: 540】","category":"代码实现","labels":["Shopee","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/492","page":"q/代码实现-492.html","excerpt":"**关键词**：JS 管道函数、JS 管道函数实现 管道函数是一种函数编程的概念，它可以将多个函数串联起来，将前一个函数的输出作为后一个函数的输入。以下是一个简单的实现示例： 在上述示例中，我们首先定义了三个简单的示例函数：addOne、double和square。然后，通过调用pipe函数，将这三个函数串联起来创建了"},{"id":"461","title":"[代码实现] 实现数组的flat方法，支持深度层级参数","category":"代码实现","labels":["京东","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/461","page":"q/代码实现-461.html","excerpt":"可以通过传入一个深度参数来限制 flat 方法的递归深度。实现如下： 这里在原有的 flat 方法基础上增加了一个 depth 参数，每递归一层，深度就减一，当深度为 0 时就不再递归。"},{"id":"460","title":"[代码实现] 手写实现 instanceof【热度: 535】","category":"代码实现","labels":["PDD","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/460","page":"q/代码实现-460.html","excerpt":"**关键词**：instanceof原理、instanceof实现、instanceof手写 instanceof 运算符用于检测一个对象是否是某个构造函数的实例。其作用是判断一个对象是否属于某个类（或其父类）的实例，类似于类的继承关系，如果是则返回 true，否则返回 false。通常情况下，用于判断一个对象的类型或"},{"id":"459","title":"[代码实现] 手写实现 Object.create【热度: 179】","category":"代码实现","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/459","page":"q/代码实现-459.html","excerpt":"**关键词**：Object.create实现、Object.create手写 Object.create() 方法可以用于创建一个新对象，使其原型与指定的对象完全相同。可以通过以下方式手写实现 Object.create() 方法。 该实现方式创建了一个名为 F 的空函数，将其原型设置为传入的 proto 对象，然后"},{"id":"448","title":"[代码实现] 手写实现一个缓存函数 memoize【热度: 787】","category":"代码实现","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/448","page":"q/代码实现-448.html","excerpt":"**关键词**：缓存函数实现、memoize函数 用于创建一个带有缓存功能的函数。下面是一个简化版本的手写实现，展示了如何自己实现 memoize 函数： 上述代码中的 memoize 函数接受一个函数 func 作为参数，并返回一个新的函数。返回的函数具有缓存的能力，即根据参数的不同缓存计算结果。 在返回的函数内部，"},{"id":"393","title":"实现一个JS 函数， 解析 url 参数， 返回一个对象","category":"代码实现","labels":["Shopee","滴滴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/393","page":"q/代码实现-393.html","excerpt":"基础版本 下面是一个简单的 JavaScript 函数，用于解析 URL 参数并返回一个包含参数键值对的对象： 这个函数接受一个 URL 字符串作为参数，并返回解析后的参数对象。例如： 这个函数的实现思路是先从 URL 字符串中提取查询字符串部分，然后将查询字符串按照 & 分割成键值对数组。接着遍历键值对数组，将每个键"},{"id":"296","title":"[代码实现] 数字千分化的实现方式有哪些？用代码实现一下【热度: 3,309】","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/296","page":"q/代码实现-296.html","excerpt":"数字千分化是指将数字按照千位分隔符进行分割，使其更容易被人类阅读。在 JavaScript 中，可以通过多种方式实现数字千分化，以下是其中的几种方式： 使用正则表达式 使用 Intl.NumberFormat 使用自带千分位分隔符的 toLocaleString 这些方法都可以实现数字千分化，具体选择哪种方法，可以根据"},{"id":"279","title":"[代码实现] 简单实现一个洋葱模式中间件","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/279","page":"q/代码实现-279.html","excerpt":"洋葱模型是一种常用的中间件模型，例如在 Koa 框架中就广泛应用了这种模型。这种模型的特点是请求被传递到下一个中间件之前，需要先经过当前中间件处理，然后再逐层返回。 下面是一个简单的洋葱模型的示例代码： 这个示例中有三个中间件函数 middleware1、middleware2 和 middleware3，它们都是接受"},{"id":"264","title":"请实现一个 add 函数，满足以下功能","category":"代码实现","labels":["JavaScript","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/264","page":"q/代码实现-264.html","excerpt":"题目如下 解法 Comments / Answers --- **wuhuaizai** at 2023-09-14T06:59:56Z 解法1，2只是柯里化的话，不能实现add(1) // 1这种操作吧，只是柯里化的话add(1)得到的应该还是函数，是不是漏了些代码了？ --- **wuhuaizai** at 20"},{"id":"222","title":"给定两个数组，写一个方法来计算它们的交集？","category":"代码实现","labels":["JavaScript","腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/222","page":"q/代码实现-222.html","excerpt":"可以使用 ES6 的 Set 数据结构来实现数组交集。 首先，将一个数组转化为 Set，然后遍历另一个数组，将数组中存在于 Set 中的元素存入结果数组中。 以下是一个示例代码： 使用示例： 该算法的时间复杂度为 O(m+n)，其中 m 和 n 分别为两个数组的长度。 Comments / Answers --- **"},{"id":"200","title":"手写订阅-发布模式","category":"代码实现","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/200","page":"q/代码实现-200.html","excerpt":"订阅-发布模式是一种常用的设计模式，它可以实现对象间的解耦，让它们不需要相互知道对方的存在，只需要关注自己需要订阅的事件即可。当一个对象的状态发生变化时，它可以发布一个事件通知其他对象，其他对象可以订阅该事件，当事件发生时得到通知并执行相应的处理。 在 JavaScript 中，订阅-发布模式也被称为事件模型。事件模型"},{"id":"199","title":"手写 观察者模式","category":"代码实现","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/199","page":"q/代码实现-199.html","excerpt":"观察者模式（又称发布-订阅模式）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，其相关的依赖对象都能够得到通知并被自动更新。 在 JavaScript 中实现观察者模式，可以分为以下几个步骤： 创建一个主题对象（Subject），用来存储观察者对象，并提供添加、删除、通知观察者的"},{"id":"107","title":"[代码实现] 手写代码实现 promise.all","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/107","page":"q/代码实现-107.html","excerpt":"下面是手写实现 Promise.all() 方法的代码： 实现原理： Promise.all() 方法接收一个包含多个 Promise 的数组作为参数，并返回一个新的 Promise。该 Promise 将会在数组中所有 Promise 状态均为 fulfilled 时被解决，并且以数组形式返回所有 Promise 的"},{"id":"106","title":"[代码实现] 手写代码实现 promise.race","category":"代码实现","labels":["代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/106","page":"q/代码实现-106.html","excerpt":"下面是手写实现 Promise.race() 方法的代码： 实现原理： Promise.race() 方法接收一个包含多个 Promise 的数组作为参数，并返回一个新的 Promise。该 Promise 将会在数组中的任意一个 Promise 状态变为 fulfilled 或 rejected 时被解决，且以第一个"},{"id":"748","title":"[React] useEffect 钩子的工作原理是什么【热度: 459】","category":"滴滴","labels":["web框架","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/748","page":"q/滴滴-748.html","excerpt":"**关键词**：React useEffect useEffect 钩子的工作原理涉及到 React 的渲染流程和副作用的调度机制。以下是其工作原理的详细说明： **调度副作用**：当你在组件内部调用 useEffect 时，你实际上是将一个副作用函数及其依赖项数组排队等待执行。这个函数并不会立即执行。 **提交阶段（"},{"id":"747","title":"[React] 介绍一下 useReducer【热度: 547】","category":"滴滴","labels":["web框架","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/747","page":"q/滴滴-747.html","excerpt":"**关键词**：React useReducer useReducer是 React Hooks 的一个部分，它为状态管理提供了一个更加灵活的方法。useReducer特别适合处理包含多个子值的复杂状态逻辑，或者当下一个状态依赖于之前的状态时。与useState相比，useReducer更适合于复杂的状态逻辑，它使组件"},{"id":"696","title":"浏览器对队头阻塞有什么优化？【热度: 368】","category":"滴滴","labels":["网络","浏览器","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/696","page":"q/滴滴-696.html","excerpt":"**关键词**：队头阻塞优化 队头阻塞（Head-of-Line Blocking，缩写 HoLB）问题主要发生在网络通信中，特别是在使用 HTTP/1.1 和以前版本时，在一个 TCP 连接中同一时间只能处理一个请求。即使后续的请求已经准备好在客户端，它们也必须等待当前处理中的请求完成后才能被发送。这会延迟整个页面或"},{"id":"695","title":"Proxy 和 Reflect 有什么关系？【热度: 361】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/695","page":"q/滴滴-695.html","excerpt":"Proxy 和 Reflect 是 ES6 (ECMAScript 2015) 中引入的两个不同的构造函数，它们密切相关，通常在某些操作中一起使用。 **Proxy**： Proxy 对象用于定义基本操作的自定义行为，例如属性查找、赋值、枚举、函数调用等。当你对一个Proxy对象执行这些操作时，你可以拦截并重新定义这些"},{"id":"560","title":"splice 和 slice 有什么区别？【热度: 282】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/560","page":"q/滴滴-560.html","excerpt":"**关键词**：Array 方法 splice、Array 方法 slice、splice 和 slice 区别 splice() 和 slice() 是 JavaScript 中用于操作数组的两个方法，它们的功能和用法有一些区别。 splice() 方法： 功能：从数组中添加、删除或替换元素。 用法：array.sp"},{"id":"540","title":"类型的转换有哪些【热度: 631】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/540","page":"q/滴滴-540.html","excerpt":"**关键词**：js类型转换 可以将上述类型转换分为以下几类： 显式转换：显式转换是通过特定的函数或操作符来实现的，开发者明确地指定了类型转换的规则和目标类型。例如使用String()、Number()、Boolean()等函数进行类型转。 隐式转换：隐式转换是在特定的运算或操作中自动发生的，不需要开发者明确指定类型转"},{"id":"539","title":"箭头函数解决了什么问题【热度: 568】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/539","page":"q/滴滴-539.html","excerpt":"**关键词**：箭头函数、箭头函数特点 箭头函数是ES6中引入的一种新的函数语法，它主要解决了以下几个问题： **简化函数表达式**：箭头函数提供了一种更简洁的函数定义方式，可以用更短的语法来定义函数，减少了冗余的代码。例如，使用箭头函数可以将一个函数表达式 function(x) { return x * x; } "},{"id":"494","title":"HTML5 的 History API 进行导航时，页面真的进行了一个切换吗？【热度: 424】","category":"滴滴","labels":["浏览器","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/494","page":"q/滴滴-494.html","excerpt":"**关键词**：History 导航、History 导航页面切换、History 页面切换 当使用 HTML5 的 History API 进行导航时，页面实际上没有进行完全的刷新。相反，只是通过 JavaScript 动态地更改 URL，并通过这个新的 URL 加载相应的内容。 这种方式被称为前端路由，因为页面的切"},{"id":"484","title":"proxy 有那些实际使用场景【热度: 849】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/484","page":"q/滴滴-484.html","excerpt":"**关键词**：proxy 应用场景、proxy 作用是什么 JavaScript的Proxy对象提供了一种拦截并定制JavaScript对象底层操作的机制。它允许你在对象上定义自定义行为，例如访问、赋值、函数调用等操作。Proxy对象包裹着目标对象，并拦截对目标对象的访问，使你能够自定义处理这些操作。 Proxy可以"},{"id":"479","title":"模拟new操作【热度: 1,186】","category":"滴滴","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/479","page":"q/滴滴-479.html","excerpt":"**关键词**：模拟 new 可以使用以下代码来模拟new操作： 使用示例： 在上述代码中，myNew函数模拟了new操作的过程： 首先，通过Object.create创建了一个新对象obj，并将构造函数的原型对象赋值给该新对象的原型。 然后，使用apply方法调用构造函数，并传入新对象obj作为this值，以及其他参"},{"id":"393","title":"实现一个JS 函数， 解析 url 参数， 返回一个对象","category":"滴滴","labels":["Shopee","滴滴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/393","page":"q/滴滴-393.html","excerpt":"基础版本 下面是一个简单的 JavaScript 函数，用于解析 URL 参数并返回一个包含参数键值对的对象： 这个函数接受一个 URL 字符串作为参数，并返回解析后的参数对象。例如： 这个函数的实现思路是先从 URL 字符串中提取查询字符串部分，然后将查询字符串按照 & 分割成键值对数组。接着遍历键值对数组，将每个键"},{"id":"1121","title":"如何将一个非常到大的 spa 应用， 迁移到微前端架构， 有哪些考虑因素【热度: 754】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1121","page":"q/工程化-1121.html","excerpt":"**关键词**：微前端框架 将大型 SPA（单页应用）迁移到微前端架构是一个复杂的系统工程，需要从业务、技术、团队等多维度综合考量。其核心目标是解决大型 SPA 的代码臃肿、团队协作低效、技术栈锁定、部署缓慢等问题，同时确保迁移过程平稳、业务不受影响。 一、迁移前的核心前提：明确目标与现状评估 在动手迁移前，需先明确“"},{"id":"1120","title":"微前端架构有哪些主流框架可以选， 各有啥优劣势？【热度: 554】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1120","page":"q/工程化-1120.html","excerpt":"**关键词**：微前端框架 以下是前端领域主流微前端框架的深度解析，涵盖核心特性、优劣势及适用场景，结合最新技术动态和企业级实践： 一、核心框架对比与选型指南 1. **Qiankun（蚂蚁集团）** **核心特性**： 基于 Single-SPA 封装，支持 React/Vue/Angular 等多框架共存 提供 J"},{"id":"1119","title":"如何对一个大型 SPA（单页应用）进行全面的性能优化？请从构建阶段、运行时、网络请求、渲染等多个维度说明。【热度: 761】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1119","page":"q/工程化-1119.html","excerpt":"**关键词**：性能优化 对大型 SPA（单页应用）进行全面性能优化需要从多个维度入手，以下是系统性的优化策略： **一、构建阶段优化** **1. 代码分割与懒加载** **动态导入（Dynamic Import）**：按需加载路由组件、组件库、第三方模块 **路由级分割**：按路由拆分 chunks，减少首屏加载体"},{"id":"1118","title":"很多web前端框架里面会有约定式路由， 他们是如何实现的【热度: 331】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1118","page":"q/工程化-1118.html","excerpt":"**关键词**：约定是路由 约定式路由（Convention over Configuration，CoC）是现代前端框架（如 Next.js、Nuxt.js、VitePress 等）广泛采用的路由实现方式，其核心思想是**根据文件目录结构自动生成路由配置**，无需手动编写冗长的路由表。下面介绍其实现原理和关键技术： "},{"id":"1113","title":"为何 Web Components 没有成为 web 前端的主流技术框架， 反而是 react 和 vue 呢？【热度: 531】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1113","page":"q/工程化-1113.html","excerpt":"**关键词**：Web Components Web Components 虽具备技术优势，但未能成为前端主流框架的核心原因可从以下维度分析： 一、**生态与工具链成熟度** **React/Vue 的生态优势** 主流框架拥有完善的工具链（如 Webpack、Vite）、状态管理库（Redux、Pinia）、UI 组"},{"id":"1112","title":"Web Components 有哪些优势【热度: 489】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1112","page":"q/工程化-1112.html","excerpt":"**关键词**：Web Components Web Components 作为现代前端开发的重要技术，具有以下显著优势： 一、**真正的组件封装** **样式隔离** Shadow DOM 确保组件内部样式不会泄露到外部，也不受外部样式影响，彻底解决 CSS 全局污染问题。 **示例**：组件内部的 .button "},{"id":"1111","title":"介绍一下 Web Components和Shadow DOM【热度: 489】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1111","page":"q/工程化-1111.html","excerpt":"**关键词**：Web Components Web Components 和 Shadow DOM 详解 一、Web Components 概述 Web Components 是一套用于构建可复用、封装性强的 Web 组件的标准，它允许开发者创建自定义 HTML 元素，这些元素具有独立的功能、样式和行为，可在不同项目"},{"id":"1110","title":"解释 V8 引擎的内存管理机制，如何通过优化闭包或对象结构减少内存泄漏？【热度: 748】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1110","page":"q/工程化-1110.html","excerpt":"**关键词**：内存机制、内存泄露 **关键词**：内存机制、内存泄露 **关键词**：内存机制、内存泄露 一、V8 引擎内存管理机制概述 V8 是 Google 开发的 JavaScript 引擎，采用**自动垃圾回收机制**管理内存，其核心流程包括： 1. **内存分配** **栈内存**：存储原始类型值（如 Nu"},{"id":"1109","title":"该如何给自己的项目添加 jest 去测试 react ts 项目【热度: 122】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1109","page":"q/工程化-1109.html","excerpt":"**关键词**：前端测试 jest 配置 当使用 Babel 编译 React TypeScript 项目并配置 Jest 时，可按以下步骤进行： 1. 安装必要的依赖 在项目根目录下，通过以下命令安装所需的依赖： jest：测试框架。 babel-jest：让 Jest 能使用 Babel 转换代码。 @babel/"},{"id":"1108","title":"jest 有哪些重要配置？【热度: 180】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1108","page":"q/工程化-1108.html","excerpt":"**关键词**：前端单测 jest 配置 Jest 有许多重要配置项，它们能帮助你根据项目需求定制测试环境和流程。以下是一些关键的 Jest 配置项及其用途： 1. testMatch **作用**：指定 Jest 要测试的文件匹配模式。Jest 会在项目中查找符合这些模式的文件并执行测试。 **示例**： 上述配置表"},{"id":"1107","title":"如何排除样式文件、图片等资源文件进行单测【热度: 173】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1107","page":"q/工程化-1107.html","excerpt":"**关键词**：前端单测，如何排除样式文件、图片 在进行前端单元测试时，样式文件（如 CSS、SCSS 等）和图片等资源文件通常不会影响代码的逻辑功能，为了让测试更加专注于代码逻辑，避免不必要的依赖和错误，需要排除这些资源文件。下面分别介绍使用不同测试框架（如 Jest）时的处理方法。 使用 Jest 排除资源文件 1"},{"id":"1106","title":"单测中，如果有一些三方依赖，想排除这个三方依赖进行测试，该如何做？【热度: 387】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1106","page":"q/工程化-1106.html","excerpt":"**关键词**：前端单测，如何排除三方依赖 在单元测试里，当存在三方依赖时，为保证测试的独立性与稳定性，你可以采用模拟（Mock）或桩（Stub）的方式排除这些三方依赖。下面结合不同的测试框架和场景，介绍具体的实现方法。 使用 Jest 进行模拟 Jest 是一个功能强大的 JavaScript 测试框架，它内置了模拟"},{"id":"1105","title":"如何 对 react 状态库进行单测， 比如 redux、recoil 等状态库【热度: 170】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1105","page":"q/工程化-1105.html","excerpt":"**关键词**：前端单测模拟 react 状态 下面分别介绍如何对 Redux 和 Recoil 这两种常见的 React 状态库进行单元测试。 测试 Redux Redux 是一个可预测的状态容器，主要由 actions、reducers 和 store 构成。单元测试时可分别对这些部分进行测试。 1. 测试 Act"},{"id":"1104","title":"jest 单测， 如何测试 react 组件交互【热度: 200】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1104","page":"q/工程化-1104.html","excerpt":"**关键词**：前端单测模拟 react 交互 在 Jest 中测试 React 组件交互，通常会结合 React Testing Library 一起使用，它专注于从用户交互的角度来测试组件，鼓励编写接近用户实际使用场景的测试用例。以下将详细介绍测试 React 组件交互的步骤和示例。 1. 安装依赖 首先要确保项目"},{"id":"1103","title":"前端单测，如何通过单测模拟请求【热度: 265】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1103","page":"q/工程化-1103.html","excerpt":"**关键词**：前端单测模拟请求 在前端单元测试里，模拟请求是很重要的操作，它能让你在不依赖真实后端服务的情况下对前端代码进行测试。以下以 React 项目为例，结合不同的测试框架和模拟工具，为你介绍模拟请求的方法。 使用 Jest 和 axios-mock-adapter 模拟 axios 请求 axios 是常用的"},{"id":"1102","title":"如何保障前端项目质量【热度: 717】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1102","page":"q/工程化-1102.html","excerpt":"**关键词**：前端项目质量保证 保障前端项目质量可从开发流程、代码规范、测试体系、部署监控等多方面入手，以下是详细介绍： 遵循规范的开发流程 **需求分析与设计**：和产品经理、设计师等充分沟通，理解项目需求和设计方案。输出详细的需求文档和设计稿，为后续开发提供清晰的指引。 **代码编写**：按照设计方案进行代码开发"},{"id":"1101","title":"前端 e2e 测试， 该如何选型【热度: 335】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1101","page":"q/工程化-1101.html","excerpt":"**关键词**：前端测试 在进行前端端到端（E2E）测试选型时，需要综合考虑多方面因素，如测试框架的功能特性、易用性、社区支持、性能等。以下为你介绍几种常见的前端 E2E 测试工具，并给出选型建议。 常见前端 E2E 测试工具 1. Cypress **优点** **易于上手**：提供了简洁直观的 API，测试代码编写"},{"id":"1100","title":"前端 单元测试， react 项目为例， 该如何做单测选型【热度: 405】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1100","page":"q/工程化-1100.html","excerpt":"**关键词**：前端测试 在 React 项目中进行单元测试选型时，你需要综合考量测试框架、断言库、模拟工具等多个方面，以下是详细的选型建议： 测试框架 Jest **优点** **功能集成度高**：集测试运行器、断言库、模拟功能于一体，无需额外安装大量依赖，配置简单，能快速上手。 **性能出色**：支持并行测试，可显"},{"id":"1099","title":"如何搭建前端测试环境【热度: 505】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1099","page":"q/工程化-1099.html","excerpt":"**关键词**：前端测试 搭建前端测试体系是一个系统性工程，下面从几个关键方面详细介绍其搭建步骤： 1. 规划测试策略 **确定测试范围**：明确需要测试的前端项目部分，例如页面布局、交互功能、组件、API 调用等。要考虑项目的规模、复杂度以及业务的关键功能点。 **设定测试目标**：比如保证代码质量、提升用户体验、减"},{"id":"1090","title":"vite 开发过程是直接将文件给浏览器【热度: 107】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1090","page":"q/工程化-1090.html","excerpt":"**关键词**：vite 与 esbuild 那比如我使用的是 比如我开发是使用的 less + ts + react 他是怎么处理的 **Vite 不是直接将原始文件给浏览器** Vite 是一个基于原生 ES 模块的前端构建工具。在开发过程中，它利用浏览器对原生 ES 模块的支持来提供快速的开发服务器。当你启动 V"},{"id":"1089","title":"vite 与 esbuild 是关系【热度: 55】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1089","page":"q/工程化-1089.html","excerpt":"**关键词**：vite 与 esbuild **Vite 对 Esbuild 的依赖关系（构建阶段）** **代码转换和打包工具**：在 Vite 的构建过程（vite build）中，Esbuild 扮演了重要的角色。Esbuild 是一个超高速的 JavaScript 打包器，Vite 利用 Esbuild 来进"},{"id":"1088","title":"vite 在开发过程中， 是如何处理 TS 文件的【热度: 112】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1088","page":"q/工程化-1088.html","excerpt":"**关键词**：vite、开发、TS **即时编译 TS 文件** **原理**：在 Vite 开发过程中，它利用浏览器原生 ES 模块（ESM）的支持，对于 TypeScript（TS）文件，Vite 会在浏览器请求时即时将其编译为 JavaScript。这个编译过程是由 Vite 内部的插件机制和 TypeScri"},{"id":"1087","title":"vite 开发和构建有何不同？【热度: 292】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1087","page":"q/工程化-1087.html","excerpt":"**关键词**：vite、开发、构建 **开发阶段** **快速的模块加载** **原理**：在开发阶段，Vite 充分利用浏览器对原生 ES 模块（ESM）的支持。当浏览器请求一个模块时，Vite 直接将对应的 ES 模块文件发送给浏览器，而不需要像传统构建工具那样先进行打包。这使得模块加载速度非常快，因为浏览器可以"},{"id":"1086","title":"前端有哪些性能指标？其中：FCP、LCP、TTFB、FID、TTI、CLS、TBT 等， 分别表示什么意思【热度: 393】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1086","page":"q/工程化-1086.html","excerpt":"**FCP（First Contentful Paint） - 首次内容绘制** **含义**：FCP是指浏览器首次绘制来自DOM的任何内容（如文本、图像、非白色的<canvas>或SVG）的时间点。这是用户体验的一个重要指标，因为它标志着页面开始有实际内容显示给用户，而不仅仅是空白的屏幕。 **重要性**：对于用户来"},{"id":"1085","title":"如何去衡量用户操作过程中否卡顿【热度: 492】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1085","page":"q/工程化-1085.html","excerpt":"**关键词**：卡顿、性能、用户体验 **使用浏览器性能指标 - FPS（每秒帧数）** **基本原理**：FPS 是衡量页面流畅度的重要指标。在浏览器中，动画和交互的流畅呈现通常依赖于较高的 FPS。一般来说，当 FPS 达到 60 时，用户体验会比较流畅，因为这意味着每秒有 60 帧画面更新，人眼很难察觉到卡顿。如"},{"id":"1084","title":"我使用 vite 打包工程， 输出为 es6 的代码， 但是我依赖的 模块是 es5 commonjs 写的；这个他是怎么处理的【热度: 459】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1084","page":"q/工程化-1084.html","excerpt":"**关键词**：vite 打包、es6 转 es5 **Vite 的模块解析机制** **概述**：Vite 在打包过程中会对模块进行解析。当遇到 ES6 模块（ESM）和 CommonJS 模块混合的情况时，它会根据模块的类型采用不同的处理策略。Vite 内部的模块解析系统能够识别模块的语法是 ES6 还是 Comm"},{"id":"1077","title":"Rollup 为何高效【热度: 200】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1077","page":"q/工程化-1077.html","excerpt":"**基于 ES 模块的静态分析** **原理**：Rollup 是围绕 ES 模块（ESM）构建的打包工具。ES 模块具有静态的特性，其导入（import）和导出（export）语句在代码解析阶段就可以确定。Rollup 利用这种静态结构，通过对代码的一次遍历就能构建出完整的模块依赖树。 **优势**：相比传统的 Co"},{"id":"1076","title":"vite 和  rollup 是什么样的依赖关系【热度: 153】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1076","page":"q/工程化-1076.html","excerpt":"**关键词**：vite 和 rollup **Vite 对 Rollup 的依赖关系（主要在生产构建阶段）** **构建过程的底层调用**：Vite 在生产构建过程中依赖 Rollup 来打包代码。当执行vite build命令时，Vite 会在内部调用 Rollup 来处理模块打包任务。Rollup 会按照 Vit"},{"id":"1075","title":"[webpack] externals 是如何加载外部依赖的【热度: 330】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1075","page":"q/工程化-1075.html","excerpt":"**关键词**：webpack externals **externals基础原理** 当在 Webpack 配置文件中使用externals选项时，实际上是在告诉 Webpack 某些模块应该被视为外部依赖，而不是被打包进最终的输出文件。这意味着这些模块将在运行时由浏览器或其他运行环境提供，而不是由 Webpack "},{"id":"1074","title":"[webpack] 在编译产物的时候， 要区分 source 代码和外部依赖代码， 该如何处理【热度: 125】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1074","page":"q/工程化-1074.html","excerpt":"**关键词**：webpack 产物 **使用 Webpack 的optimize-module-ids插件（用于区分模块来源）** **原理**：Webpack 在打包过程中会为每个模块分配一个唯一的module.id。optimize-module-ids插件可以帮助控制模块标识符的生成方式，使得能够根据模块是源文"},{"id":"1073","title":"corejs 是做什么用的， 跟 Polyfill 是什么关系【热度: 100】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1073","page":"q/工程化-1073.html","excerpt":"**关键词**：corejs 和 Polyfill **CoreJs 的作用** **提供标准的 JavaScript 功能支持**：CoreJs 是一个 JavaScript 标准库，它提供了许多在现代 JavaScript 环境中被认为是标准的功能。这些功能包括但不限于对 ES6 + 语法的支持，如Promise、"},{"id":"1072","title":"[Webpack] 我如何实现在高版本浏览器上使用 es6 产物， 在低版本上使用 es5【热度: 122】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1072","page":"q/工程化-1072.html","excerpt":"**关键词**：Webpack es6 产物 **分别打包 ES5 和 ES6 产物（从一份 ES6 源码）** **配置 Webpack 和 Babel 基础环境** 首先，安装必要的依赖。除了 Webpack 本身相关的依赖外，还需要babel - loader、@babel/core和@babel/preset "},{"id":"1071","title":"Webpack 与 Vite 在产物结果上有何区别【热度: 420】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1071","page":"q/工程化-1071.html","excerpt":"**关键词**：Webpack 与 Vite 产物差异 **模块格式和加载方式** **Webpack**： 在产物中，Webpack 通常会将多个模块打包成一个或多个 bundle 文件。这些 bundle 文件的格式可以是多种形式，如 CommonJS（在 Node.js 环境下常用）或者 IIFE（立即调用函数表"},{"id":"1070","title":"Webpack 与 Vite的核心差异点在哪儿【热度: 610】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1070","page":"q/工程化-1070.html","excerpt":"**关键词**：Webpack 与 Vite 核心差异 **构建原理差异** **Webpack**： 基于打包（Bundle）的理念。在处理模块时，Webpack 会从一个入口文件开始，递归地构建整个模块依赖图。它会把所有的模块（包括 JavaScript、CSS、图片等各种资源）都打包到一个或多个 bundle 文"},{"id":"1029","title":"前端应用 CICD 有哪些方式实现【热度: 120】","category":"工程化","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1029","page":"q/工程化-1029.html","excerpt":"**关键词**：前端 CICD 前端应用的持续集成与持续部署（CI/CD）可以通过以下几种方式实现： **一、使用 Jenkins** 持续集成： Jenkins 可以监听代码仓库（如 Git）的变化，当有新的代码提交时，自动触发构建任务。 对于前端项目，可以配置 Jenkins 执行构建命令，如使用 npm 或 ya"},{"id":"1021","title":"如何定制化开发一个 eslint 插件， 功能是实现提示检验某一个项目里面的字符串error【热度: 10】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1021","page":"q/工程化-1021.html","excerpt":"**关键词**：eslint 插件编写 以下是一个可以检测特定字符串并支持参数传递的 ESLint 插件开发步骤： **一、创建插件项目** 创建一个新的目录来存放插件项目，例如eslint-plugin-custom-string-check。 在该目录下，运行npm init初始化一个 npm 项目。 **二、插件"},{"id":"1020","title":"eslint 如何集成到 webpack【热度: 488】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1020","page":"q/工程化-1020.html","excerpt":"**关键词**：eslint 配置 要将 ESLint 集成到 Webpack 中，可以按照以下步骤进行操作： **一、安装必要的包** 确保已经安装了 Webpack 和 ESLint。如果还没有安装，可以使用以下命令进行安装： 使用 npm： 使用 yarn： 安装eslint-webpack-plugin插件，这"},{"id":"1019","title":"eslint 有哪些实用的插件， 该如何配置【热度: 488】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1019","page":"q/工程化-1019.html","excerpt":"**关键词**：eslint 配置 ESLint 有很多实用的插件，可以帮助提高代码质量和开发效率。以下是一些常见的 ESLint 插件及配置方法： **一、常见插件介绍** eslint-plugin-import： 作用：用于检查和规范导入语句。可以确保导入路径的正确性、防止重复导入、检查导入顺序等。 例如，它可以"},{"id":"1018","title":"eslint 该如何配置【热度: 487】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1018","page":"q/工程化-1018.html","excerpt":"**关键词**：eslint 配置 在前端项目中，配置 ESLint 可以帮助你保持代码风格的一致性和提高代码质量。以下是配置 ESLint 的一般步骤： **一、安装 ESLint** 首先，确保你已经安装了 Node.js 和 npm（或 yarn）。 在项目目录中，使用以下命令安装 ESLint： 使用 npm："},{"id":"1017","title":"前端工程里面，如何检测并避免循环依赖【热度: 359】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1017","page":"q/工程化-1017.html","excerpt":"**关键词**：循环依赖检测 在前端工程中，可以通过以下方法检测并避免循环依赖： **一、检测循环依赖** 手动审查代码： 仔细检查项目中的模块导入关系。查看每个模块的导入语句，确定是否存在一个模块被另一个模块导入，而后者又反过来导入前者的情况。 对于大型项目，可以使用工具辅助手动审查，如代码编辑器的搜索功能或一些专门"},{"id":"1016","title":"npm workspaces 是什么概念， 主要是解决什么问题【热度: 100】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1016","page":"q/工程化-1016.html","excerpt":"**关键词**：npm workspaces 概念 npm workspaces是一个在 npm 中用于管理多包项目的功能。它主要解决以下几个问题： **一、项目结构管理** **多包项目组织**： 在大型项目中，可能包含多个独立的软件包或模块。npm workspaces允许将这些包组织在一个统一的项目结构中，方便管"},{"id":"1009","title":"[webpack] 是如何处理 commonjs 模块的文件， 使其编译结果能被浏览器使用。【热度: 210】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/1009","page":"q/工程化-1009.html","excerpt":"**关键词**：webpack 打包处理 commonjs 模块 以下是详细讲解 Webpack 如何将 CommonJS 模块转换为浏览器可以执行的 JavaScript 文件： **一、模块解析阶段** **识别 CommonJS 模块**： Webpack 从项目的入口文件（通常在配置中指定，如entry: '."},{"id":"991","title":"部署一个 node 应用要考虑哪些因素【热度: 98】","category":"工程化","labels":["Nodejs","工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/991","page":"q/工程化-991.html","excerpt":"**关键词**：node 应用部署 **一、选择服务器和环境** **服务器选择**： 可以选择云服务器提供商（如阿里云、腾讯云、AWS 等）的虚拟服务器或容器服务。根据应用的需求和预算，确定服务器的配置（CPU、内存、存储等）。 考虑服务器的地理位置和网络连接质量，以确保用户能够快速访问应用。 **操作系统**： 常"},{"id":"976","title":"commonjs 模块化中 module.exports 与 exports 有什么区别， 该如何选择【热度: 194】","category":"工程化","labels":["工程化","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/976","page":"q/工程化-976.html","excerpt":"**关键词**：模块化 导出 在 CommonJS 模块化规范中，module.exports与exports有以下区别： **一、module.exports** **本质**： module.exports是一个对象，它代表当前模块要导出的内容。可以将任意类型的值（如函数、对象、字符串等）赋值给module.exp"},{"id":"970","title":"对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗【热度: 108】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/970","page":"q/工程化-970.html","excerpt":"**关键词**：tree-shaking 使用 在使用 Webpack 进行打包时，对于已经导入（import）但未实际使用的模块，通常情况下不会被打包进去，但这也取决于具体的配置和使用场景。 **一、默认行为** 在默认情况下，Webpack 会进行“树摇”（tree shaking）操作。树摇是一种优化技术，它可以"},{"id":"957","title":"前端需要加载一个大体积的文件时， 一般有哪些优化思路【热度: 594】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/957","page":"q/工程化-957.html","excerpt":"**关键词**：前端加载文件过大 当前端需要加载大体积文件时，可以从以下几个方面进行优化： **一、文件压缩** **服务器端压缩**： 在服务器上配置文件压缩功能，如使用 Gzip 或 Brotli 压缩算法对文件进行压缩后再传输。这样可以显著减少文件的大小，降低传输时间。 例如，在 Nginx 服务器中，可以通过配"},{"id":"956","title":"前端部署应该要考虑哪些问题【热度: 310】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/956","page":"q/工程化-956.html","excerpt":"**关键词**：前端部署 在前端部署到生产环境时，有多个关键问题需要解决： **一、高可用性与故障应对** 生产环境中，单点故障是必须考虑的问题。若一台物理机突然崩溃，应用需依然能够正常运行。这时可以了解 Kubernetes（k8s）的 Deployment，它能够有效地应对单点故障，确保应用的高可用性。 **二、热"},{"id":"953","title":"[webpack] tree-shaking 原理【热度: 722】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/953","page":"q/工程化-953.html","excerpt":"**关键词**：tree-shaking 原理 作者备注 webpack 热门问题 Webpack 的 Tree Shaking 主要是用来消除未被使用的代码，以减小最终打包文件的体积。其原理如下： **一、静态分析** 模块依赖分析： Webpack 在构建过程中，会对项目中的模块进行依赖分析。它会解析每个模块的内容"},{"id":"944","title":"[webpack] 发中使用的是 esm 和 webpack, 是否可以直接调用 commonjs 模块化的三方包【热度: 359】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/944","page":"q/工程化-944.html","excerpt":"**关键词**：模块化混用 在使用 Webpack 作为构建工具的项目中，ESM (ECMAScript Modules) 和 CommonJS 模块系统可以混用。 Webpack 提供了对两种模块化标准的支持，能够理解和处理它们之间的差异，使得这两种不同类型的模块可以在同一个项目中共存。 混用时的考虑因素 虽然 ES"},{"id":"889","title":"pnpm install 和 npm install 有何区别","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/889","page":"q/工程化-889.html","excerpt":"pnpm install 和 npm install 都是用于安装 JavaScript 项目依赖的命令，但它们背后的包管理器（分别是 pnpm 和 npm）在处理依赖安装、存储和优化方面有一些关键区别。 1. **存储方式的区别** **npm**：在每个项目的 node_modules 文件夹中分别存储其依赖。这意"},{"id":"888","title":"monorepo 工程有哪些工具架构， 该如何选型【热度: 450】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/888","page":"q/工程化-888.html","excerpt":"**关键词**：monorepo 技术选项 工具推荐 | 工具 | **Turborepo** | **Rush** | **Nx** | **Lerna** | **Pnpm Workspace** | | -------- | ------------- | -------- | ------ | --------"},{"id":"887","title":"[webpack] 如何优化产物大小【热度: 521】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/887","page":"q/工程化-887.html","excerpt":"**关键词**：webpack 产物大小优化 在使用 Webpack 进行项目构建时，减少包体积是提升加载速度、改善用户体验的关键措施之一。以下是一些通用的方法和技巧来减小构建结果的包体积： 1. **使用 Tree Shaking** Tree Shaking 是一个通过清除未引用代码（dead-code）的过程，可"},{"id":"886","title":"[webpack] 代码分割中，让所有的外部依赖打成一个包，源码 source 打成一个包，该如何配置【热度: 352】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/886","page":"q/工程化-886.html","excerpt":"**关键词**：webpack 代码分割 为了实现你的需求，即将所有外部依赖（node_modules 中的依赖）打包成一个单独的包，而你自己的源码打包成另一个包，可以通过配置 Webpack 的 optimization.splitChunks 选项来实现。下面是具体的实施方案： 1. 编辑 webpack.conf"},{"id":"841","title":"[webpack] 多个 loader 对同一个资源进行处理， 他们之间如何通信？【热度: 134】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/841","page":"q/工程化-841.html","excerpt":"**关键词**：webpack loader 通信 在 webpack 中，loader 之间传递数据的常见方式是通过资源文件（即要处理的源文件本身）的内容。每个 loader 接收上一个 loader 的处理结果作为输入，并提供自己的输出给下一个 loader。这种方式适用于大多数使用场景。然而，在某些情况下，loa"},{"id":"840","title":"[webpack] 手写 webpack loader 有哪些重要 api 与注意事项？【热度: 718】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/840","page":"q/工程化-840.html","excerpt":"**关键词**：手写 webpack loader 在开发一个 webpack loader 时，除了理解 loader 的基本概念和功能之外，还有一些重要的 API 和注意事项是必需了解的。这些能够帮助你更高效地编写和调试 loader。 重要 API **this.callback**: 在 loader 函数内部"},{"id":"839","title":"[webpack] 手写 loader: 我要在方法调用的时候， 上报调用源文件地址【热度: 117】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/839","page":"q/工程化-839.html","excerpt":"**关键词**：手写 webpack loader 要在方法调用时上报调用源文件的地址，并且希望通过 webpack 编译时来实现，你可以通过编写一个自定义的 webpack loader 来操作源代码，为特定的方法调用插入上报的代码。自定义 loader 本质上是一个函数，该函数接收源码作为输入，对源码进行处理后返回"},{"id":"838","title":"[webpack] 手写 webpack plugin 有那些重要 api 与注意的地方？【热度: 714】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/838","page":"q/工程化-838.html","excerpt":"**关键词**：手写 webpack plugin 在手写一个 webpack 插件时，理解和使用一些核心的 API 是非常关键的。以下是编写 webpack 插件时需要知道的一些重要的 API 和注意事项。 重要的 API **compiler 对象**: compiler.hooks: 提供了一系列的钩子，用于插件"},{"id":"837","title":"[webpack] 手写一个 plugin, 统计源码里面的 console.log 调用数量与调用路径【热度: 113】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/837","page":"q/工程化-837.html","excerpt":"**关键词**：手写 webpack plugin 创建一个 webpack 插件需要遵循 webpack 插件的基本结构和原则，同时为了实现统计源码里的 console.log 调用数量与调用路径的目标，我们可能需要对 webpack 的编译过程有一定的了解，尤其是如何操作 webpack 的模块系统内部的原始源代码"},{"id":"816","title":"[webpack] 构建过程中， 是如何将我们 es6 代码 编译为 es5【热度: 420】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/816","page":"q/工程化-816.html","excerpt":"**关键词**：es6 编译为 es5 Webpack 本身是一个模块打包器（bundler），它并不直接负责将 ES6 代码编译为 ES5 代码。Webpack 的主要功能是将项目中的所有模块（JavaScript、图片、CSS 等）打包成一个或多个 bundle，以供浏览器加载。然而，Webpack 可以通过加载器"},{"id":"805","title":"babel-runtime 作用是啥【热度: 200】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/805","page":"q/工程化-805.html","excerpt":"**关键词**：babel-runtime 作用 babel-runtime 是一个包含 babel 模块化运行时助手的库。 在使用 babel 进行代码转换时，有时会注入一些在多个文件中相同且可能被重复使用的代码。例如，使用类转换（无松散模式）时，每个包含类的文件都会重复出现类似 _classcallcheck 这样"},{"id":"783","title":"应用如何做应用灰度发布【热度: 247】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/783","page":"q/工程化-783.html","excerpt":"**关键词**：灰度发布 应用的灰度发布是将新版本逐步推出给有限的用户群体，以在完全发布之前监控其性能和搜集用户反馈的过程。这可以确保新版本的稳健性，减少因新版本可能引起的问题对所有用户的影响。以下是实现应用灰度发布的几种常见方法： 1. 基于 HTTP 头或 Cookie 的路由 通过识别用户的 HTTP 请求头（如"},{"id":"782","title":"[微前端] 为何通常在 微前端 应用隔离， 不选择 iframe 方案【热度: 280】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/782","page":"q/工程化-782.html","excerpt":"**关键词**：iframe 隔离方案弊端 在微前端架构中，虽然iframe能提供很好的应用隔离（包括 JavaScript 和 CSS 隔离），确保微前端应用之间不会相互干扰，但一般不把它作为首选方案，原因包括： 1. 性能开销 iframe会创建一个全新的浏览器上下文环境，每个iframe都有自己的文档对象模型（D"},{"id":"781","title":"[微前端] Qiankun 是如何做 JS 隔离的【热度: 228】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/781","page":"q/工程化-781.html","excerpt":"**关键词**：JS 隔离 Qiankun 是一个基于 Single-SPA 的微前端实现库，它提供了比较完善的 JS 隔离能力，确保微前端应用间的独立运行，避免了全局变量污染、样式冲突等问题。Qiankun 实现 JS 隔离的主要机制包括： 1. JS 沙箱 Qiankun 使用 JS 沙箱技术为每个子应用创建一个独"},{"id":"780","title":"[微前端] 微前端架构一般是如何做 JavaScript隔离【热度: 127】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/780","page":"q/工程化-780.html","excerpt":"**关键词**：JS 隔离 在微前端架构中，JavaScript 隔离是核心之一，用以确保各个子应用间代码运行时不互相干扰、变量不冲突，以及能够安全地卸载应用。为了实现这一目标，主要采用以下几种方法： 1. 使用沙箱技术： **iframe**：最直接的隔离方式是将子应用运行在iframe中。这种方式提供了良好的隔离性"},{"id":"777","title":"[Webpack] 配置代码太多，达到数千行，这个时候该如何优化配置代码【热度: 186】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/777","page":"q/工程化-777.html","excerpt":"**关键词**：webpack 配置代码优化 当 Webpack 配置代码变得冗长和难以管理时，可以采取以下方法来优化配置： **配置文件拆分** 将配置文件分成多个部分，每个文件只负责一部分逻辑。比如基础配置、开发环境配置、生产环境配置等。 **使用环境变量** 通过环境变量来区分不同的配置环境，使用 webpack"},{"id":"776","title":"[Webpack] 你用过哪些可以提高效率的插件？【热度: 179】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/776","page":"q/工程化-776.html","excerpt":"**关键词**：webpack 效率提升 webpack-dashboard：可以更友好的展示相关打包信息。 webpack-merge：提取公共配置，减少重复配置代码 speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有"},{"id":"772","title":"在做 eslint 和 commitlint 的时候， 可以使用 --no-verify 跳过， 这种情况下该如何强制卡点【热度: 233】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/772","page":"q/工程化-772.html","excerpt":"**关键词**：commit 与 eslint 规范 跳过eslint和commitlint的钩子，使用--no-verify（对于git commit来说是-n），的确是一个容许开发者在紧急情况下超越钩子检查的手段。然而，这也削弱了代码质量保证的制度。以下是一些方法，可以用来加强这些卡点的靠谱办法： **CI/CD "},{"id":"771","title":"如何做  commit lint【热度: 425】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/771","page":"q/工程化-771.html","excerpt":"**关键词**：commit 规范 Commit lint 是一种实践，用于在代码库中规范化提交信息的格式。这种做法通常有助于团队成员理解代码库的历史记录，以及自动化生成变更日志。下面是实施 Commit lint 的一些基本步骤： **选择 Commit 信息规范：** 首先，你需要选择一个提交信息的规范，最常见的是"},{"id":"770","title":"编写 npm 包的时候，可以办法自动生成 changlog 与自动更新 tag【热度: 455】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/770","page":"q/工程化-770.html","excerpt":"**关键词**：自动化 changelog 在编写 npm 包时，可以使用自动化工具来生成 changelog 和自动更新 tag。以下是你可以使用的一些流行的工具以及它们的基本用法。 **semantic-release**: 这是一个全自动的版本管理和包发布工具。它能根据 commit 信息来自动决定版本号、生成变"},{"id":"769","title":"[Webpack] ts 编写的库， 在使用 webpack 构建的时候， 如何对外提供 d.ts【热度: 224】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/769","page":"q/工程化-769.html","excerpt":"**关键词**：对外提供 d.ts 在 TypeScript (TS) 中使用 Webpack 构建并为库提供 .d.ts 类型声明文件，需要遵循以下步骤： **配置 TypeScript 编译选项**： 在库项目的根目录下创建或编辑 tsconfig.json 文件，确保编译器配置选项如下： declaration:"},{"id":"768","title":"测试前端代码覆盖率一般有什么手段？【热度: 550】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/768","page":"q/工程化-768.html","excerpt":"**关键词**：覆盖率 前端代码的测试覆盖率通常是指衡量在测试过程中有多少代码被执行了的一个指标。测试覆盖率有助于了解测试的全面性，以下是测试前端代码覆盖率常用的手段： **单元测试**： 使用测试框架（例如 Jest, Mocha, Jasmine 等）编写单元测试。 利用测试框架或插件生成覆盖率报告（例如 Ista"},{"id":"767","title":"[Webpack] 如何提取复用代码给多个 entry 使用？【热度: 292】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/767","page":"q/工程化-767.html","excerpt":"**关键词**：代码复用 在 Webpack 中提取源码里被多个入口点复用的代码，例如一个 utils 文件，可以通过配置 optimization.splitChunks 来实现。Webpack 会将这些频繁复用的模块提取出来，打包到一个独立的 chunk 中，使得浏览器可以单独缓存这部分代码，并在多个页面间共享使用"},{"id":"766","title":"[Webpack] 如何将一些通用的依赖打包成一个独立的 bundle【热度: 643】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/766","page":"q/工程化-766.html","excerpt":"**关键词**：依赖打包 在 Webpack 中，将一些通用的依赖，如 React、React DOM、React Router 等库和框架，打包成一个独立的 bundle，通常是为了长期缓存和减少每次部署更新的下载量。这可以通过 \"代码分割\" (code splitting) 和 \"优化\" (optimization"},{"id":"765","title":"[Webpack] output 配置里面， chunkFilename 和 filename 区别是什么？【热度: 210】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/765","page":"q/工程化-765.html","excerpt":"**关键词**：chunkFilename 和 filename 在 Webpack 中的 output 配置对象中，filename 和 chunkFilename 是用来指定输出文件的命名方式的关键属性。它们之间的区别主要涉及到最终生成的 JavaScript 文件的类型。 **filename**: filena"},{"id":"764","title":"[Webpack] 多入口打包共享模块【热度: 337】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/764","page":"q/工程化-764.html","excerpt":"**关键词**：webpack 多入口共享模块 默认情况下，每个入口 chunk 保存了全部其用的模块(modules)。使用 dependOn 选项你可以与另一个入口 chunk 共享模块: app 这个 chunk 就不会包含 react-vendors 拥有的模块了. dependOn 选项的也可以为字符串数组："},{"id":"763","title":"[Webpack] 如何使用 ts 来编写配置文件？【热度: 251】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/763","page":"q/工程化-763.html","excerpt":"**关键词**：webpack ts 编写配置文件 要使用 $1 来编写 webpack 配置，你需要先安装必要的依赖，比如 Typescript 以及其相应的类型声明，类型声明可以从 $1 项目中获取，依赖安装如下所示： 完成依赖安装后便可以开始编写配置文件，示例如下： **webpack.config.ts** 该"},{"id":"762","title":"[Webpack] 内部执行原理【热度: 668】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/762","page":"q/工程化-762.html","excerpt":"**关键词**：webpack 执行原理 这部分可以直接转官网，官网讲得非常好： https://www.webpackjs.com/concepts/under-the-hood/"},{"id":"761","title":"[Webpack] 为何不支持 CMD 模块化【热度: 255】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/761","page":"q/工程化-761.html","excerpt":"**关键词**：webpack 模块化支持 作者总结一下原因： CMD 是国内产品， webpack 是国外产品， 而且 CMD 还没有火起来的时候， 就已经被 ESM 替代了 CMD 是更加懒惰，是依赖就近，延迟执行。也就是说，在模块中需要用到依赖时，才去引入依赖。这和 Webpack 的理念以及模块收集和打包机制不"},{"id":"760","title":"[Webpack] 支持哪些模块化加载？【热度: 154】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/760","page":"q/工程化-760.html","excerpt":"**关键词**：webpack 模块化支持 Webpack 支持以下几种模块化标准： **ESM (ECMAScript Modules)**: 这是 JavaScript ES6 中引入的官方标准模块系统。使用 import 和 export 语句来导入和导出模块。 **CommonJS**: 主要用于 Node.j"},{"id":"758","title":"前端视角 - 如何保证系统稳定性【热度: 566】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/758","page":"q/工程化-758.html","excerpt":"**关键词**：稳定性 前端视角来做稳定性， 本是一个开放性话题，这里没有统一的解法， 作者在此提供几个思路和反向： 静态资源多备份（需要有备份） 首屏请求缓存 请求异常报警 页面崩溃报警 E2E 定时全量跑用例"},{"id":"752","title":"webpack 的主要配置项有哪些【热度: 766】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/752","page":"q/工程化-752.html","excerpt":"**关键词**：webpack 主要配置项 Webpack 是一个现代 JavaScript 应用程序的静态模块打包器。配置文件名通常为 webpack.config.js，它提供了一种配置 Webpack 的方式。下面是一些主要的 Webpack 配置选项： **entry**: 入口起点(entry point)指"},{"id":"750","title":"[webpack] optimize 配置中， 分割代码配置 splitChunks 怎么使用【热度: 546】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/750","page":"q/工程化-750.html","excerpt":"**关键词**：webpack 分割代码 在 webpack 中，splitChunks选项是optimization对象的一个属性，可以用来定义如何分割代码块。默认情况下，webpack 会将所有来自node_modules的模块分割到一个叫做vendors的 chunk 中，并且将共享或来自异步请求的模块分割成不同"},{"id":"749","title":"[webpack] optimize 配置有哪些作用【热度: 280】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/749","page":"q/工程化-749.html","excerpt":"**关键词**：webpack optimize Webpack 的 optimize 选项是在指定 Webpack 配置对象时，用于配置优化选项的一个属性。该属性下包含了一系列用于调整构建输出质量和性能的设置。这里是一些 optimize 属性中可能包含的选项： **splitChunks**：这用于代码分割，可以将"},{"id":"745","title":"[webpack] mode 是做什么用？【热度: 475】","category":"工程化","labels":["工程化","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/745","page":"q/工程化-745.html","excerpt":"**关键词**：webpack mode 在 webpack 中，mode 属性用来指定当前的构建环境是：development、production 或者是 none。设置 mode 可以使用 webpack 内置的函数，默认值为 production。 mode 属性的主要作用是：根据当前的构建环境，启用 webp"},{"id":"744","title":"V8 里面的 JIT 是什么？【热度: 694】","category":"工程化","labels":["工程化","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/744","page":"q/工程化-744.html","excerpt":"**关键词**：V8 JIT 在计算机科学中，JIT 是“Just-In-Time”（即时编译）的缩写，它是一种提高代码执行性能的技术。具体来说，在 V8 引擎（Google Chrome 浏览器和 Node.js 的 JavaScript 引擎）中，JIT 编译器在 JavaScript 代码运行时，将其编译成机器语"},{"id":"742","title":"单元测试中， TDD、BDD、DDD 分别指？【热度: 166】","category":"工程化","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/742","page":"q/工程化-742.html","excerpt":"**关键词**：TDD、BDD、DDD TDD、BDD 和 DDD 这三个缩写在软件开发中分别代表以下概念： **TDD（Test-Driven Development） - 测试驱动开发：** TDD 是一种软件开发过程，其中开发人员首先编写一个小测试用例，然后编写足够的代码来使这个测试通过，最后重构新代码以满足所需"},{"id":"725","title":"husky 作用是啥， 有哪些重要配置【热度: 192】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/725","page":"q/工程化-725.html","excerpt":"**关键词**：husky 作用、husky 配置 Husky 是一个基于 Node 的 Git 钩子管理工具，用于在你的工作流程中强制执行 Git 钩子。Husky 允许你定义脚本，这些脚本会在不同的 Git 生命周期事件触发时自运行，比如在提交、推送或合并前。 使用 Husky 可以： **保证提交质量**：Hus"},{"id":"709","title":"Husky 和 lint-staged 有什么区别？【热度: 387】","category":"工程化","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/709","page":"q/工程化-709.html","excerpt":"**关键词**：Husky 和 lint-staged、git hooks Husky 和 lint-staged 都是与 Git 钩子 (hooks) 配合使用的 Node.js 库，但它们的用途和工作方式有所不同： **Husky**： Husky 是一个 Git 钩子管理器，它允许你触发自定义脚本在 git 事件"},{"id":"703","title":"[webpack] 打包时 hash 码是如何生成的【热度: 167】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/703","page":"q/工程化-703.html","excerpt":"**关键词**：webpack hash 码的生成 Webpack 在打包过程中生成 hash 码主要用于缓存和版本管理。主要有三种类型的 hash 码： hash：是和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改。这意味着任何一个文件的改动都会影响到整体的 hash 值。 chunkh"},{"id":"702","title":"如何从 0 到 1 搭建前端基建【热度: 404】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/702","page":"q/工程化-702.html","excerpt":"**关键词**：前端基建 如何从 0 到 1 搭建前端基建 有一个非常经典的文章， 直接参考即可： $1 这里简单总结一下文章里面的要点 1.什么是基建？ 2.为什么要做前端基建？ 业务复用； 提升研发效率； 规范研发流程； 团队技术提升； 团队的技术影响力； 开源建设； 3.前端基建如何推动落地？ 要合适的同学（资源"},{"id":"701","title":"[React] 为什么 react 组件， 都必须要申明一个 `import React from 'react';`【热度: 115】","category":"工程化","labels":["web框架","工程化","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/701","page":"q/工程化-701.html","excerpt":"**关键词**：babel 编译 react 首先要知道一个事情： **JSX 是无法直接运行在浏览器环境**。 原因 JSX 语法不能直接被浏览器解析和运行，因此需要插件 @babel/plugin-transform-react-jsx 来转换语法，使之能够在浏览器或任何 JavaScript 环境中执行。 所以 "},{"id":"700","title":"babel 核心库有哪些？【热度: 35】","category":"工程化","labels":["工程化","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/700","page":"q/工程化-700.html","excerpt":"**关键词**：babel 核心库 Babel 是一个 JavaScript 编译器，主要用于将 ES6 及以上版本的代码转换为向后兼容的 JavaScript 语法，以便在当前和旧版浏览器或环境中执行。核心的 Babel 库主要包括： **@babel/core**: 这是 Babel 编译器的核心包，提供了 Bab"},{"id":"692","title":"在Babel里，stage0、stage1、stage2 和 stage3 分别代表什么含义？","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/692","page":"q/工程化-692.html","excerpt":"无意中看到别人一个面试问题， 个人感觉问这个问题的面试官， 不是蠢就是坏。 没有任何面试价值， 无法考察候选人水平。 仅仅作为科普类型参考 - 热度为 0 Babel 是一个流行的 JavaScript 编译器，它允许开发者使用新的语言特性，然后将它们编译成可以在当前和低版本的浏览器或环境中运行的代码。 在 Babel"},{"id":"691","title":"Webpack 项目中通过 script 标签引入资源，在项目中如何处理?【热度: 100】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/691","page":"q/工程化-691.html","excerpt":"也是作者无意中看到的一个有意思的问题。 虽然有意思， 但是没有任何价值， 如果说在项目中遇到过的， 而且处理过的同学， 肯定知道怎么回答。 但是压根没有碰到过得， 就算是你工作十年的老油条也是干望着。 所有没有任何面试价值。 故此， 可以当做科普来看看就行。 在使用 Webpack 打包的项目中，通常资源（如 Java"},{"id":"678","title":"为什么 Vite 速度比 Webpack 快？【热度: 382】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/678","page":"q/工程化-678.html","excerpt":"**关键词**：vite 编译速度、vite 速度 与 webpack 速度 1、开发模式的差异 在开发环境中，Webpack 是先打包再启动开发服务器，而 Vite 则是直接启动，然后再按需编译依赖文件。（大家可以启动项目后检查源码 Sources 那里看到） 这意味着，当使用 Webpack 时，所有的模块都需要在"},{"id":"661","title":"web 系统里面， 如何对图片进行优化？【热度: 789】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/661","page":"q/工程化-661.html","excerpt":"**关键词**：图片优化 图片作为网页和移动应用中不可或缺的元素之一，对于用户体验和网站性能都有着重要的影响。 加载速度是用户体验的关键因素之一，而大尺寸的图片会增加网页加载时间，导致用户等待时间过长，从而影响用户的满意度和留存率。通过优化图片，我们可以显著减少页面加载时间，提供更快速流畅的使用体验。 图片优化是提升用"},{"id":"655","title":"[webpack] webpack-dev-server 为何不适用于线上环境？【热度: 88】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/655","page":"q/工程化-655.html","excerpt":"**关键词**：webpack-dev-server 作用 webpack-dev-server并不适用于线上环境的原因有以下几点： 性能问题：webpack-dev-server是一个开发服务器，它将编译后的文件保存在内存中，并提供给浏览器访问。这种方式在开发阶段可以提供快速的编译和热模块替换，但在线上环境中，内存中"},{"id":"654","title":"[webpack] webpack-dev-server 作用是啥？【热度: 387】","category":"工程化","labels":["工程化","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/654","page":"q/工程化-654.html","excerpt":"**关键词**：webpack-dev-server 作用 webpack-dev-server 是一个开发服务器，它提供了一个快速开发的环境，并且配合Webpack使用。它的作用主要有以下几个方面： **自动编译和打包**：webpack-dev-server 可以监听源文件的变化，当文件发生改动时，它会自动重新编译"},{"id":"652","title":"vite 和  webpack 在热更新上有啥区别？【热度: 530】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/652","page":"q/工程化-652.html","excerpt":"**关键词**：热更新区别 Vite 和 Webpack 在热更新上有一些区别： 模块级别的热更新：Vite 使用浏览器原生的 ES 模块系统，可以实现模块级别的热更新，即只更新修改的模块，而不需要刷新整个页面。这样可以提供更快的开发迭代速度。而在 Webpack 中，热更新是基于文件级别的，需要重新构建并刷新整个页面"},{"id":"651","title":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？【热度: 129】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/651","page":"q/工程化-651.html","excerpt":"**关键词**：esbuild 和 rollup 区别 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们在 Vite 中担负着不同的角色和任务。 esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代"},{"id":"650","title":"vite 编译器有啥特点？【热度: 237】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/650","page":"q/工程化-650.html","excerpt":"**关键词**：vite 编译器特点 Vite 是一个基于现代浏览器原生 ES 模块导入功能的开发工具和构建系统。与传统的打包工具相比，Vite 具有以下几个特点： 快速冷启动：Vite 采用了一种新的开发服务器，利用浏览器原生的 ES 模块导入功能，无需提前构建和打包，可以实现快速的冷启动，并在浏览器中按需编译和加载"},{"id":"649","title":"vite 编译器的组成部分【热度: 335】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/649","page":"q/工程化-649.html","excerpt":"**关键词**：vite 编译器组成部分 Vite 编译器的主要组成部分包括： esbuild：一个快速的 JavaScript 打包器，用于在开发阶段进行实时编译。esbuild 提供了快速的冷启动和热模块替换功能，能够极大地加快开发环境的构建速度。 Rollup：一个强大的 JavaScript 模块打包器，在生产"},{"id":"648","title":"vite 涉及到了哪些底层原理？【热度: 510】","category":"工程化","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/648","page":"q/工程化-648.html","excerpt":"**关键词**：vite 原理 Vite 涉及到以下几个底层原理： ES 模块：Vite 使用了 ES 模块来管理和加载模块。ES 模块是 JavaScript 的标准模块系统，相比于传统的 CommonJS 或 AMD，ES 模块具有更好的静态分析能力和更高的性能。Vite 通过使用浏览器原生的 ES 模块加载器，可"},{"id":"638","title":"页面加载速度提升（性能优化）应该从哪些方向来思考？【热度: 1,099】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/638","page":"q/工程化-638.html","excerpt":"**关键词**：性能提升、加载优化 页面加载优化 「页面加载链路+流程优化+协作方」的多级分类思考 页面启动 service worker 缓存重要的静态资源 页面保活 资源加载 网络连接 NDS 减少 NDS 解析 NDA 预解析 HTTP 开启 HTTP2 多路复用 优化核心请求链路 HTML 加载 内容优化 代码"},{"id":"636","title":"对比一下 pnpm、npm、yarn 特性【热度: 399】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/636","page":"q/工程化-636.html","excerpt":"**关键词**：pnpm、npm、yarn 特性对比 | 功能 | pnpm | Yarn | npm | |--------------------------------|------------------------------------------------------------------------"},{"id":"630","title":"[低代码] 代码平台一般渲染是如何设计的？【热度: 399】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/630","page":"q/工程化-630.html","excerpt":"**关键词**：代码平台渲染设计 **渲染设计** 渲染核心本质就是： [schema] + [组件] = [页面] 整体架构如下 **协议层**：基于《低代码引擎搭建协议规范》 产出的 Schema 作为我们的规范协议。 **能力层**：提供组件、区块、页面等渲染所需的核心能力，包括 Props 解析、样式注入、条件"},{"id":"629","title":"[低代码] 代码平台一般底层协议是怎么设计的【热度: 263】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/629","page":"q/工程化-629.html","excerpt":"**关键词**：代码平台协议设计 低代码引擎体系基于三份协议来构建: $1 $1 $1 **参考文档** https://lowcode-engine.cn/site/docs/guide/design/specs"},{"id":"628","title":"[低代码] 代码平台一般架构设计如何【热度: 517】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/628","page":"q/工程化-628.html","excerpt":"**关键词**：代码平台 代码平台 - 架构综述 **分层架构描述** 自下而上分别是协议 - 引擎 - 生态 - 平台。 底层协议栈定义的是标准，标准的统一让上层产物的互通成为可能。 引擎是对协议的实现，同时通过能力的输出，向上支撑生态开放体系，提供各种生态扩展能力。 生态就好理解了，是基于引擎核心能力上扩展出来的，"},{"id":"625","title":"[Webpack] Webpack vs Vite的核心差异【热度: 820】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/625","page":"q/工程化-625.html","excerpt":"**关键词**：Webpack vs Vite 差异 **构建速度**: **Webpack**: Webpack的构建速度相对较慢，尤其在大型项目中，因为它需要分析整个依赖图，进行多次文件扫描和转译。 **Vite**: Vite以开发模式下的极速构建著称。它利用ES模块的特性，只构建正在编辑的文件，而不是整个项目。"},{"id":"623","title":"对 babel 的理解？【热度: 551】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/623","page":"q/工程化-623.html","excerpt":"**关键词**：babel 作用、为何要使用 babel Babel 是一个非常流行的 JavaScript 编译器，用于将最新版本的 ECMAScript 代码转换为向后兼容的 JavaScript 代码，以便在旧版浏览器或环境中运行。 以下是对 Babel 的理解： 语法转换：Babel 可以将使用了最新 ECMA"},{"id":"622","title":"[Webpack] 有哪些优化项目的手段？【热度: 1,163】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/622","page":"q/工程化-622.html","excerpt":"**关键词**：打包优化 围绕 webpack 做性能优化，分为两个方面：构建时间优化、构建产物优化 <!-- toc --> 优化构建时间 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 <!-- tocstop --> 构建时间优化 缩小范围 我们在使用 loa"},{"id":"612","title":"[Webpack] 全面了解 tree shaking【热度: 790】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/612","page":"q/工程化-612.html","excerpt":"webpack 如何做 tree shaking Webpack通过tree shaking技术实现了JavaScript代码的优化和精简。Tree shaking是指通过静态代码分析，识别和移除未被使用的代码（被称为\"dead code\"），从而减小最终打包后的文件大小。 下面是Webpack如何进行tree sha"},{"id":"611","title":"[Webpack] 通过 babel-loader 来编译 tsx 文件， 应该如何配置呢？【热度: 221】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/611","page":"q/工程化-611.html","excerpt":"如果你想使用 babel-loader 来编译 TypeScript 文件（.tsx），你需要在 babel.config.js 和 webpack.config.js 两个文件中进行相应的配置。 首先，在 babel.config.js 文件中，你需要添加 @babel/preset-typescript 预设，以便"},{"id":"610","title":"[Webpack] 如何打包运行时 chunk ， 且在项目工程中， 如何去加载这个运行时 chunk ?【热度: 421】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/610","page":"q/工程化-610.html","excerpt":"Webpack打包运行时chunk的方式可以通过optimization.runtimeChunk选项来配置。下面是一个示例的配置： 上述配置中，通过设置optimization.runtimeChunk为'single'，将会把所有的webpack运行时代码打包为一个单独的chunk。 在项目工程中加载运行时chun"},{"id":"609","title":"[Webpack] 如何配置多入口应用， 且区分公共依赖的？【热度: 124】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/609","page":"q/工程化-609.html","excerpt":"在Webpack中配置多入口应用并区分公共依赖，可以通过以下步骤进行配置： 在Webpack配置文件中，使用entry属性指定多个入口文件，并为每个入口文件命名一个唯一的键名。例如： 上面的配置指定了两个入口文件app1.js和app2.js，并为它们分别指定了键名app1和app2。 使用SplitChunks插件进"},{"id":"608","title":"[Webpack] 有哪些基础概念【热度: 595】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/608","page":"q/工程化-608.html","excerpt":"**关键词**：webpack 作用、webpack 概念 Webpack是一个现代的JavaScript模块打包工具，它的核心概念包括以下几个方面： 入口（Entry）：指定Webpack开始构建依赖图谱的起点。可以通过配置文件中的entry属性来指定入口文件，也可以指定多个入口文件。 输出（Output）：指定We"},{"id":"607","title":"[Webpack] 为什么选择 webpack？【热度: 515】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/607","page":"q/工程化-607.html","excerpt":"**关键词**：webpack 作用 **为什么选择 webpack** 想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。 在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因"},{"id":"606","title":"[Webpack] chunk 是什么概念，介绍一下？【热度: 1,100】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/606","page":"q/工程化-606.html","excerpt":"在Webpack中，Chunk（代码块）是指Webpack在构建过程中生成的一个或多个独立的文件，它包含了一组相关的模块。每个Chunk都有一个唯一的标识符，可以通过该标识符来访问和加载对应的Chunk。 Webpack根据指定的入口文件和依赖关系图来确定需要生成哪些Chunk。入口文件是Webpack构建的起点，而依"},{"id":"595","title":"[Vue] 响应式为何要从 Object.defineProperty 改为 proxy?【热度: 352】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/595","page":"q/工程化-595.html","excerpt":"**关键词**：vue Object.defineProperty、vue proxy 使用 Vue 在早期版本中使用了 Object.defineProperty 来实现响应式系统。但是，在 Object.defineProperty 中存在一些限制和局限性，导致在某些场景下无法完全满足需求。因此，Vue 在最新的版"},{"id":"594","title":"在你的项目中， 使用过哪些 webpack plugin, 说一下他们的作用【热度: 361】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/594","page":"q/工程化-594.html","excerpt":"下表列出了常见的 Webpack 插件及其作用： | 插件名称 | 作用 | | ------------------------------------------------ | --------------------------------------------------------------------"},{"id":"593","title":"在你的项目中， 使用过哪些 webpack loader, 说一下他们的作用【热度: 361】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/593","page":"q/工程化-593.html","excerpt":"| Loader 名称 | 作用 | | --------------------------- | -------------------------------------------------------------------------------------------------------------"},{"id":"592","title":"在 webpack 中，通常用于 css 提取的工具是什么？【热度: 269】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/592","page":"q/工程化-592.html","excerpt":"**关键词**：mini-css-extract-plugin作用、mini-css-extract-plugin使用 **概念** 在 webpack 中，通常使用 mini-css-extract-plugin 来提取 CSS。它是一个独立的插件，可以将 CSS 从 JavaScript 文件中提取出来，生成独立的"},{"id":"578","title":"将静态资源缓存在本地的方式有哪些？【热度: 584】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/578","page":"q/工程化-578.html","excerpt":"**关键词**：静态资源缓存本地 **浏览器可以使用以下几种方式将前端静态资源缓存在本地**： HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、max-age"},{"id":"577","title":"SPA首屏加载速度慢的怎么解决【热度: 868】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/577","page":"q/工程化-577.html","excerpt":"**关键词**：SPA首屏、加快首屏加载 **统计首屏时间** 可以参考下面的文档： https://github.com/pro-collection/interview-question/issues/515 https://github.com/pro-collection/interview-question/"},{"id":"558","title":"git 中回滚代码有哪些操作？【热度: 237】","category":"工程化","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/558","page":"q/工程化-558.html","excerpt":"**关键词**：git 回滚代码、git reset 操作、git revert 操作 在 Git 中，可以使用以下几种操作来回滚代码： git revert：使用 git revert 命令可以创建一个新的提交来撤销之前的提交。它会创建一个新的提交，恢复之前的更改，从而回滚代码。这种方式比较安全，不会改变历史提交记录"},{"id":"557","title":"git reset 作用是啥，有哪些操作？【热度: 275】","category":"工程化","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/557","page":"q/工程化-557.html","excerpt":"**关键词**：git reset 作用、git reset 操作 git reset 是一个用于撤销提交的命令，可以将当前分支指向某个特定的提交，同时可以选择是否修改工作区和暂存区。 常见的 git reset 操作有以下三种： git reset --soft <commit>：将当前分支的 HEAD 指向指定的 "},{"id":"556","title":"为什么现代前端应用需要打包工具进行打包编译？【热度: 588】","category":"工程化","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/556","page":"q/工程化-556.html","excerpt":"**关键词**：打包构建必要性 现代前端应用需要打包工具进行打包编译的主要原因有以下几点： 模块化管理：现代前端应用通常采用模块化的开发方式，将代码划分为多个模块，每个模块具有独立的功能和依赖关系。打包工具可以将这些模块进行分析，将它们打包成一个或多个静态文件，方便管理和维护。 解决浏览器兼容性问题：不同的浏览器对于 "},{"id":"547","title":"前端架构和前端工程化有什么区别？","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/547","page":"q/工程化-547.html","excerpt":"先说说对这两个概念的看法： $1 $1 **区别** 前端架构和前端工程化是两个不同的概念，但它们之间有一些相互关联的特点。 前端架构是指在前端开发中，对整个前端应用程序的组织结构、模块划分、框架选择等方面的设计和规划。前端架构的目标是为了提高代码的可维护性、可扩展性和可重用性，以及优化前端应用程序的性能和用户体验。常"},{"id":"546","title":"如何理解前端工程化？","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/546","page":"q/工程化-546.html","excerpt":"前端工程化是指将前端开发过程中的各种工具、技术和流程进行规范化和自动化，以提高前端开发效率、代码质量和团队协作能力的一种方法。前端工程化主要涵盖以下几个方面： 代码管理：使用版本控制系统（如Git）对前端项目进行代码管理，实现代码的版本控制、协作开发和代码回滚等功能。 代码规范：制定和遵循统一的前端代码规范，包括缩进、"},{"id":"545","title":"如何理解前端架构？","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/545","page":"q/工程化-545.html","excerpt":"前端架构是指在开发前端应用程序时，为了提高开发效率、代码可维护性和可扩展性，将前端代码组织和设计的一种架构体系。它涵盖了前端项目的整体结构、代码组织方式、技术选型、模块化开发、数据管理、状态管理、网络请求、路由管理等方面的规划和设计。 前端架构的目标是使前端开发更加规范、高效和可持续。良好的前端架构可以帮助团队成员更好"},{"id":"543","title":"前端基建设计到哪些方面【热度: 782】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/543","page":"q/工程化-543.html","excerpt":"**关键词**：前端工程化建设、前端基建 前端基建是指在前端开发过程中，为提高开发效率、代码质量和团队协作而构建的一些基础设施和工具。下面是前端基建可以做的一些事情： 脚手架工具 开发和维护一个通用的脚手架工具，可以帮助团队快速初始化项目结构、配置构建工具、集成常用的开发依赖等。 组件库 开发和维护一个内部的组件库，包"},{"id":"523","title":"webpack tree-shaking 在什么情况下会失效？【热度: 171】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/523","page":"q/工程化-523.html","excerpt":"**关键词**：tree shaking 失效 在以下情况下，webpack 的 tree-shaking 可能会失效： 使用了 sideEffects 属性：在 webpack 的配置文件中，如果设置了 sideEffects: true，则 webpack 会假设所有模块都有副作用，因此不会进行 tree-shak"},{"id":"522","title":"前端模块化的演进过程【热度: 798】","category":"工程化","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/522","page":"q/工程化-522.html","excerpt":"**关键词**：前端模块化演进 1 函数作为块 最开始的时候，是以函数为块来编程，因为函数有自己的作用域，相对比较独立 这种形式中，add和add1都是定义在全局作用域中的，会造成很多问题： 污染全局作用域，容易造成命名冲突 定义在全局作用域，数据不安全 2 namespace模式 使用对象作为独立块编程 优点：减少了"},{"id":"516","title":"[性能] 常见性能指标获取方式？【热度: 954】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/516","page":"q/工程化-516.html","excerpt":"**关键词**：web性能指标获取 常见性能指标获取方式 相关性能指标问题， 可以看这个文章：$1 **指标所反映的用户体验** 下表概述了我们的性能指标如何对应到我们的问题之上： **开始了吗？** 首次绘制、首次内容绘制 First Paint (FP) / First Contentful Paint (FCP)"},{"id":"515","title":"[性能] 衡量页面性能的指标有哪些？【热度: 1,045】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/515","page":"q/工程化-515.html","excerpt":"**关键词**：web性能指标 性能的核心问题 什么样的性能指标最能度量人的感觉？ 怎样才能从我们的真实用户中获取这些指标？ 如何用我们所获取的指标来确定一个页面表现得是否「快」？ 当我们得知用户所感知的真实性能表现后，我们应该如何做才能避免重蹈覆辙，并在未来提高性能表现？ 以用户为中心的性能指标 **开始了吗？** "},{"id":"502","title":"浏览器本身是不支持模块化的, webpack 是如何通过文件打包，让浏览器可以读取到前端各个模块的代码的？【热度: 1,153】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/502","page":"q/工程化-502.html","excerpt":"**关键词**：webpack模块化、浏览器模块化支持 浏览器本身不支持模块化的特性，无法直接读取和执行模块化的代码。Webpack通过使用一种称为\"模块化打包\"的方式，将模块化的代码转换为浏览器可以执行的形式。 Webpack使用了一个称为\"模块系统\"的机制，通过对模块的依赖关系进行分析，将所有依赖的模块打包为一个或"},{"id":"482","title":"如何搭建一套灰度系统？【热度: 1,226】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/482","page":"q/工程化-482.html","excerpt":"**关键词**：灰度上线 这个是一个非常复杂的话题， 没法直接给出答案， 进提供一些实现的思路： **什么是灰度** 灰度系统可以把流量划分成多份，一份走新版本代码，一份走老版本代码。 而且灰度系统支持设置流量的比例，比如可以把走新版本代码的流程设置为 5%，没啥问题再放到 10%，50%，最后放到 100% 全量。 "},{"id":"467","title":"如何理解研发流程和研发效率，如何保障研发效率","category":"工程化","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/467","page":"q/工程化-467.html","excerpt":"保障研发效率 研发流程指的是从需求调研、设计、开发、测试、发布、维护等一系列环节组成的整个研发过程。它是实现软件产品的必经之路，可以帮助团队规范化、标准化研发流程，提高研发效率、降低研发成本、提高产品质量和用户满意度。 研发效率指的是在研发流程中，完成同样的工作所需要的时间和成本，也就是研发效率越高，就可以在同样的时间"},{"id":"394","title":"[webpack] 提高 webpack 的构建速度的办法有哪些【热度: 1,208】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/394","page":"q/工程化-394.html","excerpt":"**关键词**：webpack 构建、webpack 构建优化、webpack 构建速度 以下是一些可以提高Webpack构建速度的办法： 使用更快的构建工具：升级Webpack到最新版本，因为每个新版本通常都会带来性能改进和优化。 减少文件的数量：通过代码拆分和按需加载等技术，将代码拆分成更小的模块，减少每次构建需要"},{"id":"390","title":"[Webpack] webpack5 Module Federation 了解多少","category":"工程化","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/390","page":"q/工程化-390.html","excerpt":"概念 Webpack 5 的 Module Federation 是一项功能强大的功能，它允许将 JavaScript 应用程序拆分成独立的模块，并在不同的 Webpack 构建中共享这些模块。它解决了多个独立应用程序之间共享代码的问题，使得实现微前端架构变得更加容易。 Module Federation 可以将一个应"},{"id":"384","title":"source map 了解多少【热度: 396】","category":"工程化","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/384","page":"q/工程化-384.html","excerpt":"**关键词**：source map 原理 Source Map（源映射）作用 Source Map（源映射）是一种文件，用于将压缩、混淆或编译后的代码映射回原始的源代码，以便在调试过程中能够直接查看和调试源代码。它提供了压缩文件和源文件之间的映射关系，包括每个压缩文件中的代码位置、原始文件的路径和行号等信息。 Sou"},{"id":"379","title":"如何定制前端项目代码规范【热度: 1,155】","category":"工程化","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/379","page":"q/工程化-379.html","excerpt":"**关键词**：定制前端代码规范 当按照上述步骤定制前端代码规范时，可以按照以下详细步骤执行： 选择代码规范工具： 研究可用的代码规范工具，如 ESLint、Prettier 等。 比较各工具的功能、灵活性和社区支持，并选择最适合你团队和项目的工具。 定义规范： 针对项目的需求和团队的编码风格，制定代码规范的具体规则和"},{"id":"377","title":"如何编写一个 babel 插件【热度: 1,062】","category":"工程化","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/377","page":"q/工程化-377.html","excerpt":"**关键词**：babel插件、babel插件api、babel插件代码示例 编写一个 babel 插件的基本步骤 编写一个 Babel 插件可以让你自定义转换、分析或操作 JavaScript 代码。下面是编写 Babel 插件的基本步骤： 安装 Babel：首先，确保你已经安装了 Babel 的相关工具和依赖。可以"},{"id":"376","title":"SSR 了解多少【热度: 486】","category":"工程化","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/376","page":"q/工程化-376.html","excerpt":"**关键词**：SSR 原理、SSR 实现 SSR 原理是啥 服务器端渲染（Server-Side Rendering，SSR）是一种前端渲染方式，其核心原理是在服务器端将动态生成的 HTML 页面发送给客户端，以便客户端在接收到页面时直接渲染显示，而不是在客户端使用 JavaScript 动态生成页面。 核心原理如下"},{"id":"373","title":"Babel Polyfill 了解多少【热度: 200】","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/373","page":"q/工程化-373.html","excerpt":"**关键词**：Babel Polyfill 原理、Babel Polyfill 作用、Babel Polyfill 使用、Babel Polyfill 按需加载 Babel Polyfill 作用是啥 Babel Polyfill 的作用是在旧版本浏览器中提供对新的JavaScript特性和API的支持。当使用Bab"},{"id":"372","title":"幽灵依赖 是什么","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/372","page":"q/工程化-372.html","excerpt":"幽灵依赖 是什么 \"幽灵依赖\"（Ghost Dependency）是指在项目的node_modules目录中存在但未被实际使用的依赖包。 在使用 npm 或者其他包管理工具安装依赖包时，有时会出现安装了一些不需要的或者不正确的依赖包的情况。这些依赖包在项目中没有被显式地引用或使用，但仍然存在于node_modules目"},{"id":"357","title":"如何将JavaScript代码解析成抽象语法树(AST)【热度: 1,169】","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/357","page":"q/工程化-357.html","excerpt":"**关键词**：解析为 AST、抽象语法树、AST 词法分析、AST 语法分析 如何将JavaScript代码解析成抽象语法树 要将JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST），你可以使用工具或库来实现。以下是几种常用的方法： Esprima: Esprima 是一个流行"},{"id":"341","title":"npm script 生命周期有哪些?【热度: 519】","category":"工程化","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/341","page":"q/工程化-341.html","excerpt":"**关键词**：npm 生命周期、script 生命周期 安装和卸载 | 脚本名称 | 阶段 | 描述 | 执行时机 | |-----------------|--------------|-----------------------------------------------------------------"},{"id":"316","title":"npm 包管理了解多少？【热度: 1,321】","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/316","page":"q/工程化-316.html","excerpt":"**关键词**：npm 依赖管理、npm 包管理、npm 缓存 **npm 是如何进行依赖管理的？** npm 是通过 package.json 文件来进行依赖管理的。当在项目中使用第三方库时，我们可以在 package.json 中添加对应的依赖项及版本号，npm 会根据 package.json 中的依赖关系，自动"},{"id":"315","title":"npx 了解多少？【热度: 290】","category":"工程化","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/315","page":"q/工程化-315.html","excerpt":"**关键词**：npx 原理、npx 作用、npx 执行 **npx 是什么** npx是一个由Node.js官方提供的用于快速执行npm包中的可执行文件的工具。它可以帮助我们在不全局安装某些包的情况下，直接运行该包提供的命令行工具。npx会在执行时，检查本地项目中是否安装了对应的依赖，如果没有安装则会自动下载安装，并"},{"id":"314","title":"npm lock 文件了解多少？【热度: 258】","category":"工程化","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/314","page":"q/工程化-314.html","excerpt":"**关键词**：npm lock 原理、npm lock 实现、npm lock 作用 **作用** npm lock 文件（如 package-lock.json 或 yarn.lock）的作用是确保在不同机器上或在不同时间安装相同的依赖包时，获得相同的版本，以避免由于版本不一致而产生的问题。在安装依赖包时，npm "},{"id":"313","title":"语义化版本 SemVer（Semantic Versioning）了解多少？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/313","page":"q/工程化-313.html","excerpt":"Semantic Versioning（语义化版本）是一种为软件组件定义版本号的规范。它使用“major.minor.patch”的格式来表示版本号。其中： Major（主版本号）：当你做了不兼容的 API 修改时，你需要更新主版本号。 Minor（次版本号）：当你做了向下兼容的功能性新增时，你需要更新次版本号。 Pa"},{"id":"312","title":"npm script 了解多少？【热度: 364】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/312","page":"q/工程化-312.html","excerpt":"什么是 npm script npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。 命令行下使用npm run"},{"id":"311","title":"package.json 配置了解多少？【热度: 747】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/311","page":"q/工程化-311.html","excerpt":"package.json常见配置分类： 描述配置 文件配置 脚本配置 依赖配置 发布配置 系统配置 第三方配置 package.json 作用：存储一切与项目相关的配置，例如项目基本信息、外界访问项目的方式、项目内置脚本、项目依赖等。 描述配置 主要是项目的基本信息，包括名称，版本，描述，仓库，作者等，部分会展示在 n"},{"id":"309","title":"[webpack] module、chunk 、bundle 的区别【热度: 136】","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/309","page":"q/工程化-309.html","excerpt":"首先上图： 手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module 当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作 webpack 处理好 "},{"id":"289","title":"[webpack] 分包的方式有哪些？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/289","page":"q/工程化-289.html","excerpt":"在 Webpack 中，可以通过以下方式进行分包 通过 entry 属性指定入口文件，在打包时，Webpack 会按照入口文件生成一个 chunk，每个 chunk 包含了一组代码块，最终生成一个或多个 bundle。 通过 SplitChunksPlugin 插件对公共依赖进行分割。该插件会把公共依赖提取出来，形成一"},{"id":"288","title":"[webpack] externals 作用是啥？","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/288","page":"q/工程化-288.html","excerpt":"webpack 中的 externals 配置项用于指定在打包时需要排除掉的模块，这些模块会被视为外部依赖，即不会被打包进最终的输出文件中，而是通过其他方式引入。 使用 externals 配置项可以使得打包后的代码文件更小，同时也可以在运行时从外部获取依赖，例如通过 CDN、全局变量或者通过 require 的方式等"},{"id":"287","title":"[webpack] 异步加载原理是啥","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/287","page":"q/工程化-287.html","excerpt":"Webpack 异步加载模块的方式主要有以下几种 使用动态 import: 使用 ES6 的 import() 语法，动态加载模块。 使用 require.ensure: 异步加载模块并将其放置到指定的 chunk 中。 使用 bundle-loader: 将模块放置到一个单独的文件中，按需加载。 使用webpack的"},{"id":"284","title":"[webpack] 核心库 - tapable 的设计思路与实现原理是什么？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/284","page":"q/工程化-284.html","excerpt":"Webpack Tapable 的设计思路 Webpack Tapable 的设计思路主要基于观察者模式（Observer Pattern）和发布-订阅模式（Publish-Subscribe Pattern），用于解耦各个插件之间的依赖关系，让插件能够独立作用于特定的钩子（Hook），从而实现可扩展性和灵活性。 具体"},{"id":"283","title":"[webpack] 构建流程是怎么样的？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/283","page":"q/工程化-283.html","excerpt":"webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好 从启动到结束会依次执行以下三大步骤： 初始化流程：从配置文件和 Shell 语句中读取与合并参数，"},{"id":"270","title":"小程序的大概原理?","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/270","page":"q/工程化-270.html","excerpt":"具体流程可以看下面这个图： 要了解小程序架构原理， 要从以下几个方面入手探索 宿主环境 执行环境 小程序整体架构 运行机制 更新机制 数据通信机制 登录机制 性能方向问题 JSCore 具体内容可以参考文档: https://juejin.cn/post/6976805521407868958"},{"id":"267","title":"[Webpack] webpack热更新原理是什么？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/267","page":"q/工程化-267.html","excerpt":"Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：**节省宝贵的开发时间、提升开发体验**。 刷新我们一般分为两种： 一种是页面刷新，不保留页面状态，就是简单粗暴，直接window.location.reload()。 另一种是基于W"},{"id":"253","title":"如果用户说 web 应用感觉很反应慢或者卡顿，该如何排查？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/253","page":"q/工程化-253.html","excerpt":"如果用户觉得 web 应用反应卡顿， 主要从哪几个方面来排查？ 加载慢 资源下载慢 首屏并发请求资源过多 首屏接口慢 首屏对应的 JS 执行慢 首屏渲染慢 首屏加载静态资源过大 ....... 执行过程慢 接口慢 long tasks 太多, 阻塞 JS 执行 内存泄漏 重绘重排 过多 关键节点没有加 节流防抖 ..."},{"id":"249","title":"[webpack] 如果解决重复引用 node_modules 里面的不同版本的包(包重复问题)","category":"工程化","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/249","page":"q/工程化-249.html","excerpt":"解决重复引用 node_modules 中不同版本的包的问题，可以通过以下几种方式： **1.使用 npm 或者 yarn 的工具进行依赖的版本控制，尽量避免引用不同版本的同一个依赖库**。在 package.json 文件中使用 \"^\"、\"~\"、\">=\" 等方式指定依赖版本，可以有效减少不同版本的包冲突问题。 **2"},{"id":"247","title":"[webpack] 是如何实现 treeShaking 的","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/247","page":"q/工程化-247.html","excerpt":"webpack实现tree shaking的原理是基于ES6模块化语法的静态特性。 在编译阶段，Webpack会根据模块的依赖关系，通过AST（抽象语法树）进行静态分析，识别出那些代码块（函数、变量、对象等）被引用并且使用了。然后将这些代码块打包输出到最终的打包文件中。在这个过程中，Webpack会自动将未被引用的代码"},{"id":"246","title":"[webpack] loader 和 plugin 有啥区别","category":"工程化","labels":["工程化","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/246","page":"q/工程化-246.html","excerpt":"在Webpack中，Loader和Plugin是两个不同的概念，它们的作用和使用方式也有所不同。 Loader用于对源代码文件进行转换和处理，而Plugin用于对Webpack的编译过程进行扩展和增强。 **Loader** Loader是Webpack中的一个核心概念，它用于处理源代码文件，将它们转换成Webpack"},{"id":"243","title":"[webpack] webpack 是如何给 web 应用注入环境变量的， 原理是啥","category":"工程化","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/243","page":"q/工程化-243.html","excerpt":"Webpack 可以通过 DefinePlugin 插件给 web 应用注入环境变量。该插件会在编译过程中替换掉代码中指定的变量，以实现在运行时替换成环境变量的值。 在 webpack 的配置文件中，需要先引入该插件，然后将需要注入的环境变量通过该插件进行配置。例如： 上述配置中，定义了两个需要注入的变量，分别是 pr"},{"id":"239","title":"如何在前端团队快速落地代码规范","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/239","page":"q/工程化-239.html","excerpt":"// todo 待整理 https://juejin.cn/post/7033210664844066853 https://juejin.cn/post/7007419705543622669 https://juejin.cn/post/7167707693333872647 https://juejin.cn/p"},{"id":"236","title":"babel 的工作流程是如何的？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/236","page":"q/工程化-236.html","excerpt":"Babel 是一个 JavaScript 编译器，它的主要功能是将新版本的 JavaScript 代码转换成向后兼容的代码。Babel 的工作流程可以简单概括为以下几个步骤： 解析：将 JavaScript 代码解析成 AST（抽象语法树）。 转换：对 AST 进行遍历，进行代码转换。 生成：将转换后的 AST 生成 "},{"id":"235","title":"[webpack] 什么情况下 webpack treeShaking 会失效？","category":"工程化","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/235","page":"q/工程化-235.html","excerpt":"以下是一些可能导致 webpack tree shaking 失效的情况 代码中使用了动态引入（Dynamic Imports）的语法，这种情况下，webpack 无法确定哪些代码会被使用，因此不会进行 tree shaking。 代码使用了函数式编程的方式，比如使用了 map、filter、reduce 等高阶函数，"},{"id":"231","title":"不用使用 vue-cli ，如何创建一个完整的 vue 工程？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/231","page":"q/工程化-231.html","excerpt":"这个一个较为复杂和庞大的话题， 不能称之为问题， 只能说它是一个话题。 主要涉及到的话题如下： vue 工程初始化 测试集成 UI 库绑定、基础组件使用 开发流程 代码规范（甚至包含 commit 规范） 多人协作与工作流 构建问题 上线流程 线上日志与用户反馈问题排查 性能保证"},{"id":"207","title":"使用 虚拟DOM 一定会比直接操作 真实 DOM 快吗？","category":"工程化","labels":["工程化","百度"],"url":"https://github.com/pro-collection/interview-question/issues/207","page":"q/工程化-207.html","excerpt":"大家惯有的思维模式下，我们普遍的认为，虚拟DOM一定会比原生DOM要快的多。 但实际上并不是这样。 **仅从React的角度来说 : React的官网可从来都没有说过虚拟DOM会比原生操作DOM更快。** 虚拟DOM和原生操作DOM谁更快这个问题。如果要我来回答的话，**一定是原生DOM比虚拟DOM更快性能更好。** "},{"id":"204","title":"AMD 和 CMD  模块化有和区别？","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/204","page":"q/工程化-204.html","excerpt":"AMD（Asynchronous Module Definition）和CMD（Common Module Definition）都是JavaScript模块化方案。它们的主要区别在于对依赖的处理方式上不同。 AMD是在require.js推广过程中诞生的，它的特点是提前执行，强调依赖前置。也就是说，在定义模块时就需要"},{"id":"203","title":"前端模块化发展历程？","category":"工程化","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/203","page":"q/工程化-203.html","excerpt":"前端模块化是指在前端开发中，通过模块化的方式组织代码，将代码按照一定规则分割成不同的模块，便于管理和维护。 前端模块化的发展历程如下： 早期，前端开发采用的是全局变量的方式进行开发，即将所有代码都放在一个文件中，通过全局变量进行交互。这种方式的问题在于，代码量较大，代码耦合度高，不易维护。 后来，前端开发采用了命名空间"},{"id":"187","title":"前端单页应用 History 路由模式， 需要如何配置 nginx？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/187","page":"q/工程化-187.html","excerpt":"前端单页应用使用 History 路由模式，需要将路由的控制交给前端，而不是后端处理，因此需要配置 nginx 让其将所有请求都指向 index.html 页面，让前端来处理路由。 具体配置可以参考以下 nginx 配置： 以上配置中，try_files 指令会尝试将请求映射到对应的文件，如果找不到，则会将请求转发到 "},{"id":"145","title":"实现 JS 沙盒的方式有哪些？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/145","page":"q/工程化-145.html","excerpt":"微前端已经成为前端领域比较火爆的话题，在技术方面，微前端有一个始终绕不过去的话题就是前端沙箱 什么是沙箱 Sandboxie(又叫沙箱、沙盘)即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响"},{"id":"141","title":"如何组织 monorepo 工程？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/141","page":"q/工程化-141.html","excerpt":"参考文档： $1 $1 $1 Comments / Answers --- **yanlele** at 2023-03-29T08:24:59Z 补充：https://juejin.cn/post/6932046455733485575"},{"id":"140","title":"pnpm 了解多少？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/140","page":"q/工程化-140.html","excerpt":"pnpm，英文里面的意思叫做 performant npm ，意味“高性能的 npm”，官网地址可以参考 $1 pnpm 相比较于 yarn/npm 这两个常用的包管理工具在性能上也有了极大的提升，根据目前官方提供的 $1 数据可以看出在一些综合场景下比 npm/yarn 快了大概两倍： 在这篇文章中，将会介绍一些关于"},{"id":"139","title":"pnpm 和 npm 的区别？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/139","page":"q/工程化-139.html","excerpt":"pnpm 和 npm 是两个不同的 JavaScript 包管理工具，它们有以下区别： **包的存储方式：**npm 将每个包都下载到项目的 node_modules 目录中，而 pnpm 会在全局安装一个存储库，并在项目中创建一个符号链接到该存储库中的每个包。 **空间占用：** 由于 pnpm 使用符号链接，它的空"},{"id":"137","title":"【性能】以用户为中心的前端性能指标有哪些？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/137","page":"q/工程化-137.html","excerpt":"$1"},{"id":"136","title":"如何分析页面加载慢？","category":"工程化","labels":["工程化"],"url":"https://github.com/pro-collection/interview-question/issues/136","page":"q/工程化-136.html","excerpt":"$1"},{"id":"1117","title":"decodeURI 和 decodeURIComponent 有何区别【热度: 230】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1117","page":"q/京东-1117.html","excerpt":"decodeURI() 和 decodeURIComponent() 是 JavaScript 中用于解码 URI（统一资源标识符）的两个方法，它们的核心区别在于解码范围和适用场景。 **1. 编码规则回顾** 在 URI 中，某些字符（如空格、特殊符号）需要被编码为 % 后跟两位十六进制数。例如： 空格被编码为 %2"},{"id":"1065","title":"proxy 可以拦截数组变化吗【热度: 133】","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1065","page":"q/京东-1065.html","excerpt":"**关键词**：proxy set 拦截器 **可以拦截数组变化** Proxy可以有效地拦截数组的变化。当对数组进行各种操作，如修改元素、添加或删除元素等，Proxy都能够捕获这些操作并进行拦截。 **拦截数组的读取和设置操作** 对于数组元素的读取和设置操作，可以通过get和set拦截器来实现。 **get拦截器示"},{"id":"1029","title":"前端应用 CICD 有哪些方式实现【热度: 120】","category":"京东","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1029","page":"q/京东-1029.html","excerpt":"**关键词**：前端 CICD 前端应用的持续集成与持续部署（CI/CD）可以通过以下几种方式实现： **一、使用 Jenkins** 持续集成： Jenkins 可以监听代码仓库（如 Git）的变化，当有新的代码提交时，自动触发构建任务。 对于前端项目，可以配置 Jenkins 执行构建命令，如使用 npm 或 ya"},{"id":"996","title":"如何实现页面文本不可选中，不可复制【热度: 255】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/996","page":"q/京东-996.html","excerpt":"**关键词**：禁止文本复制 可以通过 CSS 和 JavaScript 结合的方式实现页面文本不可选中和不可复制。 **一、使用 CSS** 可以通过设置 CSS 属性来禁止用户选中页面文本： 这将禁止在整个页面上进行文本选择。 **二、使用 JavaScript** 如果仅使用 CSS 不能满足需求，可以结合 Ja"},{"id":"865","title":"如何防止前端页面重复请求【热度: 451】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/865","page":"q/京东-865.html","excerpt":"**关键词**：重复请求问题 防止前端页面的重复请求是提升用户体验和减轻服务器压力的重要策略之一。下面是一些实用的方法来减少或防止重复请求： 1. 使用锁或标志位 设置一个锁（flag）或状态标志位来控制请求的发送。在首次点击或请求发起时设置该标志位，直到请求完成后再清除该标志，以阻止在请求未完成前再次发起相同的请求。"},{"id":"843","title":"[vue] scope 是怎么做的样式隔离的【热度: 126】","category":"京东","labels":["web框架","京东"],"url":"https://github.com/pro-collection/interview-question/issues/843","page":"q/京东-843.html","excerpt":"**关键词**：vue 样式个例 Vue 中的样式隔离是通过 Vue 单文件组件（Single File Components，简称 SFC）的 <style> 标签中的 scoped 属性实现的。当你在一个 Vue 组件的 <style> 标签上添加 scoped 属性时，Vue 会自动将该样式限定在当前组件的范围内"},{"id":"742","title":"单元测试中， TDD、BDD、DDD 分别指？【热度: 166】","category":"京东","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/742","page":"q/京东-742.html","excerpt":"**关键词**：TDD、BDD、DDD TDD、BDD 和 DDD 这三个缩写在软件开发中分别代表以下概念： **TDD（Test-Driven Development） - 测试驱动开发：** TDD 是一种软件开发过程，其中开发人员首先编写一个小测试用例，然后编写足够的代码来使这个测试通过，最后重构新代码以满足所需"},{"id":"569","title":"前端有哪些跨页面通信方式？【热度: 791】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/569","page":"q/京东-569.html","excerpt":"在前端中，有多种跨页面通信的方式，下面列举了其中一些常见的方式： **使用URL参数**：可以通过URL参数在不同页面之间传递数据。例如，可以在URL中添加查询字符串参数来传递数据，并通过解析URL参数来获取传递的数据。 **使用localStorage或sessionStorage**：可以使用浏览器的本地存储（lo"},{"id":"527","title":"常见的请求头和响应头","category":"京东","labels":["网络","京东"],"url":"https://github.com/pro-collection/interview-question/issues/527","page":"q/京东-527.html","excerpt":"**通用头部字段** 指的是在请求头和响应头中都可以使用的字段 | 通用字段 | 作用 | | ----------------- | --------------------------------------------- | | Date | 表示报文创建的时间 | | Connection | 表示内部使用的T"},{"id":"522","title":"前端模块化的演进过程【热度: 798】","category":"京东","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/522","page":"q/京东-522.html","excerpt":"**关键词**：前端模块化演进 1 函数作为块 最开始的时候，是以函数为块来编程，因为函数有自己的作用域，相对比较独立 这种形式中，add和add1都是定义在全局作用域中的，会造成很多问题： 污染全局作用域，容易造成命名冲突 定义在全局作用域，数据不安全 2 namespace模式 使用对象作为独立块编程 优点：减少了"},{"id":"473","title":"package.json 里面 sideEffects 属性的作用是啥【热度: 629】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/473","page":"q/京东-473.html","excerpt":"**关键词**：sideEffects作用、package.json sideEffects 属性、webpack Tree Shaking 优化、Tree Shaking 优化 sideEffects 作用 sideEffects是package.json文件中的一个字段，它用于指定一个模块是否具有副作用。副作用是指"},{"id":"461","title":"[代码实现] 实现数组的flat方法，支持深度层级参数","category":"京东","labels":["京东","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/461","page":"q/京东-461.html","excerpt":"可以通过传入一个深度参数来限制 flat 方法的递归深度。实现如下： 这里在原有的 flat 方法基础上增加了一个 depth 参数，每递归一层，深度就减一，当深度为 0 时就不再递归。"},{"id":"446","title":"移动端如何实现上拉加载，下拉刷新？【热度: 718】","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/446","page":"q/京东-446.html","excerpt":"**关键词**：上拉加载、下拉刷新 移动端实现上拉加载和下拉刷新通常使用一些特定的库或框架来简化开发。以下是两种常见的实现方式： 使用第三方库：一些流行的移动端UI库（如iScroll、BetterScroll、Ant Design Mobile等）提供了上拉加载和下拉刷新的功能，你可以使用它们来实现。这些库通常提供了"},{"id":"434","title":"Object.is() 与比较操作符 “===”、“==” 有什么区别【热度: 1,425】","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/434","page":"q/京东-434.html","excerpt":"**关键词**：Object.is()、js 相等比较 Object.is() 方法和比较操作符 \"===\"、\"==\" 用于比较两个值的相等性，但它们在比较方式和行为上有一些区别。 Object.is() 方法是严格相等比较，而 \"===\" 操作符也是严格相等比较，但 \"==\" 操作符是相等比较。 严格相等比较（==="},{"id":"407","title":"TCP粘包了解多少【热度: 927】","category":"京东","labels":["网络","京东"],"url":"https://github.com/pro-collection/interview-question/issues/407","page":"q/京东-407.html","excerpt":"**关键词**：粘包、粘包解决办法 TCP粘包（TCP packet sticking）是指在数据传输过程中，发送方连续发送的若干小数据包被接收方组合成较大的数据块或者多个小数据包粘合在一起接收的现象。 TCP是面向流的传输协议，数据在传输过程中会被拆分成TCP数据段，并在接收方重新组装。由于TCP的流式传输特性，发送"},{"id":"390","title":"[Webpack] webpack5 Module Federation 了解多少","category":"京东","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/390","page":"q/京东-390.html","excerpt":"概念 Webpack 5 的 Module Federation 是一项功能强大的功能，它允许将 JavaScript 应用程序拆分成独立的模块，并在不同的 Webpack 构建中共享这些模块。它解决了多个独立应用程序之间共享代码的问题，使得实现微前端架构变得更加容易。 Module Federation 可以将一个应"},{"id":"376","title":"SSR 了解多少【热度: 486】","category":"京东","labels":["工程化","京东"],"url":"https://github.com/pro-collection/interview-question/issues/376","page":"q/京东-376.html","excerpt":"**关键词**：SSR 原理、SSR 实现 SSR 原理是啥 服务器端渲染（Server-Side Rendering，SSR）是一种前端渲染方式，其核心原理是在服务器端将动态生成的 HTML 页面发送给客户端，以便客户端在接收到页面时直接渲染显示，而不是在客户端使用 JavaScript 动态生成页面。 核心原理如下"},{"id":"361","title":"函数柯里化了解多少【热度: 529】","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/361","page":"q/京东-361.html","excerpt":"**关键词**：函数柯里化、柯里化应用场景、柯里化优势 函数柯里化是什么？ 函数柯里化（Currying）是一种在函数式编程中使用的技术，其主要目的是将一个接受多个参数的函数转换成一系列使用一个参数的函数。 这样做的好处是允许你创建一些部分应用的函数，预先固定一些参数，使得代码更简洁，便于复用和组合。 以下是一个简单的"},{"id":"354","title":"CSS 伪类和伪元素有哪些，它们的区别和实际应用【热度: 317】","category":"京东","labels":["CSS","京东"],"url":"https://github.com/pro-collection/interview-question/issues/354","page":"q/京东-354.html","excerpt":"**关键词**：css 伪类、css 伪元素 CSS 中有伪类和伪元素两种，它们在用法和意义上有一些区别。 伪类是对元素在特定状态下的一种描述。比如 :hover 代表鼠标悬停状态下的样式，:active 代表元素被激活状态下的样式。伪类始终以冒号 : 开头，并放在选择器的最后。常用的 CSS 伪类有： :hover，"},{"id":"256","title":"Server-sent events(SSE) 了解多少（服务端推送）","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/256","page":"q/京东-256.html","excerpt":"一个网页获取新的数据通常需要发送一个请求到服务器，也就是向服务器请求的页面。使用 server-sent 事件，服务器可以在任何时刻向我们的 Web 页面推送数据和信息。这些被推送进来的信息可以在这个页面上作为 Events + data 的形式来处理。 从服务器接受事件 服务器发送事件 API 也就是 EventSo"},{"id":"255","title":"Long Tasks 了解多少？","category":"京东","labels":["浏览器","京东"],"url":"https://github.com/pro-collection/interview-question/issues/255","page":"q/京东-255.html","excerpt":"什么是 Long Tasks 主线程一次只能处理一个任务（任务按照队列执行）。**当任务超过某个确定的点时，准确的说是50毫秒，就会被称为长任务(Long Task)**。当长任务在执行时，如果用户想要尝试与页面交互或者一个重要的渲染更新需要重新发生，那么浏览器会等到Long Task执行完之后，才会处理它们。结果就会"},{"id":"254","title":"Service Worker 是如何缓存 http 请求资源的？","category":"京东","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/254","page":"q/京东-254.html","excerpt":"Service Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。 Service Worker 可以通过以下步骤来缓存 http 请求资源： 注册 Service Worker：通过在页面中注册 Service Work"},{"id":"214","title":"this指向与对象继承数组方法：输出以下代码执行的结果并解释为什么？","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/214","page":"q/京东-214.html","excerpt":"代码如下 执行结果如何， 为什么？ 执行结果 代码的执行结果是： 在代码中，我们创建了一个名为 obj 的对象，它包含了一些属性和方法： 2 和 3 是对象的属性名，对应的属性值分别为 3 和 4。 length 属性的值为 2。 splice 和 push 是对象的两个方法，它们均继承自 Array.prototyp"},{"id":"212","title":"[3, 15, 8, 29, 102, 22].sort(), 结果是多少， 为什么？","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/212","page":"q/京东-212.html","excerpt":"输出结果为： 原因： Array.prototype.sort() 如果没有指明 compareFn ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 \"Banana\" 会被排列到 \"cherry\" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFn"},{"id":"211","title":"下面代码中 a 在什么情况下会打印 1 ?","category":"京东","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/211","page":"q/京东-211.html","excerpt":"问题 回答 这是一个经典的面试题，可以通过重写 valueOf 或者 toString 方法来实现，在这些方法中动态返回变量 a 的值，以满足条件。例如： 在这个例子中，a 被定义为一个对象，有一个属性 i 初始化为 1，同时重写了 toString 方法，在每次调用时返回 i 的值，并且每次返回后将 i 自增。这样在"},{"id":"789","title":"css 实现翻牌效果【热度: 116】","category":"快手","labels":["CSS","快手"],"url":"https://github.com/pro-collection/interview-question/issues/789","page":"q/快手-789.html","excerpt":"**关键词**：css 动效应用 主要是考察几个属性的使用 transform: rotateY 用于 Y 轴旋转 transition 用于过度动画 还有一个要点： 翻转卡牌的时候，正面在上， 要将背面隐藏； 背面在上， 要将正面隐藏； 效果如下： **实现比较简单， 直接贴代码**："},{"id":"746","title":"[React] 是如何处理组件更新和渲染的？【热度: 862】","category":"快手","labels":["web框架","快手"],"url":"https://github.com/pro-collection/interview-question/issues/746","page":"q/快手-746.html","excerpt":"**关键词**：React 组件更新、React 组件渲染 React 组件的更新和渲染遵循一个相对严格的生命周期，这个生命周期在 React 16 版本之后，也就是从引入 Fiber 架构开始，稍微有所变化。React 通过一系列的生命周期方法以及新引入的 Hooks API，对组件的更新进行管理，主要流程如下： 类"},{"id":"572","title":"如何拦截 web 应用的请求【热度: 487】","category":"快手","labels":["网络","快手"],"url":"https://github.com/pro-collection/interview-question/issues/572","page":"q/快手-572.html","excerpt":"**关键词**：web前端监听请求、前端拦截请求 在前端拦截和处理 Web 应用的所有请求，可以使用以下方法： **使用 Fetch 或 XMLHttpRequest**：在前端代码中使用 Fetch API 或 XMLHttpRequest 对象发送请求。通过拦截 Fetch 或 XMLHttpRequest 对象的"},{"id":"559","title":"什么是匿名函数？【热度: 275】","category":"快手","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/559","page":"q/快手-559.html","excerpt":"**关键词**：匿名函数 在JavaScript中，匿名函数是一种没有名称的函数。它是一种可以直接被定义和使用的函数，而不需要通过函数名进行引用。匿名函数通常用于需要临时定义一个函数并在某个地方立即调用它的情况下使用。 匿名函数可以使用两种方式进行定义：函数表达式和箭头函数。 函数表达式： 在上述代码中，我们定义了一个"},{"id":"558","title":"git 中回滚代码有哪些操作？【热度: 237】","category":"快手","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/558","page":"q/快手-558.html","excerpt":"**关键词**：git 回滚代码、git reset 操作、git revert 操作 在 Git 中，可以使用以下几种操作来回滚代码： git revert：使用 git revert 命令可以创建一个新的提交来撤销之前的提交。它会创建一个新的提交，恢复之前的更改，从而回滚代码。这种方式比较安全，不会改变历史提交记录"},{"id":"557","title":"git reset 作用是啥，有哪些操作？【热度: 275】","category":"快手","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/557","page":"q/快手-557.html","excerpt":"**关键词**：git reset 作用、git reset 操作 git reset 是一个用于撤销提交的命令，可以将当前分支指向某个特定的提交，同时可以选择是否修改工作区和暂存区。 常见的 git reset 操作有以下三种： git reset --soft <commit>：将当前分支的 HEAD 指向指定的 "},{"id":"556","title":"为什么现代前端应用需要打包工具进行打包编译？【热度: 588】","category":"快手","labels":["工程化","快手"],"url":"https://github.com/pro-collection/interview-question/issues/556","page":"q/快手-556.html","excerpt":"**关键词**：打包构建必要性 现代前端应用需要打包工具进行打包编译的主要原因有以下几点： 模块化管理：现代前端应用通常采用模块化的开发方式，将代码划分为多个模块，每个模块具有独立的功能和依赖关系。打包工具可以将这些模块进行分析，将它们打包成一个或多个静态文件，方便管理和维护。 解决浏览器兼容性问题：不同的浏览器对于 "},{"id":"538","title":"引用类型有哪些，有什么特点【热度: 902】","category":"快手","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/538","page":"q/快手-538.html","excerpt":"**关键词**：js引用类型 在JavaScript中，引用类型是指非基本数据类型，它们是由对象、数组、函数等复杂数据结构组成的。 常见的引用类型包括： 对象（Object）：对象是JavaScript中最基本的引用类型，它可以用来存储键值对，也可以通过原型链实现继承。 数组（Array）：数组是一种有序的集合，可以存"},{"id":"493","title":"为什么 SPA 应用都会提供一个 hash 路由，好处是什么？【热度: 681】","category":"快手","labels":["web应用场景","快手"],"url":"https://github.com/pro-collection/interview-question/issues/493","page":"q/快手-493.html","excerpt":"**关键词**：hash路由优势、hash路由和history路由区别 SPA（单页应用）通常会使用 hash 路由的方式来实现页面的导航和路由功能。这种方式将路由信息存储在 URL 的片段标识符（hash）中，例如：www.example.com/#/home。 以下是使用 hash 路由的 SPA 的一些好处： 兼"},{"id":"483","title":"如何实现页面顶部， 自定义滚动进度条样式【热度: 1,220】","category":"快手","labels":["CSS","快手"],"url":"https://github.com/pro-collection/interview-question/issues/483","page":"q/快手-483.html","excerpt":"**关键词**：自定义滚动条、自定义顶部滚动条 要实现页面顶部的自定义滚动进度条样式，可以按照以下步骤进行： 在HTML中添加滚动进度条的容器元素，通常可以使用一个<div>元素作为容器，放在页面顶部的合适位置。 在CSS中定义滚动进度条的样式。可以使用背景颜色、高度、透明度等属性来自定义样式。 使用JavaScrip"},{"id":"470","title":"如果不使用脚手架， 如果用 webpack 构建一个自己的 react 应用【热度: 729】","category":"快手","labels":["web应用场景","快手"],"url":"https://github.com/pro-collection/interview-question/issues/470","page":"q/快手-470.html","excerpt":"**关键词**：构建 react 应用 利用 webpack 初始化基本应用构建 要在Webpack配置中添加对Less和Ant Design组件库的支持，需要进行以下步骤： 安装所需的依赖。 在Webpack配置文件中添加对Less的支持。 在入口文件中引入Ant Design的样式文件。 现在你可以在React组件"},{"id":"464","title":"[react] 数组用useState做状态管理的时候，使用push，pop，splice等直接更改数组对象，会引起页面渲染吗？【热度: 488】","category":"快手","labels":["web框架","快手"],"url":"https://github.com/pro-collection/interview-question/issues/464","page":"q/快手-464.html","excerpt":"**关键词**：useState状态管理、push 直接更改数组对象、pop 直接更改数组对象、splice 直接更改数组对象 在React中，使用useState时使用push，pop，splice等直接更改数组对象是不推荐的做法，因为这种直接更改数组的方式会改变原始状态，React不会检测到这种状态变化，从而无法正"},{"id":"443","title":"深度遍历广度遍历的区别？【热度: 867】","category":"快手","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/443","page":"q/快手-443.html","excerpt":"**关键词**：深度遍历广度遍历 深度遍历（Depth-First Search，DFS）和广度遍历（Breadth-First Search，BFS）是两种常用的图遍历算法，用于访问和搜索图或树中的节点。它们在遍历顺序和搜索策略上有所不同。 深度遍历（DFS）： 深度遍历从一个节点开始，递归地访问该节点的子节点，直到"},{"id":"441","title":"解释性语言和编译型语言的区别【热度: 858】","category":"快手","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/441","page":"q/快手-441.html","excerpt":"**关键词**：解释性语言和编译型语言 解释性语言和编译型语言是两种不同的编程语言类型，它们在代码的执行方式和运行过程中的一些特点上存在区别。 编译型语言： 编译型语言的代码在运行之前需要经过编译器的处理，将源代码一次性地转换成机器语言的可执行文件（通常是二进制文件）。 编译器将源代码转换为目标代码的过程包括词法分析、"},{"id":"727","title":"介绍一下 MutationObserver【热度: 632】","category":"浏览器","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/727","page":"q/浏览器-727.html","excerpt":"**关键词**：MutationObserver api MutationObserver 是一种能够响应 DOM 树变动的 Web API，它可以监听几乎所有类型的 DOM 变动，比如元素被添加、删除或修改。你可以通过它执行 callback 来应对这些变化。 下面是 MutationObserver 的基本用法： "},{"id":"697","title":"JS 的加载会阻塞浏览器渲染吗？【热度: 243】","category":"浏览器","labels":["浏览器","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/697","page":"q/浏览器-697.html","excerpt":"**关键词**：浏览器渲染阻塞、JS 阻塞浏览器渲染 JavaScript 的加载、解析和执行默认情况下会阻塞浏览器的渲染过程。这是因为浏览器渲染引擎和 JavaScript 引擎是单线程的，并且二者共享同一个线程。JavaScript 在执行时会阻止 DOM 构建，因为 JavaScript 可能会修改 DOM 结构"},{"id":"696","title":"浏览器对队头阻塞有什么优化？【热度: 368】","category":"浏览器","labels":["网络","浏览器","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/696","page":"q/浏览器-696.html","excerpt":"**关键词**：队头阻塞优化 队头阻塞（Head-of-Line Blocking，缩写 HoLB）问题主要发生在网络通信中，特别是在使用 HTTP/1.1 和以前版本时，在一个 TCP 连接中同一时间只能处理一个请求。即使后续的请求已经准备好在客户端，它们也必须等待当前处理中的请求完成后才能被发送。这会延迟整个页面或"},{"id":"621","title":"IndexedDB 存储空间大小是如何约束的？【热度: 116】","category":"浏览器","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/621","page":"q/浏览器-621.html","excerpt":"**关键词**：IndexedDB 存储空间大小设置 IndexedDB 有大小限制。具体来说，IndexedDB 的大小限制通常由浏览器实现决定，因此不同浏览器可能会有不同的限制。 一般来说，IndexedDB 的大小限制可以分为两个方面： 单个数据库的大小限制：每个 IndexedDB 数据库的大小通常会有限制，这"},{"id":"620","title":"浏览器的存储有哪些【热度: 814】","category":"浏览器","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/620","page":"q/浏览器-620.html","excerpt":"**关键词**：浏览器存储 在浏览器中，有以下几种常见的存储方式： Cookie：Cookie 是一种存储在用户浏览器中的小型文本文件。它可以用于存储少量的数据，并在浏览器与服务器之间进行传输。Cookie 可以设置过期时间，可以用于维持用户会话、记录用户偏好等功能。 Web Storage：Web Storage 是"},{"id":"526","title":"html 标签属性 src 和 href 有什么区别【热度: 1,134】","category":"浏览器","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/526","page":"q/浏览器-526.html","excerpt":"**关键词**：src和href 有什么区别 下面是一个表格，展示了src和href属性之间的异同点： | 特点 | src属性 | href属性 | |----------------|----------------------------------------|-------------------------"},{"id":"518","title":"HTML 属性 crossorigin 的作用是什么【热度: 267】","category":"浏览器","labels":["浏览器","小米"],"url":"https://github.com/pro-collection/interview-question/issues/518","page":"q/浏览器-518.html","excerpt":"**关键词**：crossorigin 属性、crossorigin 作用、crossorigin 资源错误处理 crossorigin 属性在 <audio>、<img>、<link>、<script> 和 <video> 元素中有效，它们提供对 CORS 的支持，定义该元素如何处理跨源请求，从而实现对该元素获取数据"},{"id":"517","title":"html rel 属性 的参数 preload和prefetch 的作用是什么【热度: 1,057】","category":"浏览器","labels":["浏览器","小米"],"url":"https://github.com/pro-collection/interview-question/issues/517","page":"q/浏览器-517.html","excerpt":"**关键词**：rel preload 作用、rel prefetch 作用、rel defer 作用、rel prefetch rel 属性定义了所链接的资源与当前文档的关系，在 <a>、<area> 和 <link> 元素上有效。支持的值取决于拥有该属性的元素。 preload和prefetch是浏览器提供的两种对"},{"id":"513","title":"link 标签有 那些属性，作用都是啥？【热度: 839】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/513","page":"q/浏览器-513.html","excerpt":"**关键词**：link 标签属性 link标签有以下几个常用的属性： href：指定所链接文档的URL地址，可以是一个外部CSS文件的URL或者其他文档的URL。 rel：用于定义当前文档与所链接文档之间的关系。常用的取值有stylesheet（指定所链接文档是一个外部CSS文件）、icon（指定所链接文档是一个图标"},{"id":"497","title":"onpopstate可以监听到一个pushstate的事件吗【热度: 546】","category":"浏览器","labels":["浏览器","百度"],"url":"https://github.com/pro-collection/interview-question/issues/497","page":"q/浏览器-497.html","excerpt":"**关键词**：popstate **onpopstate 事件只能监听到浏览器历史记录的前进和后退操作，无法直接监听到 pushState 或 replaceState 的调用**。这是因为 pushState 和 replaceState 方法可以修改浏览器历史记录而不触发 onpopstate 事件。 但是，您可"},{"id":"495","title":"原生 js 如何进行监听路由的变化【热度: 906】","category":"浏览器","labels":["浏览器","网易"],"url":"https://github.com/pro-collection/interview-question/issues/495","page":"q/浏览器-495.html","excerpt":"**关键词**：原生路由监听 在原生 JavaScript 中，可以使用 window 对象上的 popstate 事件来监听路由的变化。popstate 事件在浏览器的历史记录发生变化时触发，包括当用户点击浏览器的前进或后退按钮、调用 history.pushState() 或 history.replaceStat"},{"id":"494","title":"HTML5 的 History API 进行导航时，页面真的进行了一个切换吗？【热度: 424】","category":"浏览器","labels":["浏览器","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/494","page":"q/浏览器-494.html","excerpt":"**关键词**：History 导航、History 导航页面切换、History 页面切换 当使用 HTML5 的 History API 进行导航时，页面实际上没有进行完全的刷新。相反，只是通过 JavaScript 动态地更改 URL，并通过这个新的 URL 加载相应的内容。 这种方式被称为前端路由，因为页面的切"},{"id":"491","title":"如何优化 DOM 树解析过程【热度: 414】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/491","page":"q/浏览器-491.html","excerpt":"**关键词**：DOM 树解析过程、DOM 树解析、优化 DOM 树解析 以下是一些优化DOM树解析的方法： 减少DOM元素数量：尽可能减少页面上的DOM元素数量，可以通过合并或删除不必要的元素、使用CSS样式代替多个元素等方式来实现。 使用语义化的HTML结构：使用合适的HTML标签和语义化的结构，可以提高解析的效率"},{"id":"490","title":"DOM 树解析过程【热度: 416】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/490","page":"q/浏览器-490.html","excerpt":"**关键词**：DOM 树解析过程、DOM 树解析 DOM树的生成是由浏览器解析HTML文档时自动生成的。下面是DOM树生成的一般过程： 解析HTML：浏览器从上到下逐行解析HTML文档，将文档分解为一系列的标记（tokens）。 构建DOM节点：解析器根据标记构建DOM节点，并将这些节点连接到树形结构中。每个标记对应"},{"id":"427","title":"<!DOCTYPE html> 标签有何作用?","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/427","page":"q/浏览器-427.html","excerpt":"<!DOCTYPE html> 是 HTML5 的文档类型声明（Document Type Declaration），它的作用是告诉浏览器当前文档使用的是 HTML5 规范。 具体来说，<!DOCTYPE html> 的作用有以下几个方面： 指定文档类型：文档类型声明告诉浏览器当前文档所使用的 HTML 版本，即 HT"},{"id":"426","title":"HTML5 drag(拖拽) API 了解多少【热度: 324】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/426","page":"q/浏览器-426.html","excerpt":"**关键词**：drag 拖拽 api、拖拽 api api HTML5 Drag API 提供了一组用于实现拖放操作的接口和事件。以下是 HTML5 Drag API 中常用的一些接口和事件： draggable 属性：将元素设置为可拖动。可以通过设置元素的 draggable 属性为 true 或 false 来控"},{"id":"425","title":"iframe 标签有那些优点和缺点？【热度: 411】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/425","page":"q/浏览器-425.html","excerpt":"**关键词**：iframe优点、iframe缺点、iframe应用 <iframe> 标签是 HTML 中的内嵌框架元素，它具有一些优点和缺点，如下所示： 优点： 分隔内容：<iframe> 允许将不同的 HTML 文档嵌入到当前文档中，实现内容的分隔和独立。每个 <iframe> 都有自己的文档上下文，可以在不同的"},{"id":"424","title":"src和href的区别是什么？【热度: 1,601】","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/424","page":"q/浏览器-424.html","excerpt":"**关键词**：src和href的区别 src 和 href 是两个在 HTML 中常用的属性，它们具有不同的作用和用途，主要区别如下： 用途： src 属性用于指定嵌入资源的 URL，如图片、音频、视频等。 href 属性用于创建超链接，定义链接到的目标 URL 地址。 资源加载： src 属性用于指定需要加载的资源"},{"id":"366","title":"浏览器有读写能力吗？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/366","page":"q/浏览器-366.html","excerpt":"在一般情况下，浏览器本身不具备直接的读写能力。浏览器是用于显示网页内容的客户端应用程序，其主要功能是发送HTTP请求，接收和渲染服务器返回的HTML、CSS和JavaScript等资源。然而，浏览器提供了一些特定的API，允许开发人员在浏览器中进行读写操作。 下面是一些允许浏览器进行读写操作的API： Web Stor"},{"id":"364","title":"如何优化大规模 dom 操作的场景【热度: 1,012】","category":"浏览器","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/364","page":"q/浏览器-364.html","excerpt":"**关键词**：dom 操作性能、dom 操作优化 在处理大规模DOM操作的场景中，可以采取以下一些优化策略： 使用批量操作：避免频繁地进行单个DOM操作，而是将多个操作合并为一个批量操作。例如，使用DocumentFragment来创建一个离线的DOM片段，将多个元素一次性添加到片段中，然后再将整个片段插入到文档中。"},{"id":"352","title":"HTML5 中 meta 标签作用是啥【热度: 1,562】","category":"浏览器","labels":["浏览器","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/352","page":"q/浏览器-352.html","excerpt":"**关键词**：html5 meta HTML 5 中的 meta 标签是一个非常常用的标签，它可以用来描述一个 HTML 文档的一些基本信息与配置，包括字符编码、页面关键词、作者、视口大小等。具体来说，meta 标签可用于以下几个方面： 1.描述文档内容：通过设置 meta 标签中的一些属性，可以描述文档的主体内容、"},{"id":"330","title":"cookie 构成部分有哪些【热度: 598】","category":"浏览器","labels":["浏览器","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/330","page":"q/浏览器-330.html","excerpt":"**关键词**：cookie 构成部分、cookie 作用路径、cookie 作用域 在 HTTP 协议中，cookie 是一种包含在请求和响应报文头中的数据，用于在客户端存储和读取信息。cookie 是由服务器发送的，客户端可以使用浏览器 API 将 cookie 存储在本地进行后续使用。 一个 cookie 通常由"},{"id":"328","title":"script 预加载方式有哪些， 这些加载方式有何区别？【热度: 420】","category":"浏览器","labels":["浏览器","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/328","page":"q/浏览器-328.html","excerpt":"**关键词**：script 预加载 在浏览器中，可以通过预加载 JavaScript 脚本来提高性能和用户体验。预加载是指在浏览器解析完当前页面之前，提前加载并解析相关资源（例如 JavaScript 文件、CSS 文件等）。这样可以在用户请求访问其他页面时，减少资源加载的时间和延迟，从而提高页面加载速度和用户体验。"},{"id":"255","title":"Long Tasks 了解多少？","category":"浏览器","labels":["浏览器","京东"],"url":"https://github.com/pro-collection/interview-question/issues/255","page":"q/浏览器-255.html","excerpt":"什么是 Long Tasks 主线程一次只能处理一个任务（任务按照队列执行）。**当任务超过某个确定的点时，准确的说是50毫秒，就会被称为长任务(Long Task)**。当长任务在执行时，如果用户想要尝试与页面交互或者一个重要的渲染更新需要重新发生，那么浏览器会等到Long Task执行完之后，才会处理它们。结果就会"},{"id":"170","title":"文件上传和上传文件解析的原理是啥？","category":"浏览器","labels":["网络","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/170","page":"q/浏览器-170.html","excerpt":"前端如何上传图片等文件 在前端上传图片或其他文件字段，一般使用 HTML 中的 <input> 元素，并设置 type=\"file\"，这样就可以让用户选择本地的文件进行上传。 例如： 在这个例子中，<form> 元素的 enctype 属性设置为 multipart/form-data，这样就可以将文件作为二进制数据进"},{"id":"155","title":"常见的前端检测内存泄露的方法有哪些？","category":"浏览器","labels":["JavaScript","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/155","page":"q/浏览器-155.html","excerpt":"怎么检测内存泄漏 内存泄漏主要是指的是内存持续升高，但是如果是正常的内存增长的话，不应该被当作内存泄漏来排查。排查内存泄漏，我们可以借助Chrome DevTools的Performance和Memory选项。举个栗子： 我们新建一个memory.html的文件，完整代码如下： 页面上有一个按钮用来开始函数调用，方便我"},{"id":"154","title":"常见的前端内存泄露场景有哪些？","category":"浏览器","labels":["JavaScript","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/154","page":"q/浏览器-154.html","excerpt":"大多数情况下，垃圾回收器会帮我们及时释放内存，一般不会发生内存泄漏。但是有些场景是内存泄漏的高发区，我们在使用的时候一定要注意： 我们在开发的时候经常会使用console在控制台打印信息，但这也会带来一个问题：被console使用的对象是不能被垃圾回收的，这就可能会导致内存泄漏。因此在生产环境中不建议使用console"},{"id":"138","title":"浏览器渲染进程了解多少？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/138","page":"q/浏览器-138.html","excerpt":"浏览器进程： 浏览器是一个多进程的架构，当我们每开一个tab页面，就会开一个新的进程，所以如果一个页面崩溃也不会影响到别的页面。面试的时候经常会问从输入url到页面显示都发生了什么，这次主要说说针对渲染这块而浏览器具体都做了些什么，都有哪些进程？ 首先浏览器进程有如下几部分：**主进程**，**第三方插件进程，GPU进"},{"id":"123","title":"script 标签 defer 和 async 区别？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/123","page":"q/浏览器-123.html","excerpt":"defer 和 async 是用于控制脚本加载和执行的 HTML <script> 标签属性。 defer 和 async 的主要区别在于它们对脚本的加载和执行的影响。 defer 属性告诉浏览器立即下载脚本，但延迟执行，等到文档加载完成后再按照它们在页面中出现的顺序依次执行。这意味着脚本不会阻止文档的解析和渲染，并且"},{"id":"118","title":"浏览器垃圾回收机制？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/118","page":"q/浏览器-118.html","excerpt":"浏览器垃圾回收机制是指浏览器在运行时自动回收不再使用的内存空间的过程。以下是浏览器垃圾回收机制的几个方面： 标记清除：这是一种最常用的垃圾回收机制。它的工作原理是标记所有当前正在使用的对象，然后清除未标记的对象。这种方法的优点是效率高，缺点是可能会导致内存碎片。 引用计数：这种垃圾回收机制会跟踪每个对象被引用的次数，当"},{"id":"89","title":"从哪些方面可以对网站性能优化？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/89","page":"q/浏览器-89.html","excerpt":"content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减"},{"id":"88","title":"从浏览器地址栏输入url到显示页面所经历的流程有哪些(以HTTP为例)？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/88","page":"q/浏览器-88.html","excerpt":"在浏览器地址栏输入URL 浏览器查看**缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，"},{"id":"66","title":"重绘与重排的区别？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/66","page":"q/浏览器-66.html","excerpt":"浏览器重绘（Repaint）和重排（Reflow）是Web页面中常见的两种渲染方式，它们的区别如下： 重排（Reflow）：当DOM元素的结构或者布局发生变化时，浏览器需要重新计算元素的几何属性（比如位置、大小等），然后重新构建渲染树，这个过程叫做重排。重排的代价比较高，因为需要浏览器重新计算和布局，会消耗较多的CPU"},{"id":"65","title":"常见的浏览器内核有哪些，有啥区别？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/65","page":"q/浏览器-65.html","excerpt":"常见的浏览器内核包括： **Trident内核**：由Microsoft开发，主要用于Internet Explorer浏览器，也是Windows系统自带的默认浏览器内核。该内核在HTML和CSS的解释、渲染方面存在一些问题，但在JavaScript引擎的处理上表现较为出色。 **Gecko内核**：由Mozilla开"},{"id":"64","title":"浏览器 DOM Tree是如何构建的？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/64","page":"q/浏览器-64.html","excerpt":"浏览器构建DOM树的过程包括以下几个步骤： 解析HTML代码：浏览器会将HTML代码解析成一个DOM树的结构。 创建根节点：DOM树的根节点通常是HTML元素。 创建子节点：根据HTML标记的嵌套关系，浏览器会在DOM树中创建相应的子节点，每个节点表示一个HTML元素。 创建属性节点：HTML元素可能有一些属性，例如i"},{"id":"63","title":"浏览器是如何渲染UI的？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/63","page":"q/浏览器-63.html","excerpt":"浏览器渲染UI的过程通常被称为渲染流水线（rendering pipeline），它可以分为以下几个步骤： 解析HTML：浏览器首先解析HTML代码，创建DOM（文档对象模型）树。DOM树是由节点和对象组成的层次结构，它表示了文档的内容和结构。 解析CSS：浏览器接着解析CSS代码，创建CSSOM（CSS对象模型）树。"},{"id":"62","title":"浏览器如何解析css选择器？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/62","page":"q/浏览器-62.html","excerpt":"浏览器会『从右往左』解析CSS选择器。 CSS选择器的解析顺序 相信很多人在一开始接触CSS的时候都会看到一条规则就是尽量少使用层级关系，比如尽量不要写成： 而是写成： 之所以需要这么写，给的解释是这样可以减少选择器匹配的次数。 初看觉得哦，有点道理啊，但是往细了再想想： 如果我把层级定的足够的清晰分明，那不是可以直接"},{"id":"61","title":"浏览器的主要组成部分是什么？","category":"浏览器","labels":["浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/61","page":"q/浏览器-61.html","excerpt":"浏览器的主要组成部分是什么 **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。 **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和"},{"id":"1133","title":"ts 有哪些常用的关键词【热度: 178】","category":"美团","labels":["TypeScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1133","page":"q/美团-1133.html","excerpt":"**关键词**：ts 关键词 作者备注 这个问题主要是对 ts 类型熟悉程度的考察， 比直接问 number、string 等基础类型有意义。 TypeScript 在 JavaScript 基础上扩展了许多用于类型定义和类型控制的关键字，这些关键字是构建 TypeScript 类型系统的核心。以下是常用的关键词分类及"},{"id":"1132","title":"ts 里面 infer 是什么关键词， 怎么用【热度: 975】","category":"美团","labels":["TypeScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1132","page":"q/美团-1132.html","excerpt":"**关键词**：ts infer 在 TypeScript 中，infer 是一个用于**类型推断**的关键字，通常与条件类型（Conditional types）配合使用，用于**从泛型类型中提取或推断出某个具体类型**。它的核心作用是“让 TypeScript 自动推导出我们需要的类型”，而无需需手动指定。 基本语"},{"id":"1064","title":"proxy set 拦截器，其中参数中第一个参数 target 和 最后一个参数 receiver 有何区别【热度: 132】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1064","page":"q/美团-1064.html","excerpt":"**关键词**：proxy set 拦截器 **target参数** **本质和用途** target是被代理的原始对象。它代表了代理操作所基于的实际对象。在Proxy的set拦截器中，target的主要作用是提供对原始对象属性和状态的访问，以便在拦截属性设置操作时，可以正确地将新值应用到原始对象的相应属性上。 **示"},{"id":"1063","title":"在 JS 里面， proxy set 拦截器， 有那些参数， 分别表示什么含义【热度: 120】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1063","page":"q/美团-1063.html","excerpt":"**关键词**：proxy set 拦截器 **target参数** **含义**：它是被代理的目标对象。这个对象是原始的、即将被操作（在set操作的情境下是被设置属性值）的对象。例如，如果你创建了一个代理来拦截对某个对象属性的设置操作，target就是那个实际拥有属性的原始对象。 **示例**： 在这个例子中，tar"},{"id":"998","title":"[Vue] nextTick 作用是什么， 原理是什么【热度: 177】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/998","page":"q/美团-998.html","excerpt":"**关键词**：vue nextTick 作用、原理 在 Vue 中，nextTick主要有以下作用和工作原理： **一、作用** 确保 DOM 更新后执行操作： Vue 是异步更新 DOM 的。当你在代码中修改了数据，Vue 不会立即更新 DOM，而是将这些更新操作放入一个队列中，等待下一个“tick”（事件循环的一"},{"id":"997","title":"[Vue] vue3 如何监听数组变化【热度: 199】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/997","page":"q/美团-997.html","excerpt":"**关键词**：vue3 监听数组变化 在 Vue 3 中，可以通过以下几种方式监听数组的变化： **一、使用watch函数监听数组引用变化** 直接监听数组变量： 可以使用watch函数来监听一个数组变量的变化。当数组被重新赋值时，watch会触发。 在这个例子中，当state.arr数组被重新赋值时，watch函数"},{"id":"993","title":"304 是什么状态码， 跟哪些 header 有关【热度: 546】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/993","page":"q/美团-993.html","excerpt":"**关键词**：http 状态码 304 是 HTTP 状态码中的“Not Modified”（未修改）状态码。 当客户端（通常是浏览器）向服务器请求资源时，如果服务器判断该资源自上次客户端获取后没有被修改，就会返回 304 状态码，告诉客户端可以使用其本地缓存的版本，而无需再次传输整个资源。 304 状态码主要与以下"},{"id":"992","title":"常见的 http code 4xx 都有哪些状态码【热度: 545】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/992","page":"q/美团-992.html","excerpt":"**关键词**：http 状态码 HTTP 状态码中 4xx 类状态码表示客户端错误。常见的 4xx 状态码有： **一、400 Bad Request（错误请求）** **含义**： 服务器无法理解客户端的请求，通常是由于请求格式错误、参数错误或缺少必要的信息导致的。 例如，请求的 URL 语法错误、请求体格式不正确"},{"id":"960","title":"浏览器中如何实现剪切板复制内容的功能【热度: 95】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/960","page":"q/美团-960.html","excerpt":"**关键词**：document.execCommand('copy')、navigator.clipboard API 在浏览器中，可以通过以下几种方式实现剪切板复制内容的功能： **一、使用document.execCommand('copy')** **基本用法**： 在 JavaScript 中，可以使用doc"},{"id":"898","title":"[Vue] 3.x 中 app.config 有哪些应用配置？【热度: 200】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/898","page":"q/美团-898.html","excerpt":"**关键词**：app.config 配置 确实，在 Vue 3 中，app.config 提供了一系列的应用级别的配置选项，用于自定义或调整 Vue 应用的行为。你提到的这些配置项都是 app.config 的一部分，下面是关于它们的详细介绍： app.config.errorHandler **作用**：为未捕获的"},{"id":"897","title":"[Vue] 选项式 API 和组合式 API，两者有何区别，该如何取舍【热度: 322】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/897","page":"q/美团-897.html","excerpt":"**关键词**：选项式 API 和组合式 API 区别 选项式 API (Options API) 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 组合式 API (Com"},{"id":"893","title":"http 常见的几个重定向 code 是多少，区别是啥【热度: 172】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/893","page":"q/美团-893.html","excerpt":"**关键词**：http 重定向 code HTTP 重定向是指当客户端访问一个页面时，服务器返回一个重定向状态码，告诉客户端去访问另一个 URL。常见的 HTTP 重定向状态码有以下几种，每个状态码都有其特定的意义和使用场景： 1. **301 Moved Permanently（永久移动）** **含义**：请求的"},{"id":"892","title":"http 的请求和响应都有哪些传输数据格式【热度: 149】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/892","page":"q/美团-892.html","excerpt":"**关键词**：http 传输格式 HTTP（超文本传输协议）是一种用于传输超媒体文档（如 HTML）的应用层协议。在 HTTP 请求和响应中，可以传输多种数据格式。这些数据格式主要通过 HTTP 头部中的Content-Type字段来指定。下面是一些常见的 HTTP 传输数据格式： 1. 文本格式 **text/pl"},{"id":"884","title":"介绍一下 position sticky【热度: 826】","category":"美团","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/884","page":"q/美团-884.html","excerpt":"**关键词**：position sticky position: sticky; 是 CSS 中的一个定位属性值，它允许元素在页面滚动到某个阈值时“固定”在位置上，而在达到这个阈值之前，元素会像正常文档流中的元素一样表现（也就是说，在特定条件下它表现得像 position: relative;，在另一些条件下表现得像"},{"id":"880","title":"需要详细记录多个操作链路的性能耗时，进行结构化场景分析，该如何做【热度: 378】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/880","page":"q/美团-880.html","excerpt":"**关键词**：操作链路耗时分析 作者笔记 该问题， 主要是考察两个问题， 怎么定操作节点指标， 怎么去捕获每个阶段时间的耗时 操作节点指标 首先对一个操作链路切片：比如一个操作流程， 分拆为第一步， 第二步， 第三步....... 然后对每一步一个事件点。 然后统计每一个时间点之间的时间差， 就可以得出用户早操作每一"},{"id":"878","title":"长文本场景，中间显示省略号..., 两端正常展示【热度: 351】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/878","page":"q/美团-878.html","excerpt":"**关键词**：长文本隐藏 在前端处理长文本且需要在中间显示省略号（...），两端保留完整文本的情况，通常有下面几种方法可以达到效果： 1. 纯 CSS 解决方案（对于单行文本） 对于单行的文本，可以使用 CSS 的text-overflow属性来实现，但这种方法一般只能实现末尾的省略号，无法直接实现中间省略的效果。 "},{"id":"867","title":"要实时统计用户浏览器窗口大小，该如何做【热度: 210】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/867","page":"q/美团-867.html","excerpt":"**关键词**：resize 事件应用 要实时统计用户浏览器窗口大小，可以利用 JavaScript 中的 resize 事件。当浏览器窗口尺寸变化时，此事件会被触发。通过侦听此事件，可以实时获取并处理浏览器窗口的宽度和高度。 基础示例 下面是一个简单的示例，展示如何使用 resize 事件来获取并打印当前浏览器窗口的"},{"id":"866","title":"ResizeObserver 作用是什么【热度: 416】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/866","page":"q/美团-866.html","excerpt":"**关键词**：ResizeObserver api ResizeObserver 的作用是监测元素的尺寸变化。这是一种强大的 Web API，允许开发者在元素的尺寸发生改变时（无论是因为元素内容的变化、窗口大小的调整还是其他原因导致的尺寸改变），执行一些操作或布局更新。在过去，开发者通常需要依赖定时器或者窗口的 re"},{"id":"844","title":"JS 数据类型里面， Set 和 数组分别有哪些适用场景，开发中该如何抉择【热度: 333】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/844","page":"q/美团-844.html","excerpt":"**关键词**：Set 和 数组 适用场景 在 JavaScript 中，Set和数组（Array）都是用来存储一系列数据的集合，但它们具有不同的特性和适用场景。了解这些差异可以帮助你在特定情况下做出更合适的选择。 Set **特性**： Set是一种新的数据结构，被引入在 ES6 中。 它类似于数组，但是成员的值都是"},{"id":"838","title":"[webpack] 手写 webpack plugin 有那些重要 api 与注意的地方？【热度: 714】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/838","page":"q/美团-838.html","excerpt":"**关键词**：手写 webpack plugin 在手写一个 webpack 插件时，理解和使用一些核心的 API 是非常关键的。以下是编写 webpack 插件时需要知道的一些重要的 API 和注意事项。 重要的 API **compiler 对象**: compiler.hooks: 提供了一系列的钩子，用于插件"},{"id":"837","title":"[webpack] 手写一个 plugin, 统计源码里面的 console.log 调用数量与调用路径【热度: 113】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/837","page":"q/美团-837.html","excerpt":"**关键词**：手写 webpack plugin 创建一个 webpack 插件需要遵循 webpack 插件的基本结构和原则，同时为了实现统计源码里的 console.log 调用数量与调用路径的目标，我们可能需要对 webpack 的编译过程有一定的了解，尤其是如何操作 webpack 的模块系统内部的原始源代码"},{"id":"826","title":"js 数据类型里面，Map 和 object 分别有哪些适用场景，开发中该如何抉择【热度: 395】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/826","page":"q/美团-826.html","excerpt":"在 JavaScript 中，Map和普通的对象（Object）都可以用作键值对的集合，但它们各自的特性和使用场景有所不同。根据这些特性和场景，你可以选择最适合你需求的数据结构。 Object **特性**： 键（key）必须是字符串或符号（Symbol）。 适合少量和简单数据结构的场景，以及当你知道键集合不会经常变化"},{"id":"825","title":"promise 的三种状态分别是什么， 是怎么转换的， 转换时机呢?【热度: 323】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/825","page":"q/美团-825.html","excerpt":"**关键词**：promise 状态 Promise 在 JavaScript 中是一种非常有用的异步编程构造，它代表了一个可能现在、将来或永远都不会完成的操作的结果。每个Promise对象都会经历以下三种状态之一： Promise 的三种状态： **Pending (待定)**: 这是Promise的初始状态，表示异"},{"id":"806","title":"如何减少项目里面 if-else【热度: 310】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/806","page":"q/美团-806.html","excerpt":"**关键词**：减少 if-else 当项目中存在大量的 if-else 语句时，可以考虑以下几种优化方法： 策略模式 创建一组策略对象，每个对象对应一种条件和处理逻辑。根据不同的条件选择相应的策略对象来执行操作。 表驱动法 建立一个数据结构（如对象或数组），将条件与对应的处理函数或值关联起来，通过查找表来获取相应的处"},{"id":"784","title":"前端应用 如何做国际化？【热度: 199】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/784","page":"q/美团-784.html","excerpt":"**关键词**：国际化 前端应用实现国际化（i18n）主要是为了支持多语言环境，提高用户体验。这里有几种常用的方案： **使用国际化库**：这是最常用的方法之一，可以通过引用第三方库来管理不同语言环境的资源文件。比如： **React**：可以使用react-intl或react-i18next。 **Vue**：可以"},{"id":"772","title":"在做 eslint 和 commitlint 的时候， 可以使用 --no-verify 跳过， 这种情况下该如何强制卡点【热度: 233】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/772","page":"q/美团-772.html","excerpt":"**关键词**：commit 与 eslint 规范 跳过eslint和commitlint的钩子，使用--no-verify（对于git commit来说是-n），的确是一个容许开发者在紧急情况下超越钩子检查的手段。然而，这也削弱了代码质量保证的制度。以下是一些方法，可以用来加强这些卡点的靠谱办法： **CI/CD "},{"id":"740","title":"vue 中 Scoped Styles 是如何实现样式隔离的， 原理是啥？【热度: 244】","category":"美团","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/740","page":"q/美团-740.html","excerpt":"**关键词**：Scoped Styles 样式隔离 在 Vue 中，.vue 单文件组件的 <style> 标签可以添加一个 scoped 属性来实现样式的隔离。通过这个 scoped 属性，Vue 会确保样式只应用到当前组件的模板中，而不会泄漏到外部的其他组件中。 这个效果是通过 PostCSS 在构建过程中对 C"},{"id":"739","title":"样式隔离方式有哪些【热度: 683】","category":"美团","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/739","page":"q/美团-739.html","excerpt":"**关键词**：样式个例 样式隔离意味着在一个复杂的前端应用中保持组件的样式私有化，使得不同组件之间的样式不会互相影响。以下是一些在前端开发中实现样式隔离的常见方式： 1. CSS 模块（CSS Modules） CSS 模块是一种在构建时将 CSS 类名局部作用域化的技术。每个类名都是独一无二的，通常通过添加哈希值来"},{"id":"686","title":"应用上线后， 怎么通知用户刷新当前页面？【热度: 466】","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/686","page":"q/美团-686.html","excerpt":"**关键词**：静态资源更新、页面版本更新、服务端推送 **关键词**：静态资源更新、页面版本更新 这个话题非常的有意思，问题的答案是比较开发的，这里仅代表作者本人的个人经验来做回答。 当然也可以自行去搜集掘金上的大佬们的博文。 首先第一个问题 **用户在没有页面刷新的情况下， 如何去感知前端静态资源已经发生了更新？*"},{"id":"619","title":"[React] 如何实现路由守卫【热度: 681】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/619","page":"q/美团-619.html","excerpt":"**关键词**：路由守卫 在 React 中，虽然没有内置的路由守卫（Route Guards）功能，但可以使用第三方库来实现类似的功能。最常用的第三方路由库是 React Router。 React Router 提供了一些组件和钩子函数，可以用于在路由导航过程中进行拦截和控制。 <Route> 组件：可以在路由配置"},{"id":"618","title":"[Vue] 路由守卫【热度: 680】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/618","page":"q/美团-618.html","excerpt":"**关键词**：路由守卫 路由守卫是 Vue Router 提供的一种机制，用于在路由导航过程中对路由进行拦截和控制。通过使用路由守卫，我们可以在路由导航前、导航后、导航中断等不同的阶段执行相应的逻辑。 Vue Router 提供了三种类型的路由守卫： 全局前置守卫（Global Before Guards）：在路由切"},{"id":"617","title":"[Vue] computed 和 watch 有啥区别?【热度: 876】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/617","page":"q/美团-617.html","excerpt":"**关键词**：computed 和 watch 区别 在 Vue 中，computed 和 watch 是两种用于监听和响应数据变化的方式。 computed 是计算属性，它是基于响应式数据进行计算得到的一个新的派生属性。计算属性可以接收其他响应式数据作为依赖，并且只有当依赖数据发生变化时，计算属性才会重新计算。计算"},{"id":"616","title":"[Vue] ref、toRef 和 toRefs 有啥区别？【热度: 128】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/616","page":"q/美团-616.html","excerpt":"**关键词**：ref、toRef、toRefs 区别 在 Vue 3 中，ref、toRef 和 toRefs 是 Vue Composition API 提供的函数，用于处理响应式数据。 ref(value: T): Ref<T>：创建一个响应式数据引用。接收一个初始值作为参数，并返回一个包含该值的响应式引用。Re"},{"id":"584","title":"[React] 从 React 层面上， 能做的性能优化有哪些？【热度: 1,005】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/584","page":"q/美团-584.html","excerpt":"**关键词**：React性能优化 从 React 层面上，可以进行以下性能优化： 使用 memoization（记忆化）：通过使用 React.memo() 或 useMemo() 来避免不必要的重新渲染。这对于纯函数组件和大型组件特别有用。 使用 shouldComponentUpdate 或 PureCompon"},{"id":"516","title":"[性能] 常见性能指标获取方式？【热度: 954】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/516","page":"q/美团-516.html","excerpt":"**关键词**：web性能指标获取 常见性能指标获取方式 相关性能指标问题， 可以看这个文章：$1 **指标所反映的用户体验** 下表概述了我们的性能指标如何对应到我们的问题之上： **开始了吗？** 首次绘制、首次内容绘制 First Paint (FP) / First Contentful Paint (FCP)"},{"id":"515","title":"[性能] 衡量页面性能的指标有哪些？【热度: 1,045】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/515","page":"q/美团-515.html","excerpt":"**关键词**：web性能指标 性能的核心问题 什么样的性能指标最能度量人的感觉？ 怎样才能从我们的真实用户中获取这些指标？ 如何用我们所获取的指标来确定一个页面表现得是否「快」？ 当我们得知用户所感知的真实性能表现后，我们应该如何做才能避免重蹈覆辙，并在未来提高性能表现？ 以用户为中心的性能指标 **开始了吗？** "},{"id":"503","title":"如何判断一个单向链表是否是循环链表?【热度: 975】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/503","page":"q/美团-503.html","excerpt":"**关键词**：循环链表 要判断一个单向链表是否成循环链表，可以使用快慢指针的方法。 快慢指针是两个指针，一个指针每次移动两个节点，另一个指针每次移动一个节点。如果链表中存在循环，那么快指针最终会追上慢指针，两个指针会相遇。 具体的判断过程如下： 初始化快指针和慢指针，都指向链表的头节点。 进入一个循环，每次迭代中，慢"},{"id":"502","title":"浏览器本身是不支持模块化的, webpack 是如何通过文件打包，让浏览器可以读取到前端各个模块的代码的？【热度: 1,153】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/502","page":"q/美团-502.html","excerpt":"**关键词**：webpack模块化、浏览器模块化支持 浏览器本身不支持模块化的特性，无法直接读取和执行模块化的代码。Webpack通过使用一种称为\"模块化打包\"的方式，将模块化的代码转换为浏览器可以执行的形式。 Webpack使用了一个称为\"模块系统\"的机制，通过对模块的依赖关系进行分析，将所有依赖的模块打包为一个或"},{"id":"501","title":"TCP/IP五层协议是什么？【热度: 548】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/501","page":"q/美团-501.html","excerpt":"**关键词**：TCP/IP协议 当提到五层协议时，通常是指TCP/IP模型的五层协议，即物理层、数据链路层、网络层、传输层和应用层。下面是对每一层的详细解释以及一些应用场景的例子： 物理层（Physical Layer）：物理层是网络通信的最底层，它负责传输比特流，将数据从一个节点通过物理介质传输到另一个节点。它包括"},{"id":"477","title":"[React] ref 有哪些使用场景，请举例【热度: 668】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/477","page":"q/美团-477.html","excerpt":"**关键词**：ref 使用场景、ref 获取dom、ref 获取子组件属性和方法 React的ref用于获取组件或DOM元素的引用。它有以下几个常见的使用场景： 访问子组件的方法或属性：通过ref可以获取子组件的实例，并调用其方法或访问其属性。 获取DOM元素：通过ref可以获取组件渲染后的DOM元素，并进行操作。 "},{"id":"435","title":"什么是伪数组、什么是类数组【热度: 1,510】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/435","page":"q/美团-435.html","excerpt":"**关键词**：伪数组、类数组 伪数组（Array-like）和类数组（Array-like Object）都是描述一种类似数组的对象结构，它们在外观和行为上类似于数组，但实际上不是真正的数组。 伪数组（Array-like）： 伪数组是指具有类似数组的结构，但不具备数组的方法和属性的对象。 伪数组对象通常拥有一个 l"},{"id":"402","title":"使用 ajax 封装一个上传文件的函数【热度: 206】","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/402","page":"q/美团-402.html","excerpt":"**关键词**：ajax 上传文件、ajax 上传文件函数、ajax 上传文件封装 下面是一个使用 AJAX 封装的上传文件函数的示例代码： 在上述示例代码中，定义了一个 uploadFile 函数用于上传文件。该函数接收文件对象、上传 URL、进度回调函数、成功回调函数和错误回调函数作为参数。 函数内部通过创建 XM"},{"id":"389","title":"JS 作用域链链接多少?【热度: 882】","category":"美团","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/389","page":"q/美团-389.html","excerpt":"**关键词**：JS 作用域链链、JS 作用域链链应用 概念 JavaScript 作用域链（Scope Chain）是指变量和函数的可访问性和查找规则。它是由多个执行上下文（Execution Context）的变量对象（Variable Object）按照它们被创建的顺序组成的链式结构。 在 JavaScript "},{"id":"373","title":"Babel Polyfill 了解多少【热度: 200】","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/373","page":"q/美团-373.html","excerpt":"**关键词**：Babel Polyfill 原理、Babel Polyfill 作用、Babel Polyfill 使用、Babel Polyfill 按需加载 Babel Polyfill 作用是啥 Babel Polyfill 的作用是在旧版本浏览器中提供对新的JavaScript特性和API的支持。当使用Bab"},{"id":"372","title":"幽灵依赖 是什么","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/372","page":"q/美团-372.html","excerpt":"幽灵依赖 是什么 \"幽灵依赖\"（Ghost Dependency）是指在项目的node_modules目录中存在但未被实际使用的依赖包。 在使用 npm 或者其他包管理工具安装依赖包时，有时会出现安装了一些不需要的或者不正确的依赖包的情况。这些依赖包在项目中没有被显式地引用或使用，但仍然存在于node_modules目"},{"id":"343","title":"[React] createElement 和 cloneElement 有什么区别【热度: 218】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/343","page":"q/美团-343.html","excerpt":"**关键词**：createElement cloneElement createElement 和 cloneElement 有什么区别? React 中的 createElement 和 cloneElement 都可以用来创建元素，但它们用法有所不同。 createElement 用于在 React 中动态地创建"},{"id":"342","title":"Grid 布局了解多少？【热度: 653】","category":"美团","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/342","page":"q/美团-342.html","excerpt":"**关键词**：Grid 布局、Grid 属性 什么是 grid 布局 CSS Grid 布局是 CSS 中的一种新的布局系统，旨在通过 网格（grid）和 行（row）、列（column）的概念来创建灵活的、高效的、响应式网页布局。CSS Grid 布局可以将一个元素的内容划分为多个网格，根据需要，可以在这些网格中定"},{"id":"302","title":"[React] Hooks 有哪些？【热度: 2,594】","category":"美团","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/302","page":"q/美团-302.html","excerpt":"react 16.8 hooks useState useEffect useContext useReducer useMemo useCallback useRef useImperativeHandle useLayoutEffect useDebugValue React v18中的hooks useSyncE"},{"id":"250","title":"如何解决页面请求接口大规模并发问题","category":"美团","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/250","page":"q/美团-250.html","excerpt":"如何解决页面请求接口大规模并发问题， 不仅仅是包含了接口并发， 还有前端资源下载的请求并发。 应该说这是一个话题讨论了； **个人认为可以从以下几个方面来考虑如何解决这个并发问题:** 后端优化：可以对接口进行优化，采用缓存技术，对数据进行预处理，减少数据库操作等。使用集群技术，将请求分散到不同的服务器上，提高并发量。"},{"id":"249","title":"[webpack] 如果解决重复引用 node_modules 里面的不同版本的包(包重复问题)","category":"美团","labels":["工程化","美团"],"url":"https://github.com/pro-collection/interview-question/issues/249","page":"q/美团-249.html","excerpt":"解决重复引用 node_modules 中不同版本的包的问题，可以通过以下几种方式： **1.使用 npm 或者 yarn 的工具进行依赖的版本控制，尽量避免引用不同版本的同一个依赖库**。在 package.json 文件中使用 \"^\"、\"~\"、\">=\" 等方式指定依赖版本，可以有效减少不同版本的包冲突问题。 **2"},{"id":"16","title":"跨域通信的常见方式有哪些?","category":"美团","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/16","page":"q/美团-16.html","excerpt":"常见方式 **JSONP** JSONP是通过动态创建script标签的方式，利用script标签可以跨域请求资源的特性来实现的，本质是利用了script标签没有跨域限制的特性，可以在请求的url后加一个callback参数，后端接收到请求后，将需要传递的数据作为参数传递到callback函数中，前端定义该函数来接收数"},{"id":"1130","title":"less 与 css 有何区别【热度: 214】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1130","page":"q/腾讯-1130.html","excerpt":"**关键词**：less 与 css Less 是 CSS 的预处理器，它在原生 CSS 的基础上扩展了诸多功能，解决了原生 CSS 开发中的痛点（如缺乏变量、复用机制、逻辑处理等）。以下是 Less 与 CSS 的核心区别： **1. 语法与功能** | **特性** | **CSS**（原生） | **Less**"},{"id":"1129","title":"less 与 scss 有何区别【热度: 61】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1129","page":"q/腾讯-1129.html","excerpt":"**关键词**：less 与 scss Less 和 Sass（通常以 SCSS 语法使用）是最流行的两款 CSS 预处理器，都旨在解决原生 CSS 的局限性（如缺乏变量、嵌套、复用机制等），但在语法细节、功能设计和生态上存在诸多差异。以下从核心区别、使用场景等方面详细对比： **一、语法差异** 这是最直观的区别，直"},{"id":"1128","title":"less 有那些高级特性， 驱使你们项目工程去使用它【热度: 336】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1128","page":"q/腾讯-1128.html","excerpt":"**关键词**：less 特性 Less 作为一款流行的 CSS 预处理器，核心价值在于通过**增强 CSS 的可编程性、复用性和可维护性**，简化样式开发流程。除了基础的变量、嵌套语法，它还提供了诸多“高级特性”，这些特性能应对复杂场景（如组件样式封装、主题切换、动态样式计算等）。以下是 Less 核心高级特性的详细"},{"id":"1127","title":"less 是否支持条件判定【热度: 112】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1127","page":"q/腾讯-1127.html","excerpt":"**关键词**：less 条件判定 是的，Less 完全支持条件判定，其核心通过 **when 关键字** 实现，同时可结合比较运算符、逻辑运算符构建复杂的条件逻辑，主要用于动态控制样式规则的生效与否（如根据变量值切换样式、适配不同场景）。 一、核心语法：when 条件判断 Less 的条件判定并非像 JavaScri"},{"id":"1120","title":"微前端架构有哪些主流框架可以选， 各有啥优劣势？【热度: 554】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1120","page":"q/腾讯-1120.html","excerpt":"**关键词**：微前端框架 以下是前端领域主流微前端框架的深度解析，涵盖核心特性、优劣势及适用场景，结合最新技术动态和企业级实践： 一、核心框架对比与选型指南 1. **Qiankun（蚂蚁集团）** **核心特性**： 基于 Single-SPA 封装，支持 React/Vue/Angular 等多框架共存 提供 J"},{"id":"1119","title":"如何对一个大型 SPA（单页应用）进行全面的性能优化？请从构建阶段、运行时、网络请求、渲染等多个维度说明。【热度: 761】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1119","page":"q/腾讯-1119.html","excerpt":"**关键词**：性能优化 对大型 SPA（单页应用）进行全面性能优化需要从多个维度入手，以下是系统性的优化策略： **一、构建阶段优化** **1. 代码分割与懒加载** **动态导入（Dynamic Import）**：按需加载路由组件、组件库、第三方模块 **路由级分割**：按路由拆分 chunks，减少首屏加载体"},{"id":"1086","title":"前端有哪些性能指标？其中：FCP、LCP、TTFB、FID、TTI、CLS、TBT 等， 分别表示什么意思【热度: 393】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1086","page":"q/腾讯-1086.html","excerpt":"**FCP（First Contentful Paint） - 首次内容绘制** **含义**：FCP是指浏览器首次绘制来自DOM的任何内容（如文本、图像、非白色的<canvas>或SVG）的时间点。这是用户体验的一个重要指标，因为它标志着页面开始有实际内容显示给用户，而不仅仅是空白的屏幕。 **重要性**：对于用户来"},{"id":"1085","title":"如何去衡量用户操作过程中否卡顿【热度: 492】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1085","page":"q/腾讯-1085.html","excerpt":"**关键词**：卡顿、性能、用户体验 **使用浏览器性能指标 - FPS（每秒帧数）** **基本原理**：FPS 是衡量页面流畅度的重要指标。在浏览器中，动画和交互的流畅呈现通常依赖于较高的 FPS。一般来说，当 FPS 达到 60 时，用户体验会比较流畅，因为这意味着每秒有 60 帧画面更新，人眼很难察觉到卡顿。如"},{"id":"1084","title":"我使用 vite 打包工程， 输出为 es6 的代码， 但是我依赖的 模块是 es5 commonjs 写的；这个他是怎么处理的【热度: 459】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1084","page":"q/腾讯-1084.html","excerpt":"**关键词**：vite 打包、es6 转 es5 **Vite 的模块解析机制** **概述**：Vite 在打包过程中会对模块进行解析。当遇到 ES6 模块（ESM）和 CommonJS 模块混合的情况时，它会根据模块的类型采用不同的处理策略。Vite 内部的模块解析系统能够识别模块的语法是 ES6 还是 Comm"},{"id":"1025","title":"什么是 semver 规范，~1.2.3 与 ^1.2.3 的版本号范围是多少【热度: 233】","category":"腾讯","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1025","page":"q/腾讯-1025.html","excerpt":"SemVer（Semantic Versioning，语义化版本）是一种规范，用于管理软件版本号的命名和变更。它的目的是通过明确的版本号规则，让开发者和用户能够更好地理解软件的变化和兼容性。 SemVer 版本号由三个部分组成：主版本号（major）、次版本号（minor）和修订版本号（patch），格式为major."},{"id":"1023","title":"JS 浏览器事循环有哪些使用案例？【热度: 526】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1023","page":"q/腾讯-1023.html","excerpt":"**关键词**：事件循环案例 作者备注 这个是一个很好的问题， 大多数人在面试过程中， 大多数都是问到的 - 什么是事件循环 但是真是事件循环的场景可能大多数人不清楚， 所以也就是为了八股而八股。 这个问题很好的问到哪些场景下会使用到事件循环。 是属于原理考虑， 应用也要知道的场景 JavaScript 的事件循环在实"},{"id":"991","title":"部署一个 node 应用要考虑哪些因素【热度: 98】","category":"腾讯","labels":["Nodejs","工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/991","page":"q/腾讯-991.html","excerpt":"**关键词**：node 应用部署 **一、选择服务器和环境** **服务器选择**： 可以选择云服务器提供商（如阿里云、腾讯云、AWS 等）的虚拟服务器或容器服务。根据应用的需求和预算，确定服务器的配置（CPU、内存、存储等）。 考虑服务器的地理位置和网络连接质量，以确保用户能够快速访问应用。 **操作系统**： 常"},{"id":"982","title":"[React] 在 redux 中如何写一个记录状态变更的日志插件【热度: 52】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/982","page":"q/腾讯-982.html","excerpt":"**关键词**：redux 插件 在 Redux 中，可以编写一个日志插件来记录状态的变更。以下是实现的步骤： 创建日志插件函数： 这个函数接收一个 Redux store 对象，返回一个中间件函数。这个中间件函数接收下一个中间件的调用函数next和当前的动作action。 将日志插件添加到 Redux store： "},{"id":"963","title":"站点是如何保持登录状态【热度: 210】","category":"腾讯","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/963","page":"q/腾讯-963.html","excerpt":"**关键词**：http 保持登录态 虽然 HTTP 是无状态协议，但可以通过以下几种方式来保持登录状态： **一、Cookie** 工作原理： 当用户成功登录后，服务器在响应中设置一个 Cookie，通常包含用户的身份标识、会话信息等。 客户端（浏览器）会存储这个 Cookie，并在后续的请求中自动将其发送给服务器。"},{"id":"957","title":"前端需要加载一个大体积的文件时， 一般有哪些优化思路【热度: 594】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/957","page":"q/腾讯-957.html","excerpt":"**关键词**：前端加载文件过大 当前端需要加载大体积文件时，可以从以下几个方面进行优化： **一、文件压缩** **服务器端压缩**： 在服务器上配置文件压缩功能，如使用 Gzip 或 Brotli 压缩算法对文件进行压缩后再传输。这样可以显著减少文件的大小，降低传输时间。 例如，在 Nginx 服务器中，可以通过配"},{"id":"956","title":"前端部署应该要考虑哪些问题【热度: 310】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/956","page":"q/腾讯-956.html","excerpt":"**关键词**：前端部署 在前端部署到生产环境时，有多个关键问题需要解决： **一、高可用性与故障应对** 生产环境中，单点故障是必须考虑的问题。若一台物理机突然崩溃，应用需依然能够正常运行。这时可以了解 Kubernetes（k8s）的 Deployment，它能够有效地应对单点故障，确保应用的高可用性。 **二、热"},{"id":"955","title":"单元测试、E2E 测试有和区别？【热度: 258】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/955","page":"q/腾讯-955.html","excerpt":"**关键词**：前端测试 单元测试（Unit Testing）和端到端测试（End-to-End Testing，E2E Testing）有以下主要区别： **一、测试范围** 单元测试： 聚焦于软件系统的最小可测试单元，通常是函数、方法或类。 只测试单个功能单元的行为，隔离其他部分的影响。 例如，测试一个特定的数学函"},{"id":"954","title":"前端应用有哪些代码测试手段【热度: 385】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/954","page":"q/腾讯-954.html","excerpt":"**关键词**：测试手段 在前端应用中，有以下几种主要的代码测试手段： **一、单元测试** 定义： 针对应用程序中的最小可测试单元（如函数、方法或类）进行的测试。 目的是确保每个独立的单元在各种输入情况下都能正确执行其预期的功能。 常用工具： Jest：一个功能强大且流行的 JavaScript 测试框架，提供了丰富"},{"id":"953","title":"[webpack] tree-shaking 原理【热度: 722】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/953","page":"q/腾讯-953.html","excerpt":"**关键词**：tree-shaking 原理 作者备注 webpack 热门问题 Webpack 的 Tree Shaking 主要是用来消除未被使用的代码，以减小最终打包文件的体积。其原理如下： **一、静态分析** 模块依赖分析： Webpack 在构建过程中，会对项目中的模块进行依赖分析。它会解析每个模块的内容"},{"id":"890","title":"npm run start 的过程是啥，为何能执行对应的命令【热度: 170】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/890","page":"q/腾讯-890.html","excerpt":"**关键词**：npm run start 过程 当你在项目的根目录下执行 npm run start 命令时，实际上触发了一个由 Node.js 包管理器（npm）管理的一系列流程。理解这一过程，可以帮助你更好地掌握项目的构建和开发流程。以下是 npm run start 执行过程的概述： 1. npm run st"},{"id":"885","title":"如何做静态资源预加载【热度: 696】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/885","page":"q/腾讯-885.html","excerpt":"**关键词**：资源预加载 预加载 预加载是指在用户需要数据或资源之前，提前加载这些数据或资源的过程。 这个过程可以提高应用程序或网站的响应速度和用户体验 预加载的优点 **提升加载速度**：通过提前加载资源，用户在访问页面时可以更快地看到完整内容。 **提高用户体验**：减少页面加载时的延迟，使用户感到更流畅。 **"},{"id":"882","title":"websocket 断联之后如何重连，且保证断链期间数据不丢失【热度: 200】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/882","page":"q/腾讯-882.html","excerpt":"**关键词**：websocket 断联数据不丢失 实现 WebSocket 的自动重连并保证断连期间数据不丢失，通常需要在客户端实现一些机制来管理连接状态、定时重试以及缓存未成功发送的消息。以下是一个简单的步骤和策略指南： 1. 监听连接状态 首先，你需要监听 WebSocket 连接的各种事件，以便知道何时发生了断"},{"id":"859","title":"在页面关闭时执行方法，该如何做【热度: 334】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/859","page":"q/腾讯-859.html","excerpt":"**关键词**：beforeunload 和 unload 事件 在页面关闭时执行特定的方法，你可以使用 window 对象的 beforeunload 和 unload 事件。不过，这两个事件有一些微妙的区别和适用场景。 使用 beforeunload 事件 beforeunload 事件在窗口、文档或其资源即将卸载"},{"id":"851","title":"如何统计页面的 long task(长任务)【热度: 140】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/851","page":"q/腾讯-851.html","excerpt":"**关键词**：统计 long task 统计网页中的 LongTask 是性能监控的一部分，特别是在测量和优化页面的响应能力方面非常有用。LongTask API 提供了一种监测浏览器主线程被长时间任务阻塞的能力，这些任务通常会影响用户体验，如使滚动卡顿或延迟输入响应。下面是一些基本步骤，帮助你开始监控 LongTa"},{"id":"831","title":"在低版本的 node 中想使用 es module 该如何做？【热度: 188】","category":"腾讯","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/831","page":"q/腾讯-831.html","excerpt":"**关键词**：node 使用 es module 在低版本的 Node.js 中想要使用 ES Modules (ESM)，你主要有以下几种方法。但是，请注意，这些方法或许涉及到一定程度的实验性特性或依赖第三方工具，可能不会像在高版本 Node.js 中那样稳定。 1. 使用实验性支持 在 Node.js 版本 8."},{"id":"830","title":"node 里面可以使用 es module 吗【热度: 187】","category":"腾讯","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/830","page":"q/腾讯-830.html","excerpt":"**关键词**：node 使用 es module 是的，从 Node.js 的较新版本开始，你可以在 Node.js 中使用 ES Modules（ESM）。 如何启用 ES Modules 要在 Node.js 中使用 ES Modules，你可以采取以下几种方式之一： **使用 .mjs 扩展名**: 你可以将你"},{"id":"829","title":"JS 脚本延迟加载的方式有哪些？【热度: 156】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/829","page":"q/腾讯-829.html","excerpt":"**关键词**：JS 延迟加载、JS 异步加载 JavaScript 脚本的延迟加载是一种优化网页加载时间的技术，可以提高页面的加载速度，提升用户体验。以下是常见的几种 JS 脚本延迟加载的方式： 1. 使用 <script> 标签的 defer 属性 在 <script> 标签中使用 defer 属性可以使得脚本在文"},{"id":"824","title":"手写一个 axios 中间件，支持缓存返回到本地内存【热度: 845】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/824","page":"q/腾讯-824.html","excerpt":"**关键词**：请求缓存 手写一个 axios 中间件， 支持缓存返回到本地内存， 下次同样的请求路径和参数， 直接返回上一次的缓存内容即可， 不需再请求， 同时支持设置自动清除缓存数据的时间。 创建一个简单的 Axios 中间件来支持内存缓存可以大致分为以下步骤： 实现一个缓存管理器，可以存储、检索和删除缓存数据。 "},{"id":"823","title":"axios 是否可以缓存请求返回值到内存里面，下次调用的时候，直接使用内存中的缓存数据？【热度: 884】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/823","page":"q/腾讯-823.html","excerpt":"**关键词**：请求缓存 **Axios 本身没有内置的请求缓存机制**，但你可以通过一些策略手动实现，或者使用第三方库来帮助你实现请求缓存。以下是实现 Axios 请求缓存的两种方法： 方法 1: 手动实现缓存逻辑 你可以通过创建一个缓存对象和一个自定义的 Axios 实例来实现请求的缓存。每次发起请求前，检查缓存对"},{"id":"807","title":"[React] hooks 调用是可以写在 if 语句里面吗【热度: 337】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/807","page":"q/腾讯-807.html","excerpt":"**关键词**：hooks 调用问题 **hooks 写在 if 语句里面， 也是可以执行的， 但是会带来很多不可预期的异常** 在 React 中，Hooks 的调用不应该直接写在 if 语句里面。 Hooks 必须在函数组件的顶层（不在循环、条件判断或嵌套函数中）按顺序调用。这是因为 React 需要在每次渲染时以"},{"id":"805","title":"babel-runtime 作用是啥【热度: 200】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/805","page":"q/腾讯-805.html","excerpt":"**关键词**：babel-runtime 作用 babel-runtime 是一个包含 babel 模块化运行时助手的库。 在使用 babel 进行代码转换时，有时会注入一些在多个文件中相同且可能被重复使用的代码。例如，使用类转换（无松散模式）时，每个包含类的文件都会重复出现类似 _classcallcheck 这样"},{"id":"804","title":"[React] 生态有哪些【热度: 442】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/804","page":"q/腾讯-804.html","excerpt":"**关键词**：React 生态 直接抄作业即可，参考文档如下 https://juejin.cn/post/7297908859175780364"},{"id":"785","title":"如何清理源码里面没有被应用的代码， 主要是 JS、TS、CSS 代码【热度: 329】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/785","page":"q/腾讯-785.html","excerpt":"**关键词**：代码清理 清理源码中未被应用的 JavaScript (JS)、TypeScript (TS) 和 CSS 代码的关键在于合理利用工具和策略，来识别和移除这些废弃的代码。下面是一份指南，帮助你高效完成这一任务： 对于 JavaScript 和 TypeScript 1. 使用 ESLint **初始化 "},{"id":"783","title":"应用如何做应用灰度发布【热度: 247】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/783","page":"q/腾讯-783.html","excerpt":"**关键词**：灰度发布 应用的灰度发布是将新版本逐步推出给有限的用户群体，以在完全发布之前监控其性能和搜集用户反馈的过程。这可以确保新版本的稳健性，减少因新版本可能引起的问题对所有用户的影响。以下是实现应用灰度发布的几种常见方法： 1. 基于 HTTP 头或 Cookie 的路由 通过识别用户的 HTTP 请求头（如"},{"id":"771","title":"如何做  commit lint【热度: 425】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/771","page":"q/腾讯-771.html","excerpt":"**关键词**：commit 规范 Commit lint 是一种实践，用于在代码库中规范化提交信息的格式。这种做法通常有助于团队成员理解代码库的历史记录，以及自动化生成变更日志。下面是实施 Commit lint 的一些基本步骤： **选择 Commit 信息规范：** 首先，你需要选择一个提交信息的规范，最常见的是"},{"id":"770","title":"编写 npm 包的时候，可以办法自动生成 changlog 与自动更新 tag【热度: 455】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/770","page":"q/腾讯-770.html","excerpt":"**关键词**：自动化 changelog 在编写 npm 包时，可以使用自动化工具来生成 changelog 和自动更新 tag。以下是你可以使用的一些流行的工具以及它们的基本用法。 **semantic-release**: 这是一个全自动的版本管理和包发布工具。它能根据 commit 信息来自动决定版本号、生成变"},{"id":"732","title":"[React] react 和 react-dom 是什么关系？【热度: 197】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/732","page":"q/腾讯-732.html","excerpt":"**关键词**：react 和 react-dom 关系 react 和 react-dom 是两个与 React 生态系统密切相关的 npm 包，它们在使用 React 构建用户界面时扮演不同的角色： react react 包含了构建 React 组件所必需的核心功能，例如创建组件类（如 React.Compone"},{"id":"731","title":"[React] Portals 作用是什么， 有哪些使用场景？【热度: 216】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/731","page":"q/腾讯-731.html","excerpt":"**关键词**：React Portals API React Portals 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的方式。通常，组件的渲染输出会被插入到其在组件树中的父组件下，但是 Portals 提供了一种穿透组件层次结构直接渲染到任意 DOM 节点的方法。 React Portals 的作用："},{"id":"725","title":"husky 作用是啥， 有哪些重要配置【热度: 192】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/725","page":"q/腾讯-725.html","excerpt":"**关键词**：husky 作用、husky 配置 Husky 是一个基于 Node 的 Git 钩子管理工具，用于在你的工作流程中强制执行 Git 钩子。Husky 允许你定义脚本，这些脚本会在不同的 Git 生命周期事件触发时自运行，比如在提交、推送或合并前。 使用 Husky 可以： **保证提交质量**：Hus"},{"id":"722","title":"documentFragment api 是什么， 有哪些使用场景？【热度: 115】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/722","page":"q/腾讯-722.html","excerpt":"**关键词**：documentFragment 概念、documentFragment 使用场景 DocumentFragment 是 Web API 中的一部分，它是 DOM （文档对象模型）的一个非常轻量级的节点，代表一组 DOM 节点的集合。它不是一个真实存在于 DOM 中的实体，因此被认为是“没有名字”的节点"},{"id":"687","title":"JS 严格模式作用是啥？【热度: 530】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/687","page":"q/腾讯-687.html","excerpt":"JavaScript的严格模式（\"use strict\"）是一种限制JavaScript语法的方式，目的是为了捕捉一些常见的编码错误，同时阻止或者抛出错误对于一些保险不良行为的使用。它通过在脚本或函数的顶部添加一个特殊的声明来启用，声明如下： 以下是严格模式的一些主要作用： **消除JavaScript语法的一些静默错"},{"id":"678","title":"为什么 Vite 速度比 Webpack 快？【热度: 382】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/678","page":"q/腾讯-678.html","excerpt":"**关键词**：vite 编译速度、vite 速度 与 webpack 速度 1、开发模式的差异 在开发环境中，Webpack 是先打包再启动开发服务器，而 Vite 则是直接启动，然后再按需编译依赖文件。（大家可以启动项目后检查源码 Sources 那里看到） 这意味着，当使用 Webpack 时，所有的模块都需要在"},{"id":"627","title":"[React] 类组件的生命周期， 映射的 hooks 哪些 api ?【热度: 314】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/627","page":"q/腾讯-627.html","excerpt":"**关键词**：生命周期映射 hooks 下面是 React 类组件的生命周期方法和对应的 Hooks API： constructor：useState 可以在函数组件中模拟类组件的 constructor。在函数组件内部使用 useState 声明状态变量，并设置初始值。 componentDidMount：use"},{"id":"625","title":"[Webpack] Webpack vs Vite的核心差异【热度: 820】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/625","page":"q/腾讯-625.html","excerpt":"**关键词**：Webpack vs Vite 差异 **构建速度**: **Webpack**: Webpack的构建速度相对较慢，尤其在大型项目中，因为它需要分析整个依赖图，进行多次文件扫描和转译。 **Vite**: Vite以开发模式下的极速构建著称。它利用ES模块的特性，只构建正在编辑的文件，而不是整个项目。"},{"id":"611","title":"[Webpack] 通过 babel-loader 来编译 tsx 文件， 应该如何配置呢？【热度: 221】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/611","page":"q/腾讯-611.html","excerpt":"如果你想使用 babel-loader 来编译 TypeScript 文件（.tsx），你需要在 babel.config.js 和 webpack.config.js 两个文件中进行相应的配置。 首先，在 babel.config.js 文件中，你需要添加 @babel/preset-typescript 预设，以便"},{"id":"599","title":"[代码实现] 不使用 setTimeout 来实现 setInterval【热度: 231】","category":"腾讯","labels":["腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/599","page":"q/腾讯-599.html","excerpt":"**关键词**：实现setInterval、requestAnimationFrame实现setInterval、setTimeout实现setInterval 如果不使用 setTimeout 来实现 setInterval，可以使用 requestAnimationFrame 函数和时间戳来实现定时循环。下面是实现"},{"id":"598","title":"PM2 部署 nodejs 有哪些优势？【热度: 199】","category":"腾讯","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/598","page":"q/腾讯-598.html","excerpt":"**关键词**：PM2 Nodejs PM2部署Node.js应用程序有以下几个优势： 进程管理和监控：PM2可以自动监控Node.js应用程序的运行状态，并在进程崩溃或无响应时自动重启进程。它还提供了实时的日志输出和监控面板，方便查看和分析应用程序的运行情况。 无缝部署和热重载：使用PM2可以实现无缝部署Node.j"},{"id":"597","title":"http1.1 的 keep-alive 和 http2 的多路复用 有什么区别？【热度: 87】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/597","page":"q/腾讯-597.html","excerpt":"**关键词**：http1.1 keep-alive、http2 多路复用 HTTP/1.1 的 keep-alive 和 HTTP/2 的多路复用是两种不同的技术机制，它们都旨在提高 HTTP 协议的性能和效率，但具有不同的实现方式和特点。 HTTP/1.1 的 keep-alive： 在 HTTP/1.1 中，默认"},{"id":"596","title":"为何 http2 非常快速的就过度到了 HTTP3 ？【热度: 945】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/596","page":"q/腾讯-596.html","excerpt":"**关键词**：http3 HTTP/2 被广泛采用后，HTTP/3 的出现是为了解决一些 HTTP/2 存在的问题以及提升性能。 HTTP/2 在性能方面确实有很大的改进，通过多路复用和头部压缩等特性，可以提高页面加载的速度和效率。然而，HTTP/2 仍然使用了基于 TCP 的传输层协议。TCP 的一些特性，如拥塞控"},{"id":"592","title":"在 webpack 中，通常用于 css 提取的工具是什么？【热度: 269】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/592","page":"q/腾讯-592.html","excerpt":"**关键词**：mini-css-extract-plugin作用、mini-css-extract-plugin使用 **概念** 在 webpack 中，通常使用 mini-css-extract-plugin 来提取 CSS。它是一个独立的插件，可以将 CSS 从 JavaScript 文件中提取出来，生成独立的"},{"id":"591","title":"[React] useLayoutEffect 和 useEffect 有什么区别?【热度: 313】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/591","page":"q/腾讯-591.html","excerpt":"**关键词**：useLayoutEffect 和 useEffect 区别 useLayoutEffect 和 useEffect 的主要区别在于它们执行的时机。 **useLayoutEffect**: useLayoutEffect 是在 DOM 更新完成但在浏览器绘制之前同步执行的钩子函数。它会在 DOM 更新"},{"id":"590","title":"[React] 如何避免不必要的渲染?【热度: 632】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/590","page":"q/腾讯-590.html","excerpt":"**关键词**：react 渲染优化 在 React 中，有几种方法可以避免不必要的渲染，以提高性能和优化应用程序的渲染过程： 使用 PureComponent 或 shouldComponentUpdate 方法：继承 PureComponent 类或在自定义组件中实现 shouldComponentUpdate 方"},{"id":"589","title":"css  module 是什么？【热度: 346】","category":"腾讯","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/589","page":"q/腾讯-589.html","excerpt":"**关键词**：css module 概念、css module 作用 CSS Modules 是一种用于组织和管理 CSS 的技术。它通过在编译时为每个 CSS 类名生成唯一的标识符，并将它们作为 JavaScript 对象的属性导出。这样，可以确保每个类名在整个应用程序中的唯一性，避免样式冲突。 使用 CSS Mo"},{"id":"588","title":"全局样式命名冲突和样式覆盖问题怎么解决？【热度: 772】","category":"腾讯","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/588","page":"q/腾讯-588.html","excerpt":"**关键词**：全局样式命名冲突 在前端开发过程中，有几种常见的方法可以解决全局样式命名冲突和样式覆盖问题： 使用命名空间（Namespacing）：给样式类名添加前缀或命名空间，以确保每个组件的样式类名不会冲突。例如，在一个项目中，可以为每个组件的样式类名都添加一个唯一的前缀，例如.componentA-button"},{"id":"583","title":"[React] 高阶组件理解多少？【热度: 655】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/583","page":"q/腾讯-583.html","excerpt":"**关键词**：什么是React高阶组件、React高阶组件满足的条件、React高阶组件使用场景 **什么是高阶组件** React高阶组件（Higher-Order Component，HOC）是一种用于复用组件逻辑的设计模式。它本质上是一个函数，接受一个组件作为参数，并返回一个新的增强过的组件。 通过使用高阶组件"},{"id":"582","title":"[React] Class Components 和 Function Components 有区别？【热度: 229】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/582","page":"q/腾讯-582.html","excerpt":"**关键词**：Class Components 和 Function Components、Class Components 和 Function Components 区别、Class Components 和 Function Components 差异 **概要对比** Class组件是使用ES6的类语法定义的"},{"id":"581","title":"[React] 构建组件的方式有哪些【热度: 482】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/581","page":"q/腾讯-581.html","excerpt":"**关键词**：React构建组件方式 Class Components（类组件）：使用ES6的类语法来定义组件。类组件继承自React.Component，并通过render方法返回需要渲染的React元素。 Function Components（函数组件）：使用函数来定义组件，函数接收props作为参数，并返回需"},{"id":"549","title":"用户访问页面白屏了， 原因是啥， 如何排查？【热度: 609】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/549","page":"q/腾讯-549.html","excerpt":"**关键词**：白屏处理办法 用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤： 网络问题：用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。 服务端问题：服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和"},{"id":"548","title":"如果用户反馈说感觉网页很卡顿，这个时候该如何排查问题?【热度: 768】","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/548","page":"q/腾讯-548.html","excerpt":"**关键词**：网页卡顿、网页卡顿处理办法 排查网页卡顿问题时，可以按照以下步骤进行处理： 验证用户反馈：首先，确认用户反馈的卡顿问题是否普遍存在，还是个别用户的特殊情况。可以与其他用户进行沟通或观察其他设备上的表现。 检查网络连接：检查用户的网络连接是否稳定。卡顿问题可能由于网络延迟或不稳定导致。可以要求用户进行网络"},{"id":"529","title":"http2 多路复用是什么, 原理是什么【热度: 353】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/529","page":"q/腾讯-529.html","excerpt":"**关键词**：http2多路复用、http2多路复用原理、http2帧和流、http2流的优先级、http2头部压缩 多路复用是指在HTTP/2中，多个请求/响应可以同时在同一个TCP连接上进行传输和处理的机制。 在HTTP/1.1中，每个请求都需要建立一个独立的TCP连接，导致连接的建立和关闭开销很大。而在HTTP"},{"id":"528","title":"HTTP/1.0、HTTP/1.1、HTTP/2和HTTP/3之间的主要区别【热度: 1,447】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/528","page":"q/腾讯-528.html","excerpt":"**关键词**：HTTP各版本之间区别 下面是一个表格，展示了HTTP/1.0、HTTP/1.1、HTTP/2和HTTP/3之间的主要区别： | 特点 | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 | |----------------|------------------------"},{"id":"525","title":"[Vue] 异常处理机制有哪些【热度: 435】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/525","page":"q/腾讯-525.html","excerpt":"**关键词**：vue错误捕获、vue错误边界、vue异常处理、vue errorHandler Vue的错误处理机制主要包括以下几个方面： Error Capturing（错误捕获）：Vue提供了全局错误处理的钩子函数errorCaptured，可以在组件层级中捕获子组件产生的错误。通过在父组件中使用errorCap"},{"id":"524","title":"[Vue] vue3 的 diff 算法是什么，简单介绍一下【热度: 693】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/524","page":"q/腾讯-524.html","excerpt":"**关键词**：vue3 diff 算法、逐层比较和双端比较 Vue3的diff算法是一种用于比较虚拟DOM树之间差异的算法。它用于确定需要更新的部分，以便最小化对实际DOM的操作，从而提高性能。 Vue3的diff算法采用了一种称为\"逐层比较\"的策略，即从根节点开始逐层比较虚拟DOM树的节点。具体的比较过程如下： 对"},{"id":"521","title":"[代码实现] 实现一个可以用for...of遍历的对象【热度: 653】","category":"腾讯","labels":["腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/521","page":"q/腾讯-521.html","excerpt":"**关键词**：for...in遍历、for...of遍历 普通对象因为没有迭代器，所以无法使用for...of遍历，一般使用for...in或者Object.keys()来遍历 但是如果我们手动给对象设置一个迭代器，对象也是可以使用for...of来遍历的;"},{"id":"520","title":"for...of、for...in、for 循环， 三者有什么区别【热度: 1,652】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/520","page":"q/腾讯-520.html","excerpt":"**关键词**：for...in遍历、for...of遍历 以下是 for...of、for...in 和 for 循环的区别对比表格： | 特性 | for...of 循环 | for...in 循环 | for 循环 | |------------------|---------------------------"},{"id":"482","title":"如何搭建一套灰度系统？【热度: 1,226】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/482","page":"q/腾讯-482.html","excerpt":"**关键词**：灰度上线 这个是一个非常复杂的话题， 没法直接给出答案， 进提供一些实现的思路： **什么是灰度** 灰度系统可以把流量划分成多份，一份走新版本代码，一份走老版本代码。 而且灰度系统支持设置流量的比例，比如可以把走新版本代码的流程设置为 5%，没啥问题再放到 10%，50%，最后放到 100% 全量。 "},{"id":"465","title":"[react] 如何合理使用 useContext【热度: 1,326】","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/465","page":"q/腾讯-465.html","excerpt":"**关键词**：合理使用 context 的层级、避免滥用 context、避免context引起重复渲染、优化context重复渲染 如何合理使用 useContext useContext 是 React 中提供的一种跨组件传递数据的方式，可以让我们在不同层级的组件之间共享数据，避免了繁琐的 props 传递过程。"},{"id":"457","title":"JS里的类就是构造函数的语法糖，这个说法是否正确【热度: 541】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/457","page":"q/腾讯-457.html","excerpt":"**关键词**：JS构造函数、JS类的语法糖 这个说法是正确的。 在 JavaScript 中，类实际上是构造函数的语法糖，也就是说，通过类的语法创建的对象和通过构造函数创建的对象是一样的。 例如，下面是一个通过构造函数创建对象的示例： 而使用类的语法创建对象的示例代码如下： 可以看到，使用类的语法创建对象时，实际上是"},{"id":"438","title":"为什么函数的 arguments 参数是类数组而不是数组？【热度: 669】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/438","page":"q/腾讯-438.html","excerpt":"**关键词**：arguments 参数、arguments 参数遍历 在 JavaScript 中，函数的 arguments 参数被设计为类数组对象，而不是真正的数组。这是因为 arguments 对象包含了函数调用时传入的所有参数，包括未命名的参数。它提供了一种方便的方式来访问和操作这些参数。 要遍历类数组对象，"},{"id":"411","title":"什么是文档的预解析【热度: 1,133】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/411","page":"q/腾讯-411.html","excerpt":"**关键词**：文档预解析 文档的预解析（Document Preloading）是浏览器在解析 HTML 文档时的一个优化技术，用于提前获取页面所需的外部资源，如样式表、脚本、字体等。通过在解析过程中预先获取这些资源，可以加快页面加载速度和渲染时间。 浏览器在解析 HTML 文档时，会遇到外部资源的引用，比如 <li"},{"id":"399","title":"304 是什么场景的状态码， 好处和坏处分别是什么【热度: 1,425】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/399","page":"q/腾讯-399.html","excerpt":"**关键词**：304 状态码、缓存响应 HTTP 状态码 304 Not Modified 是在一些特定场景下返回的状态码，用于表示客户端缓存的资源仍然有效，无需重新下载。 好处： 减少了对服务器的请求，节省了带宽和服务器资源。 加快了客户端的加载速度，因为它可以使用缓存的响应而无需等待服务器的响应。 坏处： 如果客"},{"id":"392","title":"[React] react-router 页面跳转时，是如何传递下一个页面参数的？","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/392","page":"q/腾讯-392.html","excerpt":"路由数据 React Router 是一个用于管理前端路由的库，它与 React 应用程序集成在一起，提供了一种在单页面应用中处理路由的方式。React Router 并没有直接提供数据存储的功能，它主要负责路由的匹配和导航。 在 React Router 中，路由相关的数据主要存储在组件的 props 和组件的状态中"},{"id":"385","title":"使用 Promise 实现一个异步流量控制的函数(限制并发数)【热度: 517】","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/385","page":"q/腾讯-385.html","excerpt":"**关键词**：异步流量控制的函数 下面是使用 Promise 实现异步流量控制的函数的示例： 以上示例中的 asyncFlowControl 函数接受一个任务数组 tasks 和一个并发限制 limit，它会按照并发限制逐个执行任务，并返回一个 Promise 对象。在示例中，任务数组中的每个任务都是一个返回 Pro"},{"id":"369","title":"一直在 window 上面挂东西是否有什么风险","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/369","page":"q/腾讯-369.html","excerpt":"在前端开发中，将内容或应用程序运行在浏览器的全局window对象上可能会带来一些潜在的风险。以下是一些需要注意的风险： 命名冲突：window对象是浏览器的全局对象，它包含许多内置属性和方法。如果您在全局命名空间中定义的变量或函数与现有的全局对象属性或方法发生冲突，可能会导致意外行为或错误。 安全漏洞：在全局windo"},{"id":"358","title":"base64 的编码原理是什么","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/358","page":"q/腾讯-358.html","excerpt":"Base64编码是一种用于将二进制数据转换为可打印ASCII字符的编码方式。它的原理如下： 将原始数据划分为连续的字节序列。 将每个字节转换为8位二进制数。 将这些二进制数按照6位一组进行分组，不足6位的用0补齐。 将每个6位的二进制数转换为对应的十进制数。 根据Base64字符表，将十进制数转换为相应的可打印ASCI"},{"id":"353","title":"CSS 选择器有哪些、优先级如何？【热度: 1,183】","category":"腾讯","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/353","page":"q/腾讯-353.html","excerpt":"**关键词**：css 选择器、css 优先级 CSS 选择器有以下几种： 1.元素选择器：通过标签名选择元素，例如：p {}。 2.类选择器：通过 .+类名的形式选择元素，例如：.my-class {}。 3.ID 选择器：通过 #+ID名的形式选择元素，例如：#my-id {}。 4.通配符选择器：通过 * 选择所"},{"id":"333","title":"TCP/IP 如何保证数据包传输的有序可靠【热度: 336】","category":"腾讯","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/333","page":"q/腾讯-333.html","excerpt":"**关键词**：TCP/IP 可靠性、TCP/IP 序列号、TCP/IP 超时 TCP/IP 采用以下几种机制来保证数据包传输的有序可靠： 确认和重传：每当 TCP/IP 协议收到一个数据包时，将向发送方回送一个确认信息。如果接收方未收到数据包，则发送方将重传该数据包。这种确认和重传的机制可以确保数据包能够可靠地传输，"},{"id":"332","title":"DNS 协议了解多少【热度: 712】","category":"腾讯","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/332","page":"q/腾讯-332.html","excerpt":"**关键词**：DNS协议、DNS加速 DNS 基本概念 DNS（Domain Name System，域名系统）是因特网上用于将主机名转换为 IP 地址的协议。它是一个分布式数据库系统，通过将主机名映射到 IP 地址来实现主机名解析，并使用户能够通过更容易识别的主机名来访问互联网上的资源。 在使用 DNS 协议进行主"},{"id":"316","title":"npm 包管理了解多少？【热度: 1,321】","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/316","page":"q/腾讯-316.html","excerpt":"**关键词**：npm 依赖管理、npm 包管理、npm 缓存 **npm 是如何进行依赖管理的？** npm 是通过 package.json 文件来进行依赖管理的。当在项目中使用第三方库时，我们可以在 package.json 中添加对应的依赖项及版本号，npm 会根据 package.json 中的依赖关系，自动"},{"id":"288","title":"[webpack] externals 作用是啥？","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/288","page":"q/腾讯-288.html","excerpt":"webpack 中的 externals 配置项用于指定在打包时需要排除掉的模块，这些模块会被视为外部依赖，即不会被打包进最终的输出文件中，而是通过其他方式引入。 使用 externals 配置项可以使得打包后的代码文件更小，同时也可以在运行时从外部获取依赖，例如通过 CDN、全局变量或者通过 require 的方式等"},{"id":"287","title":"[webpack] 异步加载原理是啥","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/287","page":"q/腾讯-287.html","excerpt":"Webpack 异步加载模块的方式主要有以下几种 使用动态 import: 使用 ES6 的 import() 语法，动态加载模块。 使用 require.ensure: 异步加载模块并将其放置到指定的 chunk 中。 使用 bundle-loader: 将模块放置到一个单独的文件中，按需加载。 使用webpack的"},{"id":"286","title":"[React] 父组件调用子组件的方法","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/286","page":"q/腾讯-286.html","excerpt":"在React中，我们经常在子组件中调用父组件的方法，一般用props回调即可。但是有时候也需要在父组件中调用子组件的方法，通过这种方法实现高内聚。有多种方法，请按需服用。 类组件中 React.createRef() 优点：通俗易懂，用ref指向。 缺点：使用了HOC的子组件不可用，无法指向真是子组件 比如一些常用的写"},{"id":"277","title":"[Vue] watch 和 computed 的区别和理解","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/277","page":"q/腾讯-277.html","excerpt":"**计算属性computed :** 支持缓存，只有依赖数据发生改变，才会重新进行计算，计算属性可用于快速计算视图（View）中显示的属性。这些计算将被缓存，并且只在需要时更新。computed是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed的值在getter执行后是"},{"id":"276","title":"const 和 readonly 的区别","category":"腾讯","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/276","page":"q/腾讯-276.html","excerpt":"TypeScript 中不可变量的实现方法有两种： 使用 ES6 的 const 关键字声明的值类型 被 readonly 修饰的属性 2、TypeScript 中 readonly： TypeScript 中的只读修饰符，可以声明更加严谨的可读属性。通常在 interface 、 Class 、 type 以及 ar"},{"id":"275","title":"枚举和常量枚举的区别","category":"腾讯","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/275","page":"q/腾讯-275.html","excerpt":"枚举和常量枚举（const枚举）：使用枚举可以清晰地表达意图或创建一组有区别的用例 区别： 枚举会被编译时会编译成一个对象，可以被当作对象使用 const 枚举会在 typescript 编译期间被删除，const 枚举成员在使用的地方会被内联进来，避免额外的性能开销 由此可见，使用 常量枚举 会有更好的性能。 定义的"},{"id":"273","title":"ts 中 type 和 interface的区别","category":"腾讯","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/273","page":"q/腾讯-273.html","excerpt":"相同点 都可以描述一个对象或者函数 interface ts 都允许拓展（extends） interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 差异点 **type** type"},{"id":"272","title":"[Vue] vue3 的响应式库是独立出来的，它单独使用的时候是什么效果","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/272","page":"q/腾讯-272.html","excerpt":"vue3 的响应式库是独立出来的，它可以很方便的集成进 React， 作为 React 的状态管理库使用！ 使用示范 定义 store 消费使用 可以看出，store的定义只用到了@vue/reactivity，而rxv只是在组件中做了一层桥接，连通了Vue3和React，正如它名字的含义：React x Vue。 如"},{"id":"271","title":"[Vue] Vue3 的响应式原理?","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/271","page":"q/腾讯-271.html","excerpt":"该话题涉及的相关内容 原理：Proxy、track、trigger 新增属性 遍历后新增 遍历后删除或者清空 获取 keys 删除对象属性 判断属性是否存在 性能 推荐阅读文档： https://juejin.cn/post/6844904122479542285 响应式仓库 Vue3 不同于 Vue2 也体现在源码结"},{"id":"270","title":"小程序的大概原理?","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/270","page":"q/腾讯-270.html","excerpt":"具体流程可以看下面这个图： 要了解小程序架构原理， 要从以下几个方面入手探索 宿主环境 执行环境 小程序整体架构 运行机制 更新机制 数据通信机制 登录机制 性能方向问题 JSCore 具体内容可以参考文档: https://juejin.cn/post/6976805521407868958"},{"id":"269","title":"前端路由的实现原理","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/269","page":"q/腾讯-269.html","excerpt":"在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。 前端路由的实现原理简单来说，就是在不跳转或者刷新页面的前提下，为SPA应用中的每个视图匹配一个特殊的U"},{"id":"261","title":"[Vue] 使用Proxy实现简易的vue双向数据绑定","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/261","page":"q/腾讯-261.html","excerpt":"proxy 的基本使用 可以直接看这个链接： https://github.com/pro-collection/interview-question/issues/8 使用proxy实现数据劫持 关于vue中数据响应式的原理 对数据进行侦测 在vue2.X中，实现一个observe类，对于对象数据，通过Object."},{"id":"242","title":"[Redux] react-redux 是如何更新到 UI 的, 写一下这部分的核心源码","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/242","page":"q/腾讯-242.html","excerpt":"react-redux 和 redux 的关系 Redux 和 React-Redux 是两个独立的库，但它们通常一起使用，因为 Redux 库本身并不针对 React，而是一个通用的状态管理库，而 React-Redux 则是一个用于将 Redux 集成到 React 应用程序中的库。 React-Redux 提供了"},{"id":"241","title":"[Redux] 简单实现一下核心源码","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/241","page":"q/腾讯-241.html","excerpt":"实现 Redux 的源码主要包括以下几个步骤： 实现 createStore 函数，创建 store 对象，该函数接收一个 reducer 函数作为参数，返回一个对象。 在 createStore 函数内部，定义一个 state 变量来存储当前的状态值，定义一个 listeners 数组来存储所有的监听函数。 实现 g"},{"id":"240","title":"[Redux] 的存储过程","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/240","page":"q/腾讯-240.html","excerpt":"Redux 的存储过程可以简单地分为以下几个步骤： Action Creator 函数被调用，生成一个 Action 对象； Action 对象被传递给 Store.dispatch() 方法； Redux Store 调用 Reducer 函数，将当前的 State 和 Action 作为参数传入； Reducer "},{"id":"239","title":"如何在前端团队快速落地代码规范","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/239","page":"q/腾讯-239.html","excerpt":"// todo 待整理 https://juejin.cn/post/7033210664844066853 https://juejin.cn/post/7007419705543622669 https://juejin.cn/post/7167707693333872647 https://juejin.cn/p"},{"id":"238","title":"如何保证用户的使用体验","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/238","page":"q/腾讯-238.html","excerpt":"【如何保证用户的使用体验】这个也是一个较为复杂的话题， 这个也不是问题了， 这个算是话题吧； 主要从以下几个方面思考问题： 性能方向的思考 用户线上问题反馈，线上 on call 的思考 用户使用体验的思考， 交互体验使用方向 提升用户能效方向思考"},{"id":"237","title":"canvas 与 svg 在可视化领域优劣如何","category":"腾讯","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/237","page":"q/腾讯-237.html","excerpt":"SVG、Canvas和WebGL在可视化方向各有优劣，具体如下： **SVG（Scalable Vector Graphics）：** 优势： 矢量图形：SVG 使用矢量图形描述，图形会根据缩放和放大而保持清晰，适用于需要无损放大的情况。 文本处理：SVG 对于文本处理较好，可以方便地添加和编辑文本。 简单图形绘制：S"},{"id":"224","title":"对象取值中 a.b.c.d 和 a['b']['c']['d'] 有何区别？","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/224","page":"q/腾讯-224.html","excerpt":"使用区别 在 JavaScript 中，对象的取值可以使用两种方式，即使用点号（.）和使用方括号（\\[\\]）。对于对象的多层嵌套属性，可以使用两种方式分别取值，例如： 这两种方式获取的结果是相同的，都是 123。其中，使用点号取值的方式称为“点操作符”，使用方括号取值的方式称为“方括号操作符”。 两种方式的区别在于： "},{"id":"222","title":"给定两个数组，写一个方法来计算它们的交集？","category":"腾讯","labels":["JavaScript","腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/222","page":"q/腾讯-222.html","excerpt":"可以使用 ES6 的 Set 数据结构来实现数组交集。 首先，将一个数组转化为 Set，然后遍历另一个数组，将数组中存在于 Set 中的元素存入结果数组中。 以下是一个示例代码： 使用示例： 该算法的时间复杂度为 O(m+n)，其中 m 和 n 分别为两个数组的长度。 Comments / Answers --- **"},{"id":"221","title":"箭头函数为何不能作为构造函数使用？","category":"腾讯","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/221","page":"q/腾讯-221.html","excerpt":"在箭头函数中，this指向的是定义时所在的对象，而不是使用时所在的对象。换句话说，**箭头函数没有自己的this，而是继承父作用域中的this**。 看个例子: person.getName()中this指向函数的调用者，也就是person实例，因此this.name = \"张三\"。 getAge()通过箭头函数定义，"},{"id":"217","title":"[Vue] 响应式原理中 Object.defineProperty 有什么缺陷","category":"腾讯","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/217","page":"q/腾讯-217.html","excerpt":"Vue 2 中使用Object.defineProperty来实现其响应式系统存在一些限制和问题： **深度检测**： Vue 2中对于对象的处理是递归的；对于每个属性，Vue会逐层使用Object.defineProperty将其转换成 getter/setter。这样，当你访问或修改嵌套较深的属性时（如a.b.c）"},{"id":"204","title":"AMD 和 CMD  模块化有和区别？","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/204","page":"q/腾讯-204.html","excerpt":"AMD（Asynchronous Module Definition）和CMD（Common Module Definition）都是JavaScript模块化方案。它们的主要区别在于对依赖的处理方式上不同。 AMD是在require.js推广过程中诞生的，它的特点是提前执行，强调依赖前置。也就是说，在定义模块时就需要"},{"id":"203","title":"前端模块化发展历程？","category":"腾讯","labels":["工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/203","page":"q/腾讯-203.html","excerpt":"前端模块化是指在前端开发中，通过模块化的方式组织代码，将代码按照一定规则分割成不同的模块，便于管理和维护。 前端模块化的发展历程如下： 早期，前端开发采用的是全局变量的方式进行开发，即将所有代码都放在一个文件中，通过全局变量进行交互。这种方式的问题在于，代码量较大，代码耦合度高，不易维护。 后来，前端开发采用了命名空间"},{"id":"1082","title":"前端假如有几十个请求，如何去控制并发【热度: 590】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/1082","page":"q/网络-1082.html","excerpt":"**关键词**：并发请求处理 **使用Promise.allSettled和分批处理**：将请求按并发限制分成小批次，用Promise.allSettled逐批执行，如fetchWithConcurrency函数，通过循环取批次并处理，最后返回所有结果。 **使用队列方式控制并发**：PromiseQueue类通过限制"},{"id":"1057","title":"CDN  是如何决策资源请求的【热度: 300】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/1057","page":"q/网络-1057.html","excerpt":"**关键词**：CDN 资源请求决策 CDN（Content Delivery Network，内容分发网络）通过以下方式决策资源请求： **一、用户请求导向** **DNS 解析引导**： 当用户在浏览器中输入一个网址请求资源时，首先会进行 DNS（Domain Name System，域名系统）查询，将域名解析为对"},{"id":"1056","title":"网络五层模型  具体是指的啥【热度: 116】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/1056","page":"q/网络-1056.html","excerpt":"**关键词**：网络模型 OSI 参考模型 网络五层模型，也称为 OSI（Open System Interconnection，开放系统互连）参考模型，它将计算机网络通信的功能划分为五个层次，每个层次都有特定的功能和职责。以下是五层模型的具体介绍： **一、物理层** 功能： 物理层主要负责在物理介质上传输原始的比特"},{"id":"1048","title":"统计前端请求耗时【热度: 609】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1048","page":"q/网络-1048.html","excerpt":"**关键词**：请求耗时统计 在前端业务中，可以通过以下几种方法统计请求耗时： 初级手段 **一、使用fetch结合时间戳** 在发送请求前记录当前时间戳： const startTime = performance.now(); 使用fetch发送请求： fetch('your-api-url') 在请求的.then"},{"id":"1047","title":"Performance API 主要有哪些应用场景【热度: 431】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1047","page":"q/网络-1047.html","excerpt":"**关键词**：Performance API 应用 Performance API 在前端开发中有很多应用场景，以下是一些主要的方面： **一、性能监测与优化** 测量页面加载时间： 通过performance.timing可以获取页面加载过程中的各个关键时间点，如navigationStart（导航开始时间）、do"},{"id":"1046","title":"弱网检测该如何做【热度: 597】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1046","page":"q/网络-1046.html","excerpt":"**关键词**：网络状况检测 在 JavaScript 中，可以通过以下几种方式进行弱网检测： **一、监测网络连接状态** 使用navigator.onLine属性：这个属性可以判断浏览器是否处于在线状态。当网络连接中断时，navigator.onLine会变为false；当网络连接恢复时，它会变为true。 示例代"},{"id":"995","title":"http3 有哪些核心的新特性【热度: 313】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/995","page":"q/网络-995.html","excerpt":"**关键词**：http3 新特性 HTTP/3 带来了以下一些核心新特性： **一、基于 QUIC 协议** **多路复用无队头阻塞**： HTTP/3 基于 QUIC（Quick UDP Internet Connections）协议，它继承了 QUIC 的多路复用特性。在 HTTP/2 中，虽然也有多路复用，但由"},{"id":"993","title":"304 是什么状态码， 跟哪些 header 有关【热度: 546】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/993","page":"q/网络-993.html","excerpt":"**关键词**：http 状态码 304 是 HTTP 状态码中的“Not Modified”（未修改）状态码。 当客户端（通常是浏览器）向服务器请求资源时，如果服务器判断该资源自上次客户端获取后没有被修改，就会返回 304 状态码，告诉客户端可以使用其本地缓存的版本，而无需再次传输整个资源。 304 状态码主要与以下"},{"id":"992","title":"常见的 http code 4xx 都有哪些状态码【热度: 545】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/992","page":"q/网络-992.html","excerpt":"**关键词**：http 状态码 HTTP 状态码中 4xx 类状态码表示客户端错误。常见的 4xx 状态码有： **一、400 Bad Request（错误请求）** **含义**： 服务器无法理解客户端的请求，通常是由于请求格式错误、参数错误或缺少必要的信息导致的。 例如，请求的 URL 语法错误、请求体格式不正确"},{"id":"986","title":"https 层可以做哪些性能优化【热度: 172】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/986","page":"q/网络-986.html","excerpt":"**关键词**：http 性能优化 以下是在 HTTPS 层可以进行的一些性能优化： **一、优化服务器配置** **选择合适的加密套件**： 服务器可以配置支持的加密套件。优先选择性能较好且安全的加密算法组合，如具有高效加密和认证的椭圆曲线密码（ECC）算法及现代的对称加密算法（如 AES-GCM）。避免使用老旧、性"},{"id":"985","title":"https 加密协议里面: TLS 和 SSL 分别是什么，有何区别【热度: 51】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/985","page":"q/网络-985.html","excerpt":"**关键词**：TLS/SSL 概念、TLS/SSL 区别 在 HTTPS 加密协议中，TLS（Transport Layer Security，传输层安全协议）和 SSL（Secure Sockets Layer，安全套接字层）都是为了实现网络通信安全而设计的协议，它们的主要情况如下： **一、SSL** **定义与"},{"id":"984","title":"HTTPS 安全协议主要是啥【热度: 779】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/984","page":"q/网络-984.html","excerpt":"**关键词**：安全协议 HTTPS（Hypertext Transfer Protocol Secure）安全协议主要包括以下几个关键方面： **一、加密通信** **TLS/SSL 加密**： HTTPS 使用传输层安全（TLS）或安全套接层（SSL）协议对数据进行加密。这确保了在客户端（如浏览器）和服务器之间传输"},{"id":"974","title":"如果 cookie 没有设置  maxage， 那么这一条 cookie 失效时间改怎么算【热度: 42】","category":"网络","labels":["网络","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/974","page":"q/网络-974.html","excerpt":"**关键词**：cookie 失效时间 如果 Cookie 没有设置 max-age，它通常被视为会话 Cookie，其失效时间的计算方式如下： **一、会话 Cookie 的失效时间** 浏览器关闭时：一般情况下，当用户关闭浏览器时，会话 Cookie 会被删除。这意味着只要浏览器处于打开状态，并且用户在与同一个网站"},{"id":"973","title":"https 中如何保证证书是可信任的【热度: 210】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/973","page":"q/网络-973.html","excerpt":"**关键词**：https 证书可信保证 在 HTTPS 中，保证证书是可信任的主要通过以下几个方面实现： **一、证书颁发机构（CA）的信任体系** **根证书的信任**： 操作系统和浏览器内置了一些受信任的根证书颁发机构（Root CA）的证书。这些根证书是整个信任体系的基础。 当浏览器接收到一个服务器的 SSL/"},{"id":"972","title":"http2 中的首部压缩是什么","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/972","page":"q/网络-972.html","excerpt":"作者备注 作者看到有问题是：「请说说 http2 瘦不压缩原理」， 然后才有了这个问题。 但是作者觉得， 没有事实意义，当做科普即可。 在 HTTP/2 中，首部压缩是一项重要的特性，它主要是为了减少在网络传输中重复的首部信息所占用的带宽，从而提高网络传输效率。 **一、为什么需要首部压缩** 在 HTTP/1.1 中"},{"id":"971","title":"完整域名的构成部分","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/971","page":"q/网络-971.html","excerpt":"完整域名由多个部分组成，主要包括以下几个部分： **一、顶级域名（Top-Level Domain，TLD）** **含义**： 顶级域名是域名中最右边的部分，它表示域名的类型或所属的国家或地区。例如，在“example.com”中，“.com”就是顶级域名。 顶级域名分为通用顶级域名（gTLD）和国家代码顶级域名（c"},{"id":"969","title":"http 缓存中 no-cache 与 no-store 的区别是什么【热度: 564】","category":"网络","labels":["网络","web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/969","page":"q/网络-969.html","excerpt":"**关键词**：http 缓存 在 HTTP 缓存中，no-cache和no-store是两种不同的缓存指令，它们的区别如下： **一、no-cache** **含义**： 当设置了no-cache指令时，这并不意味着不使用缓存。相反，它表示在使用缓存之前，必须先与服务器进行验证，以确定缓存的资源是否仍然有效。 这意味"},{"id":"967","title":"http 缓存 header 中的 Date 与 Last-Modified 有什么不同【热度: 276】","category":"网络","labels":["网络","web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/967","page":"q/网络-967.html","excerpt":"**关键词**：http 缓存 header 在 HTTP 响应头中，Date和Last-Modified有以下不同： **一、含义不同** Date：表示消息产生的时间。服务器用这个时间来标记响应报文的生成时间，它反映了服务器生成响应的时刻。例如，“Mon, 07 Oct 2024 12:34:56 GMT”，这个时"},{"id":"966","title":"http 向 https 做重定向应该使用哪个状态码【热度: 336】","category":"网络","labels":["网络","web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/966","page":"q/网络-966.html","excerpt":"**关键词**：重定向 从 HTTP 向 HTTPS 做重定向，既可以使用 301 永久重定向状态码，也可以使用 302 临时重定向状态码。以下是对这两种状态码的具体介绍及使用场景分析： **301 永久重定向**： **含义**：表示请求的资源已被永久地移动到了新的 URL，搜索引擎等客户端会更新其索引，将旧的 UR"},{"id":"965","title":"http header content-type 为 application/octet-stream，则代表什么意思【热度: 136】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/965","page":"q/网络-965.html","excerpt":"**关键词**：header content-type 在 HTTP 响应头中，如果Content-Type为application/octet-stream，代表以下含义： **一、数据类型含义** **通用二进制流**： application/octet-stream表示这是一个通用的二进制流数据。它没有特定的格"},{"id":"964","title":"http 静态文件缓存 Last-Modified 是根据什么生成的【热度: 85】","category":"网络","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/964","page":"q/网络-964.html","excerpt":"**关键词**：静态文件缓存 作者备注 冷门， 当做只是了解即可 在 HTTP 服务中，静态文件的Last-Modified（最后修改时间）通常是根据以下几个因素生成的： **一、文件系统的修改时间** **来源**： 服务器在提供静态文件时，通常会读取文件所在文件系统中的最后修改时间作为Last-Modified的值"},{"id":"963","title":"站点是如何保持登录状态【热度: 210】","category":"网络","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/963","page":"q/网络-963.html","excerpt":"**关键词**：http 保持登录态 虽然 HTTP 是无状态协议，但可以通过以下几种方式来保持登录状态： **一、Cookie** 工作原理： 当用户成功登录后，服务器在响应中设置一个 Cookie，通常包含用户的身份标识、会话信息等。 客户端（浏览器）会存储这个 Cookie，并在后续的请求中自动将其发送给服务器。"},{"id":"962","title":"http ETag 值改变了，是否意味着文件内容一定已经更改【热度: 138】","category":"网络","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/962","page":"q/网络-962.html","excerpt":"**关键词**：ETag 值 如果 HTTP 响应头中的 ETag 值改变了，通常意味着资源（文件或其他内容）很可能发生了变化，但并不绝对意味着文件内容一定已经更改。 **一、可能导致 ETag 变化但文件内容未更改的情况** 生成方式的变化： 如果服务器更改了生成 ETag 的方式，即使文件内容没有变化，ETag 也"},{"id":"950","title":"axios 如何取消请求【热度: 218】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/950","page":"q/网络-950.html","excerpt":"**关键词**：axios 取消请求 作者备注 新版本已经废弃使用 cancelToken ，改为使用 signal 可以参考官网：https://axios-http.com/docs/cancellation 取消请求 timeout在 axios 调用中设置属性**可处理响应**相关的超时。 在某些情况下（例如网"},{"id":"949","title":"axios 如何注销拦截器【热度: 140】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/949","page":"q/网络-949.html","excerpt":"**关键词**：axios 拦截器 作者备注 这个问题稍微有点儿偏冷门， 需要阅读过 axios 官网才能正确作答， 考察的是同学自驱型学习能力 在 Axios 中，可以使用以下方法注销拦截器： **一、为拦截器分配一个引用** 创建拦截器时保存引用： 当创建一个 Axios 请求或响应拦截器时，可以将其分配给一个变量"},{"id":"948","title":"给 axios 做一个通用拦截器，实现功能为状态码非 200 的时候，统一拦截错误， 提示一个 toast, 该如何实现【热度: 339】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/948","page":"q/网络-948.html","excerpt":"**关键词**：axios 拦截器 作者备注 拦截器是 axios 的最核心功能之一， 该问题只是考察 axios 的核心功能的基本使用 以下是使用 Axios 的拦截器来实现当状态码非 200 时统一拦截错误并提示 toast 的方法： 假设你使用了一个名为 toast 的函数来显示 toast 消息，这个函数可以根"},{"id":"947","title":"想设置 axios 全局通用配置， 有哪些方法【热度: 298】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/947","page":"q/网络-947.html","excerpt":"**关键词**：axios 配置 在 Axios 中，可以通过以下几种方法设置全局通用配置： **一、使用axios.defaults** 直接设置属性： 可以直接在axios.defaults上设置各种配置属性，如baseURL、timeout、headers等。这些设置将应用于所有后续的 Axios 请求。 设置t"},{"id":"946","title":"解释下 axios withCredentials 配置【热度: 197】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/946","page":"q/网络-946.html","excerpt":"**关键词**：axios 配置 作者备注 这个问题太冷门了， 如果不是细看过顾问囊的人， 是不会知道有这个配置项的。 可以当做科普即可， 面试中问到的可能性也非常的低。 在 Axios 中，withCredentials是一个配置选项，用于处理跨源请求时是否携带用户凭证（cookies、HTTP 认证信息等）。 **"},{"id":"945","title":"axios 支持哪些常用的配置【热度: 196】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/945","page":"q/网络-945.html","excerpt":"**关键词**：axios 配置 作者备注 这个其实直接看官网即可 https://axios-http.com/docs/req_config 以下是翻译的全配置"},{"id":"942","title":"axios 有哪些特性【热度: 147】","category":"网络","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/942","page":"q/网络-942.html","excerpt":"**关键词**：axios 特性 作者备注 以下特性信息都是直接来自于官网 https://axios-http.com/docs/intro 但是可能很多同学并不会去好好看官网， 所以这个问题， 只是考察同学们的学习主动性 从浏览器发出 XMLHttpRequests 从 node.js 发出 http 请求 支持 "},{"id":"895","title":"http 的 请求和 响 应报文分 别是什么样的","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/895","page":"q/网络-895.html","excerpt":"HTTP（HyperText Transfer Protocol，超文本传输协议）的请求和响应报文都遵循特定的格式。理解这些格式对于开发 Web 应用和 API 非常重要。以下是 HTTP 请求和响应报文的一般结构： HTTP 请求报文 HTTP 请求报文由三个主要部分组成：请求行、请求头部（Headers）、消息主体"},{"id":"894","title":"http的请求和响应报文 有啥区别","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/894","page":"q/网络-894.html","excerpt":"作者备注 可以当做一个科普来看， 单纯的八股， 没有实际价值， 所以不做评分 HTTP 请求和响应报文都遵循类似的结构，但它们服务于通信过程中的不同阶段，并具有一些关键的区别。下面是请求和响应报文之间的主要区别： 结构上的区别 **请求行 vs 状态行**： **请求报文**的第一行是**请求行**，包含了方法（如 G"},{"id":"893","title":"http 常见的几个重定向 code 是多少，区别是啥【热度: 172】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/893","page":"q/网络-893.html","excerpt":"**关键词**：http 重定向 code HTTP 重定向是指当客户端访问一个页面时，服务器返回一个重定向状态码，告诉客户端去访问另一个 URL。常见的 HTTP 重定向状态码有以下几种，每个状态码都有其特定的意义和使用场景： 1. **301 Moved Permanently（永久移动）** **含义**：请求的"},{"id":"892","title":"http 的请求和响应都有哪些传输数据格式【热度: 149】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/892","page":"q/网络-892.html","excerpt":"**关键词**：http 传输格式 HTTP（超文本传输协议）是一种用于传输超媒体文档（如 HTML）的应用层协议。在 HTTP 请求和响应中，可以传输多种数据格式。这些数据格式主要通过 HTTP 头部中的Content-Type字段来指定。下面是一些常见的 HTTP 传输数据格式： 1. 文本格式 **text/pl"},{"id":"891","title":"发送请求的时候， method = OPTIONS 是什么请求【热度: 717】","category":"网络","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/891","page":"q/网络-891.html","excerpt":"**关键词**：预检请求 当看到 method 为 OPTIONS 的请求时，这是一个 HTTP OPTIONS 请求。OPTIONS 请求是 HTTP/1.1 协议中定义的一种方法，用于获取目的资源（服务器）支持的通信选项。这种请求主要被用于 CORS（Cross-Origin Resource Sharing，跨域"},{"id":"875","title":"请求数量过多，该如何治理【热度: 418】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/875","page":"q/网络-875.html","excerpt":"**关键词**：治理请求数量 作者备注 很多同学我有 http2 ， 可以多路复用， 所以请求再多都不会影响页面性能。 实际上是错误的。 在作者知道的很多超大型项目（千万行级别的项目）里面， 太多的网络并发（首屏可能就有好大几百的请求发出去）， 会因为 IO 问题到时吃掉很多的 CPU 与网络带宽， 用户依然会觉得非常"},{"id":"857","title":"可有办法判断用户的网络条件, 判断网速快慢，网络状态？【热度: 195】","category":"网络","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/857","page":"q/网络-857.html","excerpt":"**关键词**：网络状态 确定用户的网络条件，包括网络速度和连接状态，对于提供优质用户体验至关重要。以下是一些方法可以帮助你判断用户的网络条件： 1. **Navigator Connection API** 这个 API 提供有关系统的网络连接的信息，如网络的类型和下载速度。这个 API 的支持度不是全局性的，但在许"},{"id":"848","title":"介绍一下 fetch 请求 keepalive 属性【热度: 112】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/848","page":"q/网络-848.html","excerpt":"**关键词**：fetch keepalive 属性 keepalive 选项在 fetch 请求中的作用主要是允许在浏览器即将关闭或者用户即将离开当前页面时，仍然能够成功发送网络请求。这个选项的设计初衷是为了处理那些需要在页面生命周期结束时发送的统计或追踪数据的场景，比如用户的行为追踪数据、性能数据等。 keepal"},{"id":"824","title":"手写一个 axios 中间件，支持缓存返回到本地内存【热度: 845】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/824","page":"q/网络-824.html","excerpt":"**关键词**：请求缓存 手写一个 axios 中间件， 支持缓存返回到本地内存， 下次同样的请求路径和参数， 直接返回上一次的缓存内容即可， 不需再请求， 同时支持设置自动清除缓存数据的时间。 创建一个简单的 Axios 中间件来支持内存缓存可以大致分为以下步骤： 实现一个缓存管理器，可以存储、检索和删除缓存数据。 "},{"id":"823","title":"axios 是否可以缓存请求返回值到内存里面，下次调用的时候，直接使用内存中的缓存数据？【热度: 884】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/823","page":"q/网络-823.html","excerpt":"**关键词**：请求缓存 **Axios 本身没有内置的请求缓存机制**，但你可以通过一些策略手动实现，或者使用第三方库来帮助你实现请求缓存。以下是实现 Axios 请求缓存的两种方法： 方法 1: 手动实现缓存逻辑 你可以通过创建一个缓存对象和一个自定义的 Axios 实例来实现请求的缓存。每次发起请求前，检查缓存对"},{"id":"810","title":"axios 请求的底层依赖是什么？【热度: 266】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/810","page":"q/网络-810.html","excerpt":"**关键词**：axios 请求依赖 Axios 的底层依赖会根据运行环境而有所不同： 在浏览器环境中，Axios 通常会优先使用 XMLHttpRequest 对象来发送请求。但它也可以使用 fetch API （如果浏览器支持）。 在 Node.js 环境中，Axios 依赖于 Node.js 的 http 或 h"},{"id":"809","title":"ajax 和 xhr 是什么关系？【热度: 332】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/809","page":"q/网络-809.html","excerpt":"**关键词**：ajax 和 xhr **Ajax** 全称为 Asynchronous JavaScript and XML（异步 JavaScript 和 XML），是一种在不重新加载整个网页的情况下，与服务器进行数据交换并更新部分网页内容的技术方法。 Ajax 主要基于以下几个关键概念和技术： 异步通信：允许网页"},{"id":"797","title":"浏览器有同源策略， 但是为何 cdn 请求资源的时候不会有跨域限制【热度: 579】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/797","page":"q/网络-797.html","excerpt":"**关键词**：同源策略、跨域限制 同源策略是啥 浏览器的同源策略（Same-origin policy）是一种重要的安全机制，用于限制不同源的文档或脚本之间的交互操作。 “源”（origin）由三部分组成：协议（protocol）、域名（domain）和端口（port）。如果两个 URL 的协议、域名和端口都完全相同"},{"id":"796","title":"cookie 可以实现不同域共享吗【热度: 533】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/796","page":"q/网络-796.html","excerpt":"**关键词**：cookie 共享 通常，Cookie不能直接在不同域间共享，这源于浏览器同源策略，该策略由协议、域名和端口号共同界定“源”，只有三者完全相同才属同源，Cookie才能在其间共享。但在特定条件和技术手段下，可实现不同域间一定程度的Cookie共享，同时，Cookie也能设置为在同主域下的子域间共享，具体"},{"id":"795","title":"axios 是否可以取消请求【热度: 532】","category":"网络","labels":["网络","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/795","page":"q/网络-795.html","excerpt":"**关键词**：取消请求 Axios 可以取消请求。官方文档指出有两种方法可以取消请求，分别是cancelToken和AbortController，示例代码如下： 使用cancelToken的方法一： 使用 cancelToken的方法二： 使用AbortController： 通过文档描述和示例代码，可以总结出以下"},{"id":"733","title":"什么是DNS劫持？【热度: 165】","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/733","page":"q/网络-733.html","excerpt":"**关键词**：DNS劫持 DNS 劫持（DNS Hijacking），也称为 DNS 重定向，是一种通过篡改原本的 DNS 解析流程，使得用户在尝试访问特定网址时被非法重定向到其他（通常是恶意的、广告相关的或者钓鱼的）网站的行为。这种攻击可以发生在用户的个人电脑、网络设备、甚至是直接在 DNS 服务器上。 DNS 劫"},{"id":"696","title":"浏览器对队头阻塞有什么优化？【热度: 368】","category":"网络","labels":["网络","浏览器","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/696","page":"q/网络-696.html","excerpt":"**关键词**：队头阻塞优化 队头阻塞（Head-of-Line Blocking，缩写 HoLB）问题主要发生在网络通信中，特别是在使用 HTTP/1.1 和以前版本时，在一个 TCP 连接中同一时间只能处理一个请求。即使后续的请求已经准备好在客户端，它们也必须等待当前处理中的请求完成后才能被发送。这会延迟整个页面或"},{"id":"680","title":"HTTP是一个无状态的协议，那么Web应用要怎么保持用户的登录态呢？【热度: 1,092】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/680","page":"q/网络-680.html","excerpt":"**关键词**：登录状态问题 涉及到的几个知识点: cookie，session，token(json web token,jwt)的区别 node 中 jwt 的应用 直接参考文档即可： https://juejin.cn/post/7356788983483842587"},{"id":"676","title":"列表分页， 快速翻页下的竞态问题【热度: 444】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/676","page":"q/网络-676.html","excerpt":"**关键词**：翻页场景竞态问题 **列表分页， 快速翻页下的竞态问题** 问题描述：比如在前端分页请求的时候， 因为翻页很快， 所以请求还没有来得及回来的时候， 就发起了下一次请求， 且请求返回的时间也是不固定的。 如何保证最后一次请求结果和其请求页码是对应上的。 在处理这种情况时，一种常见的方法是使用请求标记或唯一"},{"id":"675","title":"CORS 请求中，是如何触发预检请求【热度: 229】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/675","page":"q/网络-675.html","excerpt":"**关键词**：CORS 预检请求条件 其动机是，HTML 4.0 中的 <form> 元素（早于跨站 XMLHttpRequest 和 fetch）可以向任何来源提交简单请求，所以任何编写服务器的人一定已经在保护跨站请求伪造攻击（CSRF）。 在这个假设下，服务器不必选择加入（通过响应预检请求）来接收任何看起来像表单"},{"id":"674","title":"http 中 HSTS 是什么【热度: 374】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/674","page":"q/网络-674.html","excerpt":"**关键词**：http HSTS HTTP Strict-Transport-Security（HSTS）是一种安全策略，它通过 HTTP 头部告诉浏览器只能通过安全的 HTTPS 连接访问网站，从而增加网站的安全性。HSTS 有助于防止恶意攻击者通过中间人攻击（如SSL剥离攻击）窃取敏感信息。 HSTS 的主要作用"},{"id":"673","title":"http 中 CSP 是什么【热度: 323】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/673","page":"q/网络-673.html","excerpt":"**关键词**：http CSP 在 HTTP 协议中，CSP 指的是 \"Content Security Policy\"（内容安全策略）。CSP 是一种用于增强网站安全性的安全策略机制，通过指定浏览器只能加载指定来源的资源，以减少恶意攻击的风险。 CSP 的主要目标是防止和减缓特定类型的攻击，例如跨站脚本攻击 (XS"},{"id":"671","title":"grpc 和 protobuf 是什么关系？【热度: 320】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/671","page":"q/网络-671.html","excerpt":"gRPC（gRPC Remote Procedure Call）和 Protocol Buffers（protobuf）有密切的关系，可以理解为它们之间是一种上下游的关系： **Protocol Buffers（protobuf）：** 这是一种由 Google 设计的数据序列化格式，用于结构化数据的序列化和反序列化。"},{"id":"669","title":"常见网络协议有哪些【热度: 724】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/669","page":"q/网络-669.html","excerpt":"**关键词**：网络协议 | 协议 | 层次 | 说明 | | ------------- | ------- | ----------------------------------------------------- | | HTTP/HTTPS | 应用层 | 用于在 Web 浏览器和 Web 服务器之间传输超"},{"id":"667","title":"Protobuf 相关知识【热度: 216】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/667","page":"q/网络-667.html","excerpt":"**关键词**：Protobuf 基本概念 Protobuf（Protocol Buffers）是由 Google 开发的一种轻量级、高效的数据交换格式，它被用于结构化数据的序列化、反序列化和传输。相比于 XML 和 JSON 等文本格式，Protobuf 具有更小的数据体积、更快的解析速度和更强的可扩展性。 Prot"},{"id":"660","title":"请求 Header 的 Content-Type 常见的有哪几种?【热度: 617】","category":"网络","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/660","page":"q/网络-660.html","excerpt":"**关键词**：请求 header Content-Type、header Content-Type 参数类型 **常见的请求Content-Type有以下几种**： application/x-www-form-urlencoded：用于URL编码的表单数据，数据以键值对的形式发送。 multipart/form-d"},{"id":"653","title":"需要在跨域请求中携带另外一个域名下的 Cookie 该如何操作？【热度: 254】","category":"网络","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/653","page":"q/网络-653.html","excerpt":"**关键词**：跨域 cookie 在跨域请求中携带另外一个域名下的 Cookie，需要通过设置响应头部的Access-Control-Allow-Credentials字段为true，并且请求头部中添加withCredentials字段为true。 在服务端需要设置响应头部的Access-Control-Allow-"},{"id":"643","title":"http code 中 301 和 302 有啥区别？【热度: 721】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/643","page":"q/网络-643.html","excerpt":"**关键词**：http code 码 在 HTTP 协议中，301和302是两种重定向状态码。它们的区别如下： 301 Moved Permanently (永久重定向)：当服务器返回301状态码时，表示所请求的资源已经被永久移动到了一个新的位置。浏览器在接收到301响应后，会自动将请求的 URL 地址更新为新的位置"},{"id":"642","title":"前端如何设置请求超时时间 timeout(axios)【热度: 890】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/642","page":"q/网络-642.html","excerpt":"**关键词**：请求超时时间 **1. axios全局设置网络超时** axios.defaults.timeout = 10 * 1000; // 10s **2. 单独对某个请求设置网络超时** axios.post(url, params, {timeout: 1000}) .then(res => { cons"},{"id":"597","title":"http1.1 的 keep-alive 和 http2 的多路复用 有什么区别？【热度: 87】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/597","page":"q/网络-597.html","excerpt":"**关键词**：http1.1 keep-alive、http2 多路复用 HTTP/1.1 的 keep-alive 和 HTTP/2 的多路复用是两种不同的技术机制，它们都旨在提高 HTTP 协议的性能和效率，但具有不同的实现方式和特点。 HTTP/1.1 的 keep-alive： 在 HTTP/1.1 中，默认"},{"id":"596","title":"为何 http2 非常快速的就过度到了 HTTP3 ？【热度: 945】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/596","page":"q/网络-596.html","excerpt":"**关键词**：http3 HTTP/2 被广泛采用后，HTTP/3 的出现是为了解决一些 HTTP/2 存在的问题以及提升性能。 HTTP/2 在性能方面确实有很大的改进，通过多路复用和头部压缩等特性，可以提高页面加载的速度和效率。然而，HTTP/2 仍然使用了基于 TCP 的传输层协议。TCP 的一些特性，如拥塞控"},{"id":"575","title":"XHR 和 Fetch 是否支持取消请求【热度: 122】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/575","page":"q/网络-575.html","excerpt":"**关键词**：XHR 取消请求、Fetch 取消请求 **XHR 支持取消请求** XHR（XMLHttpRequest）对象支持取消请求。你可以使用 xhr.abort() 方法来取消正在进行的请求。 下面是一个使用 XHR 取消请求的示例代码： 使用 xhr.abort() 方法会导致 XHR 请求被中止，并触发"},{"id":"574","title":"axios 是如何区分是 nodejs 环境还是 浏览器环境 的？【热度: 113】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/574","page":"q/网络-574.html","excerpt":"**关键词**：nodejs与浏览器环境判定 Axios 是一个跨平台的 HTTP 客户端库，可以在浏览器和 Node.js 中使用。Axios 通过判断当前环境来确定是在浏览器还是在 Node.js 环境中运行。 在浏览器环境中，Axios 默认会使用浏览器提供的 XMLHttpRequest 对象来发送 HTTP "},{"id":"573","title":"axios 有哪些特性？【热度: 464】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/573","page":"q/网络-573.html","excerpt":"**关键词**：axios特性 直接可以参考官网链接： https://axios-http.com/docs/intro 特点 从浏览器创建XMLHttpRequest 从node.js生成http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 超时时间 支持嵌套项的查询参数序列化 "},{"id":"572","title":"如何拦截 web 应用的请求【热度: 487】","category":"网络","labels":["网络","快手"],"url":"https://github.com/pro-collection/interview-question/issues/572","page":"q/网络-572.html","excerpt":"**关键词**：web前端监听请求、前端拦截请求 在前端拦截和处理 Web 应用的所有请求，可以使用以下方法： **使用 Fetch 或 XMLHttpRequest**：在前端代码中使用 Fetch API 或 XMLHttpRequest 对象发送请求。通过拦截 Fetch 或 XMLHttpRequest 对象的"},{"id":"566","title":"https 如何保证安全的？【热度: 782】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/566","page":"q/网络-566.html","excerpt":"**关键词**：https 安全性 HTTPS相比HTTP更安全的原因主要有以下几点： 数据传输加密：HTTPS使用SSL/TLS协议对数据进行加密传输，通过使用对称密钥加密传输数据，并使用非对称密钥进行身份验证和密钥交换。这意味着即使攻击者截获了数据包，也无法解密其中的内容。 身份验证和数据完整性：HTTPS使用数字"},{"id":"536","title":"http 请求中 GET 和 POST 有什么区别【热度: 505】","category":"网络","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/536","page":"q/网络-536.html","excerpt":"**关键词**：GET 和 POST 区别 | | GET请求 | POST请求 | | --- | --------------------------------------------------------- | -------------------------------------------------"},{"id":"535","title":"如何实现大文件断点续传【热度: 897】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/535","page":"q/网络-535.html","excerpt":"**关键词**：文件上传断点续传 前端实现断点续传一般涉及到以下几个步骤： 分片上传：将大文件分割成多个小的文件块。可以使用 JavaScript 的 File 对象的 slice 方法来实现分片。 上传文件块：使用 XMLHttpRequest 或 Fetch API 发送每个文件块到服务器。可以将每个文件块的索引、"},{"id":"534","title":"长连接了解多少【热度: 567】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/534","page":"q/网络-534.html","excerpt":"**关键词**：http 长连接过程 HTTP/1.1 的长连接（Keep-Alive）是一种机制，使客户端和服务器在同一连接上可以发送和接收多个 HTTP 请求和响应。它的原理如下： 客户端发送请求：当客户端发起一个 HTTP 请求时，在请求头中会包含一个 Connection 字段，标识这个连接是否需要保持持久连接"},{"id":"532","title":"什么是 JWT【热度: 428】","category":"网络","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/532","page":"q/网络-532.html","excerpt":"**关键词**：jwt 基本概念 JWT是JSON Web Token的缩写，是一种用于在不同系统之间安全传输信息的开放标准。JWT通常用于身份验证和授权，它由三部分组成：头部（header）、载荷（payload）和签名（signature）。 头部包含了关于令牌的元数据和算法信息，通常包括令牌的类型（例如JWT）、"},{"id":"531","title":"Http 状态码 301 和 302 的应用场景分别是什么","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/531","page":"q/网络-531.html","excerpt":"HTTP状态码301和302都是重定向状态码，用于将客户端请求重定向到另一个URL。 301（Moved Permanently）：表示请求的资源已永久移动到新位置。服务器发送301状态码时，还会在响应头中包含一个Location字段，指示新的资源位置。客户端接收到301响应后，会自动重定向到新的URL，并且搜索引擎也"},{"id":"530","title":"http 常见状态码有哪些【热度: 1,410】","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/530","page":"q/网络-530.html","excerpt":"**关键词**：http常见状态码 HTTP（超文本传输协议）中常见的状态码包括： 1xx（信息性状态码）：表示请求已被接收并正在处理。 100（Continue）：请求已接收，客户端应继续发送请求的剩余部分。 101（Switching Protocols）：服务器要求客户端切换协议。 2xx（成功状态码）：表示请求"},{"id":"529","title":"http2 多路复用是什么, 原理是什么【热度: 353】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/529","page":"q/网络-529.html","excerpt":"**关键词**：http2多路复用、http2多路复用原理、http2帧和流、http2流的优先级、http2头部压缩 多路复用是指在HTTP/2中，多个请求/响应可以同时在同一个TCP连接上进行传输和处理的机制。 在HTTP/1.1中，每个请求都需要建立一个独立的TCP连接，导致连接的建立和关闭开销很大。而在HTTP"},{"id":"528","title":"HTTP/1.0、HTTP/1.1、HTTP/2和HTTP/3之间的主要区别【热度: 1,447】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/528","page":"q/网络-528.html","excerpt":"**关键词**：HTTP各版本之间区别 下面是一个表格，展示了HTTP/1.0、HTTP/1.1、HTTP/2和HTTP/3之间的主要区别： | 特点 | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 | |----------------|------------------------"},{"id":"527","title":"常见的请求头和响应头","category":"网络","labels":["网络","京东"],"url":"https://github.com/pro-collection/interview-question/issues/527","page":"q/网络-527.html","excerpt":"**通用头部字段** 指的是在请求头和响应头中都可以使用的字段 | 通用字段 | 作用 | | ----------------- | --------------------------------------------- | | Date | 表示报文创建的时间 | | Connection | 表示内部使用的T"},{"id":"501","title":"TCP/IP五层协议是什么？【热度: 548】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/501","page":"q/网络-501.html","excerpt":"**关键词**：TCP/IP协议 当提到五层协议时，通常是指TCP/IP模型的五层协议，即物理层、数据链路层、网络层、传输层和应用层。下面是对每一层的详细解释以及一些应用场景的例子： 物理层（Physical Layer）：物理层是网络通信的最底层，它负责传输比特流，将数据从一个节点通过物理介质传输到另一个节点。它包括"},{"id":"499","title":"如何封装一个请求，让其多次调用的时候，实际只发起一个请求的时候，返回同一份结果【热度: 636】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/499","page":"q/网络-499.html","excerpt":"**关键词**：defer函数、请求结果缓存在JS内存 最优解： **使用deferred思想来实现请求的等待队列，可以借助Promise和async/await语法**。 下面是使用deferred思想来实现的代码示例： 在上述代码中，Deferred类用于创建一个延迟对象，其中promise属性是一个Promise"},{"id":"498","title":"一般项目里面对请求 request 都会做哪些统一封装？【热度: 916】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/498","page":"q/网络-498.html","excerpt":"**关键词**：request封装、request封装功能、request封装作用 统一处理错误：可以在请求封装中统一处理错误，例如网络错误、超时等，并进行统一的错误提示或处理逻辑。 统一处理认证和授权：可以在请求中添加认证信息，例如在请求头中添加 token，或者在每个请求中验证用户权限。 统一处理请求配置：可以在请"},{"id":"442","title":"ajax、axios、fetch的区别【热度: 855】","category":"网络","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/442","page":"q/网络-442.html","excerpt":"**关键词**：ajax、axios、fetch、前端网络请求库 Ajax、Axios和Fetch都是用于进行HTTP请求的工具或技术，但它们在实现细节和功能方面有所不同。 Ajax（Asynchronous JavaScript and XML）: Ajax是一种用于在后台与服务器进行异步通信的技术。 Ajax使用X"},{"id":"413","title":"什么是正向代理，反向代理【热度: 1,294】","category":"网络","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/413","page":"q/网络-413.html","excerpt":"**关键词**：正向代理反向代理概念 概念 正向代理（Forward Proxy）和反向代理（Reverse Proxy）都是常见的代理服务器架构，用于在客户端与目标服务器之间进行中转和处理请求的工作。它们的区别在于代理的位置和作用方式不同。 正向代理： 代理位于客户端与目标服务器之间，代理服务器充当客户端的代表。 客"},{"id":"412","title":"什么是同源策略【热度: 1,430】","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/412","page":"q/网络-412.html","excerpt":"**关键词**：同源策略限制了什么资源 同源策略（Same-Origin Policy）是一种浏览器安全机制，用于限制不同源（域名、协议、端口）之间的交互。它是一种重要的安全措施，用于保护用户的隐私和安全，防止恶意网站通过跨域请求获取用户的敏感信息或进行恶意操作。 同源策略要求网页资源（如JavaScript、CSS、"},{"id":"411","title":"什么是文档的预解析【热度: 1,133】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/411","page":"q/网络-411.html","excerpt":"**关键词**：文档预解析 文档的预解析（Document Preloading）是浏览器在解析 HTML 文档时的一个优化技术，用于提前获取页面所需的外部资源，如样式表、脚本、字体等。通过在解析过程中预先获取这些资源，可以加快页面加载速度和渲染时间。 浏览器在解析 HTML 文档时，会遇到外部资源的引用，比如 <li"},{"id":"410","title":"在浏览器内多个标签页之间实现通信有哪些方式【热度: 897】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/410","page":"q/网络-410.html","excerpt":"**关键词**：跨页面通信、Broadcast Channel API 通信、SharedWorker 基本通信方式 在浏览器内多个标签页之间实现通信可以通过以下几种方式： 使用 Broadcast Channel API：Broadcast Channel API 是 HTML5 提供的一种跨页面通信的机制。通过该 "},{"id":"409","title":"进程和线程的区别是什么？","category":"网络","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/409","page":"q/网络-409.html","excerpt":"进程（Process）和线程（Thread）是计算机操作系统中的两个核心概念，它们在程序执行和资源管理方面有着不同的特点和作用。下面是它们之间的区别： 定义：进程是程序的一次执行过程，是资源分配的基本单位；线程是进程的一部分，是程序执行的最小单位。 资源拥有：每个进程都拥有独立的内存空间和系统资源，包括文件、设备、网络"},{"id":"408","title":"token过期后，页面如何实现无感刷新【热度: 485】","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/408","page":"q/网络-408.html","excerpt":"**关键词**：token过期刷新、token刷新 当 token 过期后，实现无感刷新页面的一种常见方式是使用刷新 token 的机制。下面是一个基本的实现思路： 在前端应用中，使用某种方式（例如 Cookie、Local Storage）存储 token。 在每次发起请求时，通过拦截器或者请求中间件检查 token"},{"id":"407","title":"TCP粘包了解多少【热度: 927】","category":"网络","labels":["网络","京东"],"url":"https://github.com/pro-collection/interview-question/issues/407","page":"q/网络-407.html","excerpt":"**关键词**：粘包、粘包解决办法 TCP粘包（TCP packet sticking）是指在数据传输过程中，发送方连续发送的若干小数据包被接收方组合成较大的数据块或者多个小数据包粘合在一起接收的现象。 TCP是面向流的传输协议，数据在传输过程中会被拆分成TCP数据段，并在接收方重新组装。由于TCP的流式传输特性，发送"},{"id":"406","title":"数字证书了解多少【热度: 1,834】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/406","page":"q/网络-406.html","excerpt":"**关键词**：数字证书 公钥、数字签名 概念、数字签名详解 概念 数字证书是一种用于验证和证明网络实体身份的电子文件。它由证书颁发机构（Certificate Authority，CA）或类似的实体签发，并包含了一系列信息，包括公钥、证书持有者的身份信息以及数字签名等。 数字证书通常用于建立安全通信，特别是在使用加密"},{"id":"405","title":"TLS/SSL的工作原理【热度: 499】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/405","page":"q/网络-405.html","excerpt":"**关键词**：SSL的工作原理、TLS的工作原理、密钥交换阶段 TLS（Transport Layer Security）和SSL（Secure Sockets Layer）是用于在网络上提供安全通信的协议。TLS是SSL的继任者，但两者通常被混合使用。 TLS/SSL的工作原理如下： 握手阶段（Handshake）"},{"id":"404","title":"OSI的七层模型是什么","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/404","page":"q/网络-404.html","excerpt":"OSI的七层模型是什么 OSI（Open Systems Interconnection）是国际标准化组织（ISO）定义的一个用于网络协议设计的参考模型。它将网络通信的过程分为七个不同的层级，每个层级负责不同的功能和任务，以实现网络通信的可靠性和互操作性。下面是 OSI 模型的七个层级： 物理层（Physical La"},{"id":"403","title":"fetch 与 ajax 的区别是什么","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/403","page":"q/网络-403.html","excerpt":"以下是 Fetch API 与传统的 Ajax（XMLHttpRequest）在几个方面的对比： | 维度 | Fetch API | Ajax (XMLHttpRequest) | | ------------ | ---------------------------------------------------"},{"id":"402","title":"使用 ajax 封装一个上传文件的函数【热度: 206】","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/402","page":"q/网络-402.html","excerpt":"**关键词**：ajax 上传文件、ajax 上传文件函数、ajax 上传文件封装 下面是一个使用 AJAX 封装的上传文件函数的示例代码： 在上述示例代码中，定义了一个 uploadFile 函数用于上传文件。该函数接收文件对象、上传 URL、进度回调函数、成功回调函数和错误回调函数作为参数。 函数内部通过创建 XM"},{"id":"401","title":"ajax 是否支持取消请求","category":"网络","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/401","page":"q/网络-401.html","excerpt":"**xhr.abort() 方法用于中止当前的请求**。调用该方法会导致 XHR 对象触发 abort 事件，且触发 readystatechange 事件的处理函数，xhr.readyState 的值将变为 0。 下面是一个示例代码，展示了如何使用标志位实现取消请求的效果： 在上述示例代码中，添加了一个 cancel"},{"id":"400","title":"介绍一下 XMLHTTPRequest 对象【热度: 453】","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/400","page":"q/网络-400.html","excerpt":"**关键词**：XMLHTTPRequest 对象、XMLHTTPRequest 特点、XMLHTTPRequest 属性、封装发送 GET 请求 介绍 XMLHttpRequest 是一个在浏览器中用于发送 HTTP 请求的 JavaScript 对象。它提供了一种在客户端与服务器之间进行数据交互的方式，可以异步地发"},{"id":"399","title":"304 是什么场景的状态码， 好处和坏处分别是什么【热度: 1,425】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/399","page":"q/网络-399.html","excerpt":"**关键词**：304 状态码、缓存响应 HTTP 状态码 304 Not Modified 是在一些特定场景下返回的状态码，用于表示客户端缓存的资源仍然有效，无需重新下载。 好处： 减少了对服务器的请求，节省了带宽和服务器资源。 加快了客户端的加载速度，因为它可以使用缓存的响应而无需等待服务器的响应。 坏处： 如果客"},{"id":"398","title":"有哪些场景的 http header","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/398","page":"q/网络-398.html","excerpt":"常见的 HTTP Header 在请求头（Request Header）和响应头（Response Header）中有许多不同的字段，它们具有各自的作用。下面是一些常见的 HTTP Header 字段及其作用的简要说明： **Request Header：** **Host**：指定目标服务器的域名或 IP 地址。 *"},{"id":"360","title":"WebSocket 协议的底层原理是什么【热度: 1,805】","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/360","page":"q/网络-360.html","excerpt":"**关键词**：WebSocket 协议、WebSocket 与 http 区别、全双工通信的协议 WebSocket 通信原理 WebSocket 是一种在Web浏览器和服务器之间进行全双工通信的协议，它通过一个长久的、双向的通信通道来实现实时数据传输。 下面是WebSocket协议的底层原理： 握手（Handsha"},{"id":"359","title":"DNS解析过程","category":"网络","labels":["网络","百度"],"url":"https://github.com/pro-collection/interview-question/issues/359","page":"q/网络-359.html","excerpt":"DNS（Domain Name System，域名系统）解析是将域名转换为对应的IP地址的过程。下面是DNS解析的一般步骤： 用户输入域名：用户在浏览器或其他应用程序中输入要访问的域名，例如 \"$1 本地缓存查找：操作系统首先会检查本地的DNS缓存，看是否已经缓存了该域名的IP地址。如果有匹配的缓存记录，且仍在有效期内"},{"id":"335","title":"HTTP 304 状态码表达的请求过程是什么【热度: 459】","category":"网络","labels":["网络","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/335","page":"q/网络-335.html","excerpt":"**关键词**：304状态码、304请求过程、304过程、304请求 HTTP 304 状态码是表示所请求的资源未修改，可以直接使用客户端缓存的版本。当客户端发送 GET 请求时，服务器会检查该资源的 ETag（实体标签）或 Last-Modified（最后修改时间）等信息，与客户端缓存中的相应信息进行比较。如果这些信"},{"id":"333","title":"TCP/IP 如何保证数据包传输的有序可靠【热度: 336】","category":"网络","labels":["网络","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/333","page":"q/网络-333.html","excerpt":"**关键词**：TCP/IP 可靠性、TCP/IP 序列号、TCP/IP 超时 TCP/IP 采用以下几种机制来保证数据包传输的有序可靠： 确认和重传：每当 TCP/IP 协议收到一个数据包时，将向发送方回送一个确认信息。如果接收方未收到数据包，则发送方将重传该数据包。这种确认和重传的机制可以确保数据包能够可靠地传输，"},{"id":"332","title":"DNS 协议了解多少【热度: 712】","category":"网络","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/332","page":"q/网络-332.html","excerpt":"**关键词**：DNS协议、DNS加速 DNS 基本概念 DNS（Domain Name System，域名系统）是因特网上用于将主机名转换为 IP 地址的协议。它是一个分布式数据库系统，通过将主机名映射到 IP 地址来实现主机名解析，并使用户能够通过更容易识别的主机名来访问互联网上的资源。 在使用 DNS 协议进行主"},{"id":"297","title":"CDN 了解多少？【热度: 413】","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/297","page":"q/网络-297.html","excerpt":"CDN 是什么 CDN（Content Delivery Network）是指内容分发网络，它是由分布在不同地理位置的多台服务器组成的网络系统，用于更快地传递互联网内容和服务。CDN 可以缓存静态资源，加速用户访问速度，降低带宽消耗和服务器压力。 CDN 的工作原理：CDN 通过将资源缓存在离用户更近的边缘节点，使用户"},{"id":"223","title":"介绍下如何实现 token 加密？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/223","page":"q/网络-223.html","excerpt":"Token 是一种常用的身份验证机制，通常被用于 Web 应用程序的用户身份验证。Token 的生成和使用可以使用加密技术来增强安全性，下面介绍一下如何实现 Token 加密。 Token 加密一般有两个步骤： 生成 Token 加密 Token 1. 生成 Token 在生成 Token 时，需要将用户的一些信息进行"},{"id":"213","title":"https 的证书验证过程是什么样的","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/213","page":"q/网络-213.html","excerpt":"HTTPS的证书验证过程通常包括以下几个步骤： 客户端向服务端发起HTTPS请求，服务端将其公钥证书发送给客户端。 客户端接收到服务端的证书后，首先验证证书是否过期，如果过期，则证书无效，验证失败；如果证书未过期，则进行下一步。 客户端使用CA证书（如系统内置的或者从服务端获取）对服务端证书进行验证，以确定该证书是否是"},{"id":"206","title":"浏览器缓存中 Memory Cache 和 Disk Cache， 有啥区别？","category":"网络","labels":["网络","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/206","page":"q/网络-206.html","excerpt":"Memory Cache 和 Disk Cache 的区别 在浏览器缓存中，Memory Cache 和 Disk Cache 是两种不同的缓存类型，它们有以下区别： 存储位置：Memory Cache 存储在内存中，而 Disk Cache 存储在硬盘中。 读取速度：Memory Cache 读取速度比 Disk C"},{"id":"197","title":"A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态？(了解即可)","category":"网络","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/197","page":"q/网络-197.html","excerpt":"当 B 机器重启时，TCP 连接会被断开，此时 A 机器会检测到 TCP 连接异常断开，将 TCP 状态修改为 FIN\\_WAIT\\_1 状态。A 机器会继续等待来自 B 机器的响应，如果等待的时间超过了一定时间（通常为几分钟），A 机器会放弃等待并关闭 TCP 连接，将 TCP 状态修改为 CLOSED 状态。"},{"id":"186","title":"中间人攻击是什么？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/186","page":"q/网络-186.html","excerpt":"中间人攻击（Man-in-the-Middle Attack，简称MITM）是一种常见的网络攻击手段，以下是关于它的详细介绍： 定义 中间人攻击是攻击者在通信双方不知情的情况下，插入到通信链路中间，拦截、窃听、篡改甚至伪造通信双方之间传输的数据，从而达到获取敏感信息、干扰通信或进行其他恶意操作的目的。攻击者就像处在通信"},{"id":"184","title":"前端如何防止加载外域脚本？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/184","page":"q/网络-184.html","excerpt":"前端可以通过以下方式防止加载外域脚本： 使用 Content Security Policy (CSP)：CSP 是一个 HTTP 头，可以限制页面可以从哪些源加载资源。通过 CSP，可以禁止加载外域脚本，从而防止 XSS 攻击等安全问题。 使用 Subresource Integrity (SRI)：SRI 是一个浏"},{"id":"183","title":"HTTP/3 是基于 UDP 的协议， 那么他是如何保障安全性的？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/183","page":"q/网络-183.html","excerpt":"HTTP/3是基于UDP的协议，因此在设计时需要考虑安全性问题。为了保障安全性，HTTP/3使用了一个新的加密协议——QUIC Crypto。 QUIC Crypto使用了一种名为\"0-RTT安全连接\"的机制，允许客户端在第一次请求时就可以建立安全连接，从而减少连接建立的延迟。此外，HTTP/3还使用了数字证书来验证服"},{"id":"182","title":"http3 QUIC 是什么协议？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/182","page":"q/网络-182.html","excerpt":"HTTP/3（或称为HTTP-over-QUIC）是一个基于QUIC协议的新版本的HTTP协议。QUIC（Quick UDP Internet Connections）是由Google设计的一个基于UDP协议的传输层协议，旨在解决HTTP/2协议存在的一些问题。 HTTP/3中引入了QUIC的一些特性，如0-RTT连接"},{"id":"181","title":"http1.1 持久连接 和 http2 的多路复用有什么区别？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/181","page":"q/网络-181.html","excerpt":"HTTP/1.1和HTTP/2都是HTTP协议的不同版本，在网络传输和性能方面有很大的差别。 HTTP/1.1使用的是“管线化请求”和“持久连接”来提高性能，而HTTP/2则引入了更多的特性，其中最重要的特性是“多路复用”。 “管线化请求”是HTTP/1.1提出的一种优化方法，它可以让浏览器同时发出多个请求，从而避免了"},{"id":"180","title":"HTTP协议的不同版本的主要特点有哪些？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/180","page":"q/网络-180.html","excerpt":"HTTP协议的不同版本的主要特点如下表所示： |版本|发布时间|主要特点| |---|---|---| |HTTP/0.9|1991年|只支持GET方法，没有Header和Body| |HTTP/1.0|1996年|引入Header、POST方法、响应码、缓存等特性| |HTTP/1.1|1999年|引入持久连接、管道"},{"id":"170","title":"文件上传和上传文件解析的原理是啥？","category":"网络","labels":["网络","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/170","page":"q/网络-170.html","excerpt":"前端如何上传图片等文件 在前端上传图片或其他文件字段，一般使用 HTML 中的 <input> 元素，并设置 type=\"file\"，这样就可以让用户选择本地的文件进行上传。 例如： 在这个例子中，<form> 元素的 enctype 属性设置为 multipart/form-data，这样就可以将文件作为二进制数据进"},{"id":"153","title":"如何监控前端页面内存持续增长情况？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/153","page":"q/网络-153.html","excerpt":"监控前端页面内存持续增长可以帮助我们及时发现内存泄漏和其他内存问题，从而优化前端页面的性能和稳定性。以下是一些监控前端页面内存持续增长的方法： 使用浏览器开发工具：现代浏览器的开发工具提供了内存监控功能。您可以使用 Chrome 开发者工具、Firefox 开发者工具等浏览器工具来监控内存的使用情况，并在内存使用超过阈"},{"id":"152","title":"页面崩溃如何监控？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/152","page":"q/网络-152.html","excerpt":"页面崩溃如何监控？ 对于 web 页面线上监控，如果页面崩溃了，通常会出现 500 或 404 状态码，或者页面停止响应或显示白屏等情况。 以下是一些监控崩溃的方法： 使用网站性能监测工具：这些工具可以检测页面的状态码和响应时间，如果页面崩溃了，就会发出警报。一些流行的性能监测工具包括 New Relic, Pingd"},{"id":"151","title":"HTTPS 加密算法和加解密过程是啥？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/151","page":"q/网络-151.html","excerpt":"探究 HTTPS 我说，你起这么牛逼的名字干嘛，还想吹牛批？你 HTTPS 不就抱上了 TLS/SSL 的大腿么，咋这么牛批哄哄的，还想探究 HTTPS，瞎胡闹，赶紧改成 TLS 是我主，赞美我主。 SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层，SSL 在 1999 年被 IETF(互联网工程组)更名"},{"id":"149","title":"HTTPS 中的 SSL/TLS 是什么？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/149","page":"q/网络-149.html","excerpt":"什么是 SSL/TLS 认识 SSL/TLS TLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，它们是用于在互联网两台计算机之间用于身份验证和加密的一种协议。 注意：在互联网中，很多名称都可以进行互换。 我们都知道一些在线业务（比如在线支付）最"},{"id":"148","title":"HTTPS 解决了什么问题？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/148","page":"q/网络-148.html","excerpt":"HTTPS 解决了什么问题 一个简单的回答可能会是 HTTP 它不安全。由于 HTTP 天生明文传输的特性，在 HTTP 的传输过程中，任何人都有可能从中截获、修改或者伪造请求发送，所以可以认为 HTTP 是不安全的；在 HTTP 的传输过程中不会验证通信方的身份，因此 HTTP 信息交换的双方可能会遭到伪装，也就是没"},{"id":"147","title":"HTTP 与 HTTPS 的区别？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/147","page":"q/网络-147.html","excerpt":"HTTPS 基础 https 是 http 的“升级”版本： SSL 是安全层，TLS 是传输层安全，是SSL 的继承。使用SSL或TLS 可确保传输数据的安全性。 使用 HTTP 可能看到传输数据是： “这是明文信息” 使用 HTTPS 可能看到： “283hd9saj9cdsncihquhs99ndso” HTTP"},{"id":"129","title":"有什么方法可以保持前后端实时通信？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/129","page":"q/网络-129.html","excerpt":"实时通信是一种双向的通信方式，前后端都能实时地获取对方的数据和状态变化，目前主要有以下几种方法可以实现： WebSocket：WebSocket 是一种基于 TCP 协议的双向通信协议，它可以在客户端和服务器之间建立持久性的连接，并且支持服务器主动向客户端推送数据。WebSocket 协议通过 HTTP 协议的 101"},{"id":"122","title":"跨站请求伪造（Cross-Site Request Forgery, CSRF）具体实现步骤是啥， 如何防止？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/122","page":"q/网络-122.html","excerpt":"跨站请求伪造（Cross-Site Request Forgery, CSRF）是一种常见的网络攻击方式，攻击者可以利用已登录的用户身份，通过伪造用户的请求，对服务器上的资源进行非法操作。下面是一种常见的 CSRF 攻击方式： 用户在浏览器中登录了某个网站，并获取了该网站的 Cookie。 攻击者诱导用户访问一个恶意网"},{"id":"121","title":"如何防止 跨站脚本攻击（Cross-Site Scripting, XSS）?","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/121","page":"q/网络-121.html","excerpt":"以下是一些防范跨站脚本攻击的常见方法： 输入过滤：对于所有输入的数据（如表单数据、URL 参数等），应该进行过滤和验证。特别是对于敏感数据（如密码、信用卡信息等），应该进行严格的验证，防止恶意的脚本注入。可以使用一些开源的输入验证工具，如OWASP ESAPI来过滤恶意输入。 对特殊字符进行转义：对于所有输出到页面上的"},{"id":"120","title":"常见的 web 前端网路攻击有哪些？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/120","page":"q/网络-120.html","excerpt":"以下是一些常见的 web 前端网络攻击类型： 跨站脚本攻击（Cross-Site Scripting, XSS）：XSS攻击利用了 Web 应用程序对用户输入的不当处理，以将恶意代码注入到 Web 页面中。当用户访问包含恶意代码的页面时，攻击者可以利用这些代码窃取用户的敏感信息、劫持用户会话等。 跨站请求伪造（Cros"},{"id":"98","title":"HTTP 1.0 和 HTTP 1.1 有以下区别？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/98","page":"q/网络-98.html","excerpt":"**连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。 **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对"},{"id":"96","title":"一个 tcp 连接能发几个 http 请求？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/96","page":"q/网络-96.html","excerpt":"如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 和 Keep-Alive 首部，在请求头带上 Connection: Kee"},{"id":"86","title":"V8 引擎了解多少？","category":"网络","labels":["Nodejs","网络"],"url":"https://github.com/pro-collection/interview-question/issues/86","page":"q/网络-86.html","excerpt":"目录 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 渲染引擎与网页渲染 编程分类 编程语言分为 **编译型语言和解释型语** 言两类。 编译型语言在执行之前要先进行完全编译，而 **解释型语言一边编译一边执行**， 很明显解释型语言的执行速度是慢于编译型语言"},{"id":"72","title":"TCP 和 UDP的区别？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/72","page":"q/网络-72.html","excerpt":"TCP和UDP的区别 TCP、UDP和HTTP关系 1、TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。 因此，HTTP"},{"id":"69","title":"前端如何实现即时通讯？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/69","page":"q/网络-69.html","excerpt":"前端如何实现即时通讯 短轮询 短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。 优点：兼容性强，实现非常简单 缺点：延迟性高，非常消耗请求资源，影响性能 comet comet有两种主要实现手段， 一种是基于 AJAX 的长轮询（long-polling）方式"},{"id":"49","title":"fetch 了解多少？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/49","page":"q/网络-49.html","excerpt":"深入fetch fetch 的简单介绍 Fetch 被称为下一代Ajax技术,采用Promise方式来处理数据。 是一种简洁明了的API，比XMLHttpRequest更加简单易用。 页面中需要向服务器请求数据时，基本上都会使用Ajax来实现。 Ajax的本质是使用XMLHttpRequest对象来请求数据，而XMLH"},{"id":"45","title":"cookie 和 session 有什么区别？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/45","page":"q/网络-45.html","excerpt":"cookie 和 session 有什么区别？ 工作方式有所不同 Cookie和Session都是用来在Web应用程序中维护用户状态的机制，但是它们的工作方式有所不同： **Cookie**： Cookie是存储在用户计算机中的小文件，通常由Web服务器发送给Web浏览器。当用户在Web浏览器中发送请求时，浏览器会将C"},{"id":"33","title":"Http协议基础","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/33","page":"q/网络-33.html","excerpt":"http 协议有什么特点？ **简单快速，灵活、无连接、无状态** 每一个资源对应一个URI，请求只要输入资源地址uri就可以了； 在每一个http头部协议中都有一个数据类型，通过一个http协议就可以完成不同类型数据的传输； 链接一次就会断开； 每一次链接不会记住链接状态的，服务器不区分两次链接的身份； http报文"},{"id":"29","title":"请简述 HTTP 请求的过程","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/29","page":"q/网络-29.html","excerpt":"HTTP（Hypertext Transfer Protocol）是一种用于传输数据的协议。当我们在浏览器中输入 URL，点击链接或提交表单时，浏览器会发送 HTTP 请求，并等待服务器的响应。以下是 HTTP 请求的基本过程： 建立连接：浏览器向服务器发出连接请求，服务器接受请求并建立连接。 发送请求：浏览器向服务器"},{"id":"28","title":"HTTP 缓存策略有哪些？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/28","page":"q/网络-28.html","excerpt":"HTTP 缓存策略有哪些？ HTTP缓存策略是指浏览器和服务器之间在传输资源时，如何使用缓存的方式。HTTP缓存的主要目的是减少网络传输的数据量，提高页面的访问速度。 缓存的主要策略有哪些？ HTTP缓存策略主要包括以下几种： 强缓存：通过设置 HTTP 头部中的 Expires 或 Cache-Control 字段来"},{"id":"27","title":"HTTP建立连接的过程?","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/27","page":"q/网络-27.html","excerpt":"在HTTP/1.1中 建立连接过程遵循以下步骤： 建立TCP连接：客户端通过三次握手建立TCP连接。 发送请求：客户端向服务器发送一个HTTP请求报文。 服务器响应：服务器收到请求后，返回一个HTTP响应报文。 客户端接收响应：客户端收到响应后，根据响应中的状态码判断请求是否成功。 关闭连接：如果响应中包含 Conne"},{"id":"26","title":"TCP 传输过程？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/26","page":"q/网络-26.html","excerpt":"传输过程 TCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下： **建立连接**：TCP 通过三次握手建立连接，即客户端向服务器发送 SYN（同步）数据包，服务器接收到 SYN 后回应一个 SYN-ACK（同步-确认）数据包"},{"id":"25","title":"网络模型分层大概有哪些层级？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/25","page":"q/网络-25.html","excerpt":"计算机网络体系结构通常被划分为七层，即**OSI（Open System Interconnection，开放式系统互联）参考模型**和**TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/互联网协议）参考模型。** OSI参考模型包含七层，从底"},{"id":"19","title":"什么是同源策略？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/19","page":"q/网络-19.html","excerpt":"同源策略是一种安全机制，它是浏览器对 JavaScript 实施的一种安全限制。所谓“同源”是指域名、协议、端口号均相同。同源策略限制了一个页面中的脚本只能与同源页面的脚本进行交互，而不能与不同源页面的脚本进行交互。这是为了防止恶意脚本窃取数据、进行 XSS 攻击等安全问题。 同源策略限制的资源包括： Cookie、L"},{"id":"16","title":"跨域通信的常见方式有哪些?","category":"网络","labels":["网络","美团"],"url":"https://github.com/pro-collection/interview-question/issues/16","page":"q/网络-16.html","excerpt":"常见方式 **JSONP** JSONP是通过动态创建script标签的方式，利用script标签可以跨域请求资源的特性来实现的，本质是利用了script标签没有跨域限制的特性，可以在请求的url后加一个callback参数，后端接收到请求后，将需要传递的数据作为参数传递到callback函数中，前端定义该函数来接收数"},{"id":"15","title":"JSONP 是如何实现跨域的?","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/15","page":"q/网络-15.html","excerpt":"JSONP JSONP 的实现原理是通过添加一个 script 标签，指定 src 属性为跨域请求的 URL，而这个 URL 返回的不是 JSON 数据，而是一段可执行的 JavaScript 代码，这段代码会调用一个指定的函数，并且将 JSON 数据作为参数传入函数中。 例如，假设我们从 http://example"},{"id":"14","title":"CORS 是如何实现跨域的？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/14","page":"q/网络-14.html","excerpt":"cors 的基本概念 CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种用于让浏览器绕过同源策略限制，实现跨域访问资源的机制。在浏览器端，JavaScript 的跨域请求必须要经过浏览器的同源策略限制，即只能向同一域名下的服务器发送请求，而不能向其它域名的服务器发送请求。CORS"},{"id":"13","title":"postMessage 是如何解决跨域问题的？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/13","page":"q/网络-13.html","excerpt":"基本概念 postMessage 是 HTML5 提供的一种跨窗口通信机制，可以在不同窗口、甚至不同域名之间进行通信，从而实现跨域通信。通过在一个窗口中调用 postMessage 方法向另一个窗口发送消息，接收窗口可以监听 message 事件，以接收发送过来的消息。 使用 postMessage 可以解决一些跨域问"},{"id":"12","title":"WebSocket 了解多少？","category":"网络","labels":["网络"],"url":"https://github.com/pro-collection/interview-question/issues/12","page":"q/网络-12.html","excerpt":"基本概念 WebSocket 是一种基于 TCP 协议的网络通信协议，可以在客户端和服务器之间进行双向通信。相比传统的 HTTP 请求，WebSocket 具有更低的延迟和更高的效率。但是，由于同源策略的限制，**WebSocket 也会受到跨域问题的影响。** WebSocket 通过在客户端和服务器之间建立持久连接"},{"id":"966","title":"http 向 https 做重定向应该使用哪个状态码【热度: 336】","category":"网易","labels":["网络","web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/966","page":"q/网易-966.html","excerpt":"**关键词**：重定向 从 HTTP 向 HTTPS 做重定向，既可以使用 301 永久重定向状态码，也可以使用 302 临时重定向状态码。以下是对这两种状态码的具体介绍及使用场景分析： **301 永久重定向**： **含义**：表示请求的资源已被永久地移动到了新的 URL，搜索引擎等客户端会更新其索引，将旧的 UR"},{"id":"828","title":"[vue] 第一次页面加载会触发哪几个钩子【热度: 112】","category":"网易","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/828","page":"q/网易-828.html","excerpt":"**关键词**：vue 钩子出发 在 Vue.js 中，页面首次加载时，会按照以下顺序触发一系列的生命周期钩子： **beforeCreate**: 实例刚在内存中被创建时调用，此时还未初始化响应式数据和事件。 **created**: 实例创建完成后被调用，此时已完成数据观测（即数据响应式）、属性和方法的运算，$el"},{"id":"743","title":"用 JS 写一个 cookies 解析函数， 输出结果为一个对象【热度: 137】","category":"网易","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/743","page":"q/网易-743.html","excerpt":"**关键词**：解析 cookies 当然可以，以下是一个简单的 JavaScript 函数，用于解析当前页面的 cookie 并将它们存储到一个对象中： 这个函数首先会以分号 ; 分割 document.cookie 字符串来得到各个 cookie 键值对，然后移除键值对前后的任何空格。接着寻找每个键值对中的等号 ="},{"id":"652","title":"vite 和  webpack 在热更新上有啥区别？【热度: 530】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/652","page":"q/网易-652.html","excerpt":"**关键词**：热更新区别 Vite 和 Webpack 在热更新上有一些区别： 模块级别的热更新：Vite 使用浏览器原生的 ES 模块系统，可以实现模块级别的热更新，即只更新修改的模块，而不需要刷新整个页面。这样可以提供更快的开发迭代速度。而在 Webpack 中，热更新是基于文件级别的，需要重新构建并刷新整个页面"},{"id":"643","title":"http code 中 301 和 302 有啥区别？【热度: 721】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/643","page":"q/网易-643.html","excerpt":"**关键词**：http code 码 在 HTTP 协议中，301和302是两种重定向状态码。它们的区别如下： 301 Moved Permanently (永久重定向)：当服务器返回301状态码时，表示所请求的资源已经被永久移动到了一个新的位置。浏览器在接收到301响应后，会自动将请求的 URL 地址更新为新的位置"},{"id":"642","title":"前端如何设置请求超时时间 timeout(axios)【热度: 890】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/642","page":"q/网易-642.html","excerpt":"**关键词**：请求超时时间 **1. axios全局设置网络超时** axios.defaults.timeout = 10 * 1000; // 10s **2. 单独对某个请求设置网络超时** axios.post(url, params, {timeout: 1000}) .then(res => { cons"},{"id":"638","title":"页面加载速度提升（性能优化）应该从哪些方向来思考？【热度: 1,099】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/638","page":"q/网易-638.html","excerpt":"**关键词**：性能提升、加载优化 页面加载优化 「页面加载链路+流程优化+协作方」的多级分类思考 页面启动 service worker 缓存重要的静态资源 页面保活 资源加载 网络连接 NDS 减少 NDS 解析 NDA 预解析 HTTP 开启 HTTP2 多路复用 优化核心请求链路 HTML 加载 内容优化 代码"},{"id":"636","title":"对比一下 pnpm、npm、yarn 特性【热度: 399】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/636","page":"q/网易-636.html","excerpt":"**关键词**：pnpm、npm、yarn 特性对比 | 功能 | pnpm | Yarn | npm | |--------------------------------|------------------------------------------------------------------------"},{"id":"633","title":"token 进行身份验证了解多少？【热度: 942】","category":"网易","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/633","page":"q/网易-633.html","excerpt":"**关键词**：身份验证、token 验证 token 概念和作用 Token是一种用于身份验证和授权的令牌。在Web应用程序中，当用户进行登录或授权时，服务器会生成一个Token并将其发送给客户端。客户端在后续的请求中将Token作为身份凭证携带，以证明自己的身份。 Token可以是一个字符串，通常是经过加密和签名的"},{"id":"580","title":"[React] 如何实现vue 中 keep-alive 的功能？【热度: 255】","category":"网易","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/580","page":"q/网易-580.html","excerpt":"**关键词**：keep-alive组件缓存、keep-alive实现、keep-alive原理 **keep-alive 原理** 可以参考这个文章： https://github.com/pro-collection/interview-question/issues/119 **实现** 当使用函数式组件时，可以"},{"id":"579","title":"[Vue] 中为何不要把 v-if 和 v-for 同时用在同一个元素上， 原理是什么？【热度: 546】","category":"网易","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/579","page":"q/网易-579.html","excerpt":"**关键词**：v-if和v-for性能 确实，将v-if和v-for同时用在同一个元素上可能会导致性能问题。**原因在于v-for具有比v-if更高的优先级，它会在每次渲染的时候都会运行**。这意味着，即使在某些情况下v-if的条件为false，v-for仍然会对数据进行遍历和渲染。 这样会导致一些不必要的性能消耗，"},{"id":"578","title":"将静态资源缓存在本地的方式有哪些？【热度: 584】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/578","page":"q/网易-578.html","excerpt":"**关键词**：静态资源缓存本地 **浏览器可以使用以下几种方式将前端静态资源缓存在本地**： HTTP缓存：浏览器通过设置HTTP响应头中的Cache-Control或Expires字段来指定资源的缓存策略。常见的缓存策略有：no-cache（每次都请求服务器进行验证）、no-store（不缓存资源）、max-age"},{"id":"577","title":"SPA首屏加载速度慢的怎么解决【热度: 868】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/577","page":"q/网易-577.html","excerpt":"**关键词**：SPA首屏、加快首屏加载 **统计首屏时间** 可以参考下面的文档： https://github.com/pro-collection/interview-question/issues/515 https://github.com/pro-collection/interview-question/"},{"id":"570","title":"Object 对象有哪些场景 api ？【热度: 509】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/570","page":"q/网易-570.html","excerpt":"**关键词**：Object对象api | 方法/属性 | 描述 | | ------------------------------ | ------------------------------------------------------------ | | Object.keys(obj) | 返回一个由给"},{"id":"568","title":"实现日期格式化 format 函数【热度: 489】","category":"网易","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/568","page":"q/网易-568.html","excerpt":"**关键词**：日期format函数、日期format实现 **问题** **解答** 以下是使用JavaScript实现日期格式化的format函数： 上述代码中，我们通过在Date对象的原型上定义format函数，使得所有的Date对象都可以调用format函数进行日期格式化。在函数内部，我们使用getFullYe"},{"id":"567","title":"实现一个函数， 计算两个日期之间的天数差","category":"网易","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/567","page":"q/网易-567.html","excerpt":"以下是使用JavaScript实现计算两个日期之间的天数差的函数： 上述函数首先将两个日期字符串转换为Date对象，然后计算两个日期对象之间的时间差（以毫秒表示），最后将时间差转换为天数。通过调用calculateDateDifference函数，可以获取两个日期之间的天数差。"},{"id":"566","title":"https 如何保证安全的？【热度: 782】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/566","page":"q/网易-566.html","excerpt":"**关键词**：https 安全性 HTTPS相比HTTP更安全的原因主要有以下几点： 数据传输加密：HTTPS使用SSL/TLS协议对数据进行加密传输，通过使用对称密钥加密传输数据，并使用非对称密钥进行身份验证和密钥交换。这意味着即使攻击者截获了数据包，也无法解密其中的内容。 身份验证和数据完整性：HTTPS使用数字"},{"id":"564","title":"JavaScript 中， 隐藏类是什么概念？【热度: 146】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/564","page":"q/网易-564.html","excerpt":"**关键词**：JavaScript隐藏类 隐藏类是JavaScript引擎中的一种优化技术，用于提高对象访问的性能。隐藏类是一种数据结构，用于跟踪对象的属性和方法的布局和类型，以便在代码运行时能够快速访问它们。 当JavaScript引擎在执行代码时，会动态地创建对象的隐藏类。隐藏类会跟踪对象的属性和方法，并为它们分"},{"id":"563","title":"JavaScript 如何做内存管理？【热度: 603】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/563","page":"q/网易-563.html","excerpt":"**关键词**：JavaScript内存管理 JavaScript中的内存管理是由垃圾收集器负责的。垃圾收集器会自动追踪不再使用的对象，并在适当的时候释放它们占用的内存。 JavaScript的垃圾收集器使用了一种称为\"**标记-清除**\"（mark and sweep）的算法来确定哪些对象是不再需要的。该算法通过标记"},{"id":"554","title":"如何理解数据驱动视图， 有哪些核心要素？【热度: 943】","category":"网易","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/554","page":"q/网易-554.html","excerpt":"**关键词**：理解数据驱动视图 数据驱动视图是指将数据作为主要驱动力，通过对数据的处理和分析，动态地更新和呈现视图的过程。它强调将数据与视图进行解耦，使得视图的呈现可以根据数据的变化自动更新，实现更灵活、可扩展和可维护的视图。 数据驱动视图的核心要素包括： 数据源：数据驱动视图需要有一个或多个数据源，这些数据源可以是"},{"id":"553","title":"WeakMap 是什么样的数据结构【热度: 431】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/553","page":"q/网易-553.html","excerpt":"**关键词**：WeakMap应用、WeakMap数据、WeakMap api **基本概念** WeakMap 是一种键值对存储的数据结构，类似于 Map。它的特点是键必须是对象，值可以是任意类型的数据。 WeakMap 内部使用了引用计数的方式来判断键是否存活，当键不再被引用时，垃圾回收机制会自动清除对应的键值对。"},{"id":"551","title":"[代码实现] JS 中数组深对比实现【热度: 985】","category":"网易","labels":["网易","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/551","page":"q/网易-551.html","excerpt":"**关键词**：JS数组对比 在JavaScript中，可以使用递归的方式实现数组的深度对比。以下是一个示例函数，用于比较两个数组是否相等： 使用示例： 在上述示例中，deepArrayEqual函数会递归比较两个数组的每个元素的值，包括嵌套的数组和对象。如果两个数组是相等的，则返回true，否则返回false。注意，"},{"id":"535","title":"如何实现大文件断点续传【热度: 897】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/535","page":"q/网易-535.html","excerpt":"**关键词**：文件上传断点续传 前端实现断点续传一般涉及到以下几个步骤： 分片上传：将大文件分割成多个小的文件块。可以使用 JavaScript 的 File 对象的 slice 方法来实现分片。 上传文件块：使用 XMLHttpRequest 或 Fetch API 发送每个文件块到服务器。可以将每个文件块的索引、"},{"id":"534","title":"长连接了解多少【热度: 567】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/534","page":"q/网易-534.html","excerpt":"**关键词**：http 长连接过程 HTTP/1.1 的长连接（Keep-Alive）是一种机制，使客户端和服务器在同一连接上可以发送和接收多个 HTTP 请求和响应。它的原理如下： 客户端发送请求：当客户端发起一个 HTTP 请求时，在请求头中会包含一个 Connection 字段，标识这个连接是否需要保持持久连接"},{"id":"495","title":"原生 js 如何进行监听路由的变化【热度: 906】","category":"网易","labels":["浏览器","网易"],"url":"https://github.com/pro-collection/interview-question/issues/495","page":"q/网易-495.html","excerpt":"**关键词**：原生路由监听 在原生 JavaScript 中，可以使用 window 对象上的 popstate 事件来监听路由的变化。popstate 事件在浏览器的历史记录发生变化时触发，包括当用户点击浏览器的前进或后退按钮、调用 history.pushState() 或 history.replaceStat"},{"id":"472","title":"用 nodejs 实现一个命令行工具， 统计输入目录下面指定代码的行数【热度: 732】","category":"网易","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/472","page":"q/网易-472.html","excerpt":"**关键词**：统计指定目录下代码行数 要实现一个命令行工具来统计输入目录下指定代码的行数，你可以使用Node.js的fs模块来读取文件内容并进行行数统计。以下是一个简单的实现示例： 你可以将上述代码保存为一个JavaScript文件，比如line-counter.js。然后，在终端中运行以下命令： 其中/path/t"},{"id":"468","title":"前端如何用 canvas 来做电影院选票功能","category":"网易","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/468","page":"q/网易-468.html","excerpt":"电影院选票功能可以通过 Canvas 来实现，具体实现步骤如下： 绘制座位图案：使用 Canvas 绘制座位图案，可以用矩形或圆形来表示每个座位，还可以添加不同颜色来表示该座位的状态（已售、已选、可选等）。 添加鼠标事件：添加鼠标事件，如鼠标移动、鼠标单击等，来实现用户交互操作。例如，当用户点击座位时，将该座位的状态改"},{"id":"462","title":"斐波拉契数列是什么，用 JS 实现，用尾调优化斐波拉契数列【热度: 923】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/462","page":"q/网易-462.html","excerpt":"**关键词**：斐波拉契数列、尾调优化 斐波那契数列是指：0、1、1、2、3、5、8、13、21、34、……，在数学上，斐波那契数列以如下被以递归的方法定义： F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) (n > 1) 用 JS 实现斐波那契数列可以如下： 这个函数用递归的方式实"},{"id":"445","title":"执行上下文栈是什么【热度: 632】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/445","page":"q/网易-445.html","excerpt":"**关键词**：执行上下文栈 在JavaScript中，执行上下文栈（Execution Context Stack）是用于跟踪和管理函数执行的机制。每当JavaScript代码执行到一个函数时，就会创建一个执行上下文（Execution Context）并被推入执行上下文栈的顶部。当函数执行完毕后，执行上下文将从栈中"},{"id":"431","title":"判断数组的方式有哪些【热度: 509】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/431","page":"q/网易-431.html","excerpt":"**关键词**：js判断数组方法 在 JavaScript 中，判断一个值是否为数组有多种方式，以下是几种常见的方法： Array.isArray(): 使用 Array.isArray() 方法可以判断一个值是否为数组。它是 ES5 中新增的方法，返回一个布尔值。 instanceof 操作符：可以使用 instan"},{"id":"408","title":"token过期后，页面如何实现无感刷新【热度: 485】","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/408","page":"q/网易-408.html","excerpt":"**关键词**：token过期刷新、token刷新 当 token 过期后，实现无感刷新页面的一种常见方式是使用刷新 token 的机制。下面是一个基本的实现思路： 在前端应用中，使用某种方式（例如 Cookie、Local Storage）存储 token。 在每次发起请求时，通过拦截器或者请求中间件检查 token"},{"id":"394","title":"[webpack] 提高 webpack 的构建速度的办法有哪些【热度: 1,208】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/394","page":"q/网易-394.html","excerpt":"**关键词**：webpack 构建、webpack 构建优化、webpack 构建速度 以下是一些可以提高Webpack构建速度的办法： 使用更快的构建工具：升级Webpack到最新版本，因为每个新版本通常都会带来性能改进和优化。 减少文件的数量：通过代码拆分和按需加载等技术，将代码拆分成更小的模块，减少每次构建需要"},{"id":"377","title":"如何编写一个 babel 插件【热度: 1,062】","category":"网易","labels":["工程化","网易"],"url":"https://github.com/pro-collection/interview-question/issues/377","page":"q/网易-377.html","excerpt":"**关键词**：babel插件、babel插件api、babel插件代码示例 编写一个 babel 插件的基本步骤 编写一个 Babel 插件可以让你自定义转换、分析或操作 JavaScript 代码。下面是编写 Babel 插件的基本步骤： 安装 Babel：首先，确保你已经安装了 Babel 的相关工具和依赖。可以"},{"id":"362","title":"手写 JSON.stringify 和 手写 JSON.parse 实现【热度: 134】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/362","page":"q/网易-362.html","excerpt":"**关键词**：手写 JSON.stringify、手写 JSON.parse 手写JSON.stringify JSON.stringify 是一个将 JavaScript 对象或值转换为 JSON 字符串的函数。下面是一个简化的实现，主要考虑以下几种类型：字符串、数字、布尔值、对象和数组。 请注意，这个实现有很多限"},{"id":"355","title":"如何防止 CSS 阻塞渲染【热度: 213】","category":"网易","labels":["CSS","网易"],"url":"https://github.com/pro-collection/interview-question/issues/355","page":"q/网易-355.html","excerpt":"**关键词**：css 阻塞渲染、css 阻塞 当浏览器遇到一个 <link> 标签时，它会停止解析 HTML 并发出一个单独的网络请求去加载外部样式表。 这意味着，如果样式表很大或者网络速度很慢，它将阻止页面的渲染。阻止 CSS 渲染可能会导致页面看起来很糟糕，用户无法立即看到页面内容。 有一些方法可以防止或减轻 C"},{"id":"344","title":"[React] createPortal 了解多少？【热度: 597】","category":"网易","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/344","page":"q/网易-344.html","excerpt":"**关键词**：react createPortal createPortal 是 React 中一个用于将子元素渲染到指定 DOM 元素下的 API。 在 React 应用中，通常会通过组件树传递 props、状态等数据来渲染 UI，并由 React 自动管理 DOM 元素的创建、更新和销毁等操作。不过，有时我们需要"},{"id":"303","title":"dom 渲染能使用 GPU 加速吗？【热度: 494】","category":"网易","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/303","page":"q/网易-303.html","excerpt":"只有部分情况可以使用 GPU 加速渲染。浏览器将 DOM 元素转换为图层（Layer），然后将图层绘制到屏幕上。在某些情况下，这些图层可以使用 GPU 加速，从而提高渲染性能。 浏览器将具有以下属性之一的元素视为单独的图层： 使用 CSS 3D 变换或透视属性的元素 使用 CSS 滤镜的元素 使用 will-chang"},{"id":"200","title":"手写订阅-发布模式","category":"网易","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/200","page":"q/网易-200.html","excerpt":"订阅-发布模式是一种常用的设计模式，它可以实现对象间的解耦，让它们不需要相互知道对方的存在，只需要关注自己需要订阅的事件即可。当一个对象的状态发生变化时，它可以发布一个事件通知其他对象，其他对象可以订阅该事件，当事件发生时得到通知并执行相应的处理。 在 JavaScript 中，订阅-发布模式也被称为事件模型。事件模型"},{"id":"199","title":"手写 观察者模式","category":"网易","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/199","page":"q/网易-199.html","excerpt":"观察者模式（又称发布-订阅模式）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，其相关的依赖对象都能够得到通知并被自动更新。 在 JavaScript 中实现观察者模式，可以分为以下几个步骤： 创建一个主题对象（Subject），用来存储观察者对象，并提供添加、删除、通知观察者的"},{"id":"198","title":"介绍下观察者模式和订阅-发布模式的区别？","category":"网易","labels":["JavaScript","网易","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/198","page":"q/网易-198.html","excerpt":"观察者模式和订阅-发布模式都属于事件模型，它们都是为了解耦合而存在，但是它们之间还是有一些不同之处的： 观察者模式中，主题（被观察者）和观察者之间是直接联系的，观察者订阅主题，主题状态发生变化时会直接通知观察者；而订阅-发布模式中，发布者和订阅者之间没有直接的联系，发布者发布消息到消息中心，订阅者从消息中心订阅消息。 "},{"id":"197","title":"A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态？(了解即可)","category":"网易","labels":["网络","网易"],"url":"https://github.com/pro-collection/interview-question/issues/197","page":"q/网易-197.html","excerpt":"当 B 机器重启时，TCP 连接会被断开，此时 A 机器会检测到 TCP 连接异常断开，将 TCP 状态修改为 FIN\\_WAIT\\_1 状态。A 机器会继续等待来自 B 机器的响应，如果等待的时间超过了一定时间（通常为几分钟），A 机器会放弃等待并关闭 TCP 连接，将 TCP 状态修改为 CLOSED 状态。"},{"id":"974","title":"如果 cookie 没有设置  maxage， 那么这一条 cookie 失效时间改怎么算【热度: 42】","category":"小红书","labels":["网络","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/974","page":"q/小红书-974.html","excerpt":"**关键词**：cookie 失效时间 如果 Cookie 没有设置 max-age，它通常被视为会话 Cookie，其失效时间的计算方式如下： **一、会话 Cookie 的失效时间** 浏览器关闭时：一般情况下，当用户关闭浏览器时，会话 Cookie 会被删除。这意味着只要浏览器处于打开状态，并且用户在与同一个网站"},{"id":"707","title":"在表单校验场景中， 如何实现页面视口滚动到报错的位置【热度: 248】","category":"小红书","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/707","page":"q/小红书-707.html","excerpt":"**关键词**：滚动到页面视口 基本原理 页面是用户与程序进行交互的界面，在对应表单校验场景中，通常会因为有填写错误需要用户进行修改。为了提高用户体验，可以将页面滚动至对应表单报错的位置，使得用户立即可见错误并进行修改。这通常可以通过 JavaScript 编程实现。 要注意的是，实现滚动至错误表单，一般需要几个步骤："},{"id":"706","title":"交叉观察器 API IntersectionObserver 详解【热度: 665】","category":"小红书","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/706","page":"q/小红书-706.html","excerpt":"**关键词**：交叉观察器 API、IntersectionObserver 详解 IntersectionObserver API 是现代浏览器提供的一个强大的 API，用于性能友好地跟踪元素是否进入、离开或穿过另一个元素（通常是视口）的边界。这个 API 特别适用于执行懒加载、实现无限滚动、检测广告展示等功能，因为"},{"id":"705","title":"滚动混动加载原理是什么， 用 JS 代码简单实现一个虚拟滚动加加载。【热度: 354】","category":"小红书","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/705","page":"q/小红书-705.html","excerpt":"**关键词**：虚拟滚动、虚拟加载 原理 虚拟滚动（Virtual Scrolling）是一种性能优化的手段，通常用于处理长列表的显示问题。在传统的滚动加载中，当面对成千上万项的长列表时，直接在 DOM 中创建并展示所有项会导致严重的性能问题，因为浏览器需要渲染所有的列表项。而虚拟滚动的核心原理是仅渲染用户可视范围内的"},{"id":"701","title":"[React] 为什么 react 组件， 都必须要申明一个 `import React from 'react';`【热度: 115】","category":"小红书","labels":["web框架","工程化","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/701","page":"q/小红书-701.html","excerpt":"**关键词**：babel 编译 react 首先要知道一个事情： **JSX 是无法直接运行在浏览器环境**。 原因 JSX 语法不能直接被浏览器解析和运行，因此需要插件 @babel/plugin-transform-react-jsx 来转换语法，使之能够在浏览器或任何 JavaScript 环境中执行。 所以 "},{"id":"700","title":"babel 核心库有哪些？【热度: 35】","category":"小红书","labels":["工程化","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/700","page":"q/小红书-700.html","excerpt":"**关键词**：babel 核心库 Babel 是一个 JavaScript 编译器，主要用于将 ES6 及以上版本的代码转换为向后兼容的 JavaScript 语法，以便在当前和旧版浏览器或环境中执行。核心的 Babel 库主要包括： **@babel/core**: 这是 Babel 编译器的核心包，提供了 Bab"},{"id":"1136","title":"react 开发的应用里面， 如何给系统设置一个全局的崩溃的提示页面【热度: 725】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1136","page":"q/小米-1136.html","excerpt":"**关键词**：崩溃提示 在 React 应用中设置全局崩溃提示页面，核心是通过 **错误边界边界（Error Boundary）** 来捕获子组件树中的 JavaScript 错误，并显示备用 UI。以下是具体实现方案： 实现说明 **错误边界组件（ErrorBoundary）** 这是一个 React 类组件，利用"},{"id":"1066","title":"Object.defineProperty 是否可以监听拦截数组变化【热度: 144】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1066","page":"q/小米-1066.html","excerpt":"**关键词**：Object.defineProperty 监听数组变化 **基本原理与部分可行性** Object.defineProperty可以用于监听和拦截数组的某些变化，但不是原生地对所有数组操作都能很好地监听。 数组在 JavaScript 中是特殊的对象，其索引可以看作是对象属性。理论上，我们可以使用Ob"},{"id":"1022","title":"闭包有哪些使用场景，请举例【热度: 679】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1022","page":"q/小米-1022.html","excerpt":"**关键词**：闭包使用场景 闭包在 JavaScript 中有很多实用的使用场景，以下是一些主要的场景： **一、数据隐藏和封装** 保护变量： 闭包可以创建一个私有作用域，将变量封装在函数内部，防止外部直接访问和修改。只有通过特定的函数接口才能访问和操作这些变量。 例如： 在这个例子中，count变量被封装在cre"},{"id":"983","title":"[React] 在 setState 时发生了什么【热度: 169】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/983","page":"q/小米-983.html","excerpt":"**关键词**：React setState 过程 在 React 中，当调用setState时，会发生以下一系列事情： **一、触发状态更新** **调用 setState 方法**： 当在 React 组件中调用setState方法时，React 会将这个状态更新请求排队。这意味着 React 不会立即更新组件的状"},{"id":"969","title":"http 缓存中 no-cache 与 no-store 的区别是什么【热度: 564】","category":"小米","labels":["网络","web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/969","page":"q/小米-969.html","excerpt":"**关键词**：http 缓存 在 HTTP 缓存中，no-cache和no-store是两种不同的缓存指令，它们的区别如下： **一、no-cache** **含义**： 当设置了no-cache指令时，这并不意味着不使用缓存。相反，它表示在使用缓存之前，必须先与服务器进行验证，以确定缓存的资源是否仍然有效。 这意味"},{"id":"968","title":"如何进行代码质量检测【热度: 497】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/968","page":"q/小米-968.html","excerpt":"**关键词**：代码质量检查 作者备注 开发性质的话题， 没有统一答复， 也没有最好答复， 这边给几个思考的方向 进行代码质量检测可以从以下几个方面入手： **一、静态代码分析** 使用静态代码分析工具 例如 SonarQube、Checkstyle、PMD 等。这些工具可以检查代码中的潜在问题，如代码风格不符合规范、"},{"id":"939","title":"手写实现 lodash.flattenDeep 将array递归为一维数组【热度: 345】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/939","page":"q/小米-939.html","excerpt":"**关键词**：lodash.flattenDeep 实现 以下是用 JavaScript 手写实现类似于 lodash.flattenDeep 的函数来将数组递归展平为一维数组： 你可以使用以下方式测试这个函数："},{"id":"936","title":"[Vue] 对比一下 vuex 和 Pinia 两个状态库【热度: 300】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/936","page":"q/小米-936.html","excerpt":"**关键词**：vue 状态库对比 Vuex 和 Pinia 都是用于 Vue 应用程序的状态管理库，它们有一些相似之处，但也存在一些差异。以下是它们的对比： **一、相似之处** **集中式状态管理**： 两者都提供了一种集中式的方式来管理应用程序的状态。这使得状态可以在不同的组件之间共享，并且可以更容易地跟踪和调试"},{"id":"891","title":"发送请求的时候， method = OPTIONS 是什么请求【热度: 717】","category":"小米","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/891","page":"q/小米-891.html","excerpt":"**关键词**：预检请求 当看到 method 为 OPTIONS 的请求时，这是一个 HTTP OPTIONS 请求。OPTIONS 请求是 HTTP/1.1 协议中定义的一种方法，用于获取目的资源（服务器）支持的通信选项。这种请求主要被用于 CORS（Cross-Origin Resource Sharing，跨域"},{"id":"881","title":"flex 布局中子元素不压缩， 该如何设置属性【热度: 200】","category":"小米","labels":["CSS","小米"],"url":"https://github.com/pro-collection/interview-question/issues/881","page":"q/小米-881.html","excerpt":"**关键词**：flex 子元素不压缩 在 Flex 布局中，如果你想要子元素在容器内不被压缩，即保持其原始尺寸或指定尺寸，不受容器大小变化的影响，可以通过设置子元素的flex-shrink属性来实现。flex-shrink属性决定了当父容器大小小于其所有 flex 项总大小时，各 flex 项的缩小比例。默认值是 1"},{"id":"876","title":"eslint 如何设置只校验本次 MR 变更的文件内容【热度: 200】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/876","page":"q/小米-876.html","excerpt":"**关键词**：eslint 和 git 结合校验 要让 ESLint 只校验在 Merge Request (MR)、Pull Request (PR)或代码提交中变更的文件，可以采用几种方法。下面是几个可能的方案： 1. 命令行 Git 和 ESLint 组合使用 通过组合git命令和eslint命令来实现。首先，"},{"id":"874","title":"如何开启 ts 类型强校验，ts 类型错误 webpack 直接编译失败【热度: 232】","category":"小米","labels":["TypeScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/874","page":"q/小米-874.html","excerpt":"**关键词**：ts 类型强校验 要开启 TypeScript 的类型强校验，并使得 Webpack 在遇到类型错误时编译失败，可以通过以下步骤实现： 1. 开启 TS 严格模式 首先，在tsconfig.json中启用严格模式。这是通过设置\"strict\": true来实现的，这个选项会启用一系列严格的类型检查，帮助"},{"id":"869","title":"实现阿拉伯数字转中文【热度: 673】","category":"小米","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/869","page":"q/小米-869.html","excerpt":"**关键词**：数字转中文 将阿拉伯数字转换成中文数字，主要考虑到以下几个转换规则： **基本数字**：0-9 对应的汉字数字。 **单位**：十、百、千、万、亿等。 **规则**：数字从右到左，每 4 位一小节，小节内部和小节之间的转换规则。 实现思路 将阿拉伯数字分解成单个数字，从右到左进行处理。 对每 4 位数字"},{"id":"857","title":"可有办法判断用户的网络条件, 判断网速快慢，网络状态？【热度: 195】","category":"小米","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/857","page":"q/小米-857.html","excerpt":"**关键词**：网络状态 确定用户的网络条件，包括网络速度和连接状态，对于提供优质用户体验至关重要。以下是一些方法可以帮助你判断用户的网络条件： 1. **Navigator Connection API** 这个 API 提供有关系统的网络连接的信息，如网络的类型和下载速度。这个 API 的支持度不是全局性的，但在许"},{"id":"738","title":"jsBridge 是什么？原理是啥？【热度: 220】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/738","page":"q/小米-738.html","excerpt":"**关键词**：jsBridge 原理 jsBridge是一种在 Web 开发中常用的技术，通常指的是 JavaScript Bridge 的缩写，它是一种在 Web 视图（如 WebView）和原生应用之间进行通信的机制。jsBridge 使得原生代码（如 Android 的 Java/Kotlin 或 iOS 的 "},{"id":"737","title":"在 JS 中， 如何解决递归导致栈溢出问题？【热度: 269】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/737","page":"q/小米-737.html","excerpt":"**关键词**：栈溢出问题 在 JavaScript 中，递归如果执行过深，确实有可能导致“栈溢出(stack overflow)”错误，因为每次函数调用都会向调用栈中添加一个新的帧，而每个线程的调用栈都有其最大容量限制。当这个容量被超过时，就会发生栈溢出。为了解决这个问题，你可以使用几种不同的方法： 尾调用优化（Ta"},{"id":"666","title":"git 仓库迁移应该怎么操作【热度: 160】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/666","page":"q/小米-666.html","excerpt":"**关键词**：git 仓库迁移 如果你想迁移仓库并保留原始仓库的所有提交历史、分支和标签，你可以使用以下步骤： 方法一：使用 git clone 和 git push **在仓库 B 中创建新的仓库。** **在本地克隆仓库 A：** 使用 --mirror 选项克隆仓库会保留所有分支、标签和提交历史。 **修改远程"},{"id":"640","title":"后端一次性返回树形结构数据，数据量非常大, 前端该如何处理？【热度: 171】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/640","page":"q/小米-640.html","excerpt":"**关键词**：大数据处理 当后端一次性返回的树形结构数据量非常大，导致前端一次性计算和渲染会栈溢出的情况时，可以考虑以下几种处理方式： 分批处理：将大量的树形数据分为多个批次进行处理和渲染。前端可以通过递归或循环的方式，每次处理一部分数据，并在渲染完成后再处理下一部分数据。这样可以避免一次性处理大量数据造成栈溢出的问"},{"id":"615","title":"介绍一下迭代器 Iterator, 以及有哪些用法【热度: 645】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/615","page":"q/小米-615.html","excerpt":"**关键词**：迭代器 Iterator 1、Iterator 的概念 JavaScript 原有的表示 “ 集合 ” 的数据结构，主要是数组（ Array ）和对象（ Object ）， ES6 又添加了 Map 和 Set 。 这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 M"},{"id":"613","title":"箭头函数的作用以及使用场景【热度: 760】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/613","page":"q/小米-613.html","excerpt":"**特点** **简洁的语法形式**：箭头函数使用了更简洁的语法形式，省略了传统函数声明中的function关键字和大括号。它通常可以在更少的代码行数中表达相同的逻辑。 **没有自己的this**：箭头函数没有自己的this绑定，它会捕获所在上下文的this值。这意味着箭头函数中的this与其定义时所在的上下文中的th"},{"id":"544","title":"web 网页如何禁止别人移除水印【热度: 540】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/544","page":"q/小米-544.html","excerpt":"**关键词**：前端防止移除水印 关于加水印的问题， 可以看这篇文档： https://github.com/pro-collection/interview-question/issues/351 关于如何防止移除水印： 可以通过监听 DOM 的变化来检测是否有人删除水印，可以使用 MutationObserver "},{"id":"533","title":"单点登录是什么， 具体流程是什么【热度: 1,168】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/533","page":"q/小米-533.html","excerpt":"**关键词**：单点登录流程 SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport"},{"id":"532","title":"什么是 JWT【热度: 428】","category":"小米","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/532","page":"q/小米-532.html","excerpt":"**关键词**：jwt 基本概念 JWT是JSON Web Token的缩写，是一种用于在不同系统之间安全传输信息的开放标准。JWT通常用于身份验证和授权，它由三部分组成：头部（header）、载荷（payload）和签名（signature）。 头部包含了关于令牌的元数据和算法信息，通常包括令牌的类型（例如JWT）、"},{"id":"518","title":"HTML 属性 crossorigin 的作用是什么【热度: 267】","category":"小米","labels":["浏览器","小米"],"url":"https://github.com/pro-collection/interview-question/issues/518","page":"q/小米-518.html","excerpt":"**关键词**：crossorigin 属性、crossorigin 作用、crossorigin 资源错误处理 crossorigin 属性在 <audio>、<img>、<link>、<script> 和 <video> 元素中有效，它们提供对 CORS 的支持，定义该元素如何处理跨源请求，从而实现对该元素获取数据"},{"id":"517","title":"html rel 属性 的参数 preload和prefetch 的作用是什么【热度: 1,057】","category":"小米","labels":["浏览器","小米"],"url":"https://github.com/pro-collection/interview-question/issues/517","page":"q/小米-517.html","excerpt":"**关键词**：rel preload 作用、rel prefetch 作用、rel defer 作用、rel prefetch rel 属性定义了所链接的资源与当前文档的关系，在 <a>、<area> 和 <link> 元素上有效。支持的值取决于拥有该属性的元素。 preload和prefetch是浏览器提供的两种对"},{"id":"467","title":"如何理解研发流程和研发效率，如何保障研发效率","category":"小米","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/467","page":"q/小米-467.html","excerpt":"保障研发效率 研发流程指的是从需求调研、设计、开发、测试、发布、维护等一系列环节组成的整个研发过程。它是实现软件产品的必经之路，可以帮助团队规范化、标准化研发流程，提高研发效率、降低研发成本、提高产品质量和用户满意度。 研发效率指的是在研发流程中，完成同样的工作所需要的时间和成本，也就是研发效率越高，就可以在同样的时间"},{"id":"459","title":"[代码实现] 手写实现 Object.create【热度: 179】","category":"小米","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/459","page":"q/小米-459.html","excerpt":"**关键词**：Object.create实现、Object.create手写 Object.create() 方法可以用于创建一个新对象，使其原型与指定的对象完全相同。可以通过以下方式手写实现 Object.create() 方法。 该实现方式创建了一个名为 F 的空函数，将其原型设置为传入的 proto 对象，然后"},{"id":"448","title":"[代码实现] 手写实现一个缓存函数 memoize【热度: 787】","category":"小米","labels":["小米","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/448","page":"q/小米-448.html","excerpt":"**关键词**：缓存函数实现、memoize函数 用于创建一个带有缓存功能的函数。下面是一个简化版本的手写实现，展示了如何自己实现 memoize 函数： 上述代码中的 memoize 函数接受一个函数 func 作为参数，并返回一个新的函数。返回的函数具有缓存的能力，即根据参数的不同缓存计算结果。 在返回的函数内部，"},{"id":"413","title":"什么是正向代理，反向代理【热度: 1,294】","category":"小米","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/413","page":"q/小米-413.html","excerpt":"**关键词**：正向代理反向代理概念 概念 正向代理（Forward Proxy）和反向代理（Reverse Proxy）都是常见的代理服务器架构，用于在客户端与目标服务器之间进行中转和处理请求的工作。它们的区别在于代理的位置和作用方式不同。 正向代理： 代理位于客户端与目标服务器之间，代理服务器充当客户端的代表。 客"},{"id":"401","title":"ajax 是否支持取消请求","category":"小米","labels":["网络","小米"],"url":"https://github.com/pro-collection/interview-question/issues/401","page":"q/小米-401.html","excerpt":"**xhr.abort() 方法用于中止当前的请求**。调用该方法会导致 XHR 对象触发 abort 事件，且触发 readystatechange 事件的处理函数，xhr.readyState 的值将变为 0。 下面是一个示例代码，展示了如何使用标志位实现取消请求的效果： 在上述示例代码中，添加了一个 cancel"},{"id":"388","title":"哪些原因会导致js里this指向混乱?【热度: 1,282】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/388","page":"q/小米-388.html","excerpt":"**关键词**：js 指向 JavaScript 中 this 指向混乱的原因主要有以下几个： 函数调用方式不同：JavaScript 中函数的调用方式决定了 this 的指向。常见的函数调用方式有函数调用、方法调用、构造函数调用和箭头函数调用。不同的调用方式会导致 this 指向不同的对象，容易引发混乱。 丢失绑定："},{"id":"378","title":"常见 web 安全解析【热度: 1,968】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/378","page":"q/小米-378.html","excerpt":"**关键词**：XSS攻击、CSRF攻击、点击劫持共计、URL跳转漏洞、SQL注入攻击、OS命令注入攻击 参考文档： https://github.com/ljianshu/Blog/issues/56"},{"id":"371","title":"Object.prototype.hasOwnProperty() 作用是啥【热度: 1,176】","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/371","page":"q/小米-371.html","excerpt":"**关键词**：Object.prototype.hasOwnProperty Object.prototype.hasOwnProperty() Object.prototype.hasOwnProperty()是JavaScript中Object原型对象上的方法。它用于检查一个对象是否具有指定的属性（即对象自身拥有"},{"id":"356","title":"CSS 绘制三角形【热度: 324】","category":"小米","labels":["CSS","小米"],"url":"https://github.com/pro-collection/interview-question/issues/356","page":"q/小米-356.html","excerpt":"**关键词**：css 绘制、css 三角形 在CSS中，你可以使用多种方法来实现三角形。以下是几种常用的方法和相应的代码示例： 使用边框： 这个方法通过设置元素的边框来创建三角形，其中左右边框设为透明，底边框设置为你想要的颜色。 使用伪元素： 这个方法使用伪元素 ::before 来创建三角形，通过设置其边框的宽度和"},{"id":"351","title":"前端水印了解多少？【热度: 641】","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/351","page":"q/小米-351.html","excerpt":"**关键词**：前端 明水印 暗水印 明水印和暗水印的区别 前端水印可以分为明水印和暗水印两种类型。它们的区别如下： 明水印：明水印是通过在文本或图像上覆盖另一层图像或文字来实现的。这种水印会明显地出现在页面上，可以用来显示版权信息或其他相关信息。 暗水印：暗水印是指在文本或图像中隐藏相关信息的一种技术。这种水印不会直"},{"id":"341","title":"npm script 生命周期有哪些?【热度: 519】","category":"小米","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/341","page":"q/小米-341.html","excerpt":"**关键词**：npm 生命周期、script 生命周期 安装和卸载 | 脚本名称 | 阶段 | 描述 | 执行时机 | |-----------------|--------------|-----------------------------------------------------------------"},{"id":"336","title":"[React] 事件绑定原理【热度: 1,097】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/336","page":"q/小米-336.html","excerpt":"**关键词**：react事件绑定、react合成事件、react事件监听 绑定原理与过程 在 React 中，事件绑定不同于传统的直接在 HTML 元素添加事件监听器的方式。React 的事件绑定是建立在自定义组件上的，因此需要对 React 组件的生命周期进行理解。 React 事件绑定的原理可以概括为三个步骤： "},{"id":"315","title":"npx 了解多少？【热度: 290】","category":"小米","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/315","page":"q/小米-315.html","excerpt":"**关键词**：npx 原理、npx 作用、npx 执行 **npx 是什么** npx是一个由Node.js官方提供的用于快速执行npm包中的可执行文件的工具。它可以帮助我们在不全局安装某些包的情况下，直接运行该包提供的命令行工具。npx会在执行时，检查本地项目中是否安装了对应的依赖，如果没有安装则会自动下载安装，并"},{"id":"314","title":"npm lock 文件了解多少？【热度: 258】","category":"小米","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/314","page":"q/小米-314.html","excerpt":"**关键词**：npm lock 原理、npm lock 实现、npm lock 作用 **作用** npm lock 文件（如 package-lock.json 或 yarn.lock）的作用是确保在不同机器上或在不同时间安装相同的依赖包时，获得相同的版本，以避免由于版本不一致而产生的问题。在安装依赖包时，npm "},{"id":"306","title":"[React] 如何监听路由变化？【热度: 679】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/306","page":"q/小米-306.html","excerpt":"**依赖** react-router-dom v6 react v18 实现 监听的核心原理基于useEffect，和useLocation，通过useEffect监听当前location的变化，这样就实现的最基本的监听结构： 然后，我们可以在useEffect中记录和更新from、to的值，可以根据自己的需要选择f"},{"id":"305","title":"[React] 开发过程中有哪些性能优化手段？【热度: 1,511】","category":"小米","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/305","page":"q/小米-305.html","excerpt":"路由懒加载 两种方式可实现: 使用 React 中 Suspense,lazy 使用 react-loadable React 中 Suspense,lazy 应用的组件需要使用 lazy 的方式引入， 且使用 Suspense 包裹异步加载的组件 react-loadable 受控性组件颗粒化 ，独立请求服务渲染单元"},{"id":"235","title":"[webpack] 什么情况下 webpack treeShaking 会失效？","category":"小米","labels":["工程化","小米"],"url":"https://github.com/pro-collection/interview-question/issues/235","page":"q/小米-235.html","excerpt":"以下是一些可能导致 webpack tree shaking 失效的情况 代码中使用了动态引入（Dynamic Imports）的语法，这种情况下，webpack 无法确定哪些代码会被使用，因此不会进行 tree shaking。 代码使用了函数式编程的方式，比如使用了 map、filter、reduce 等高阶函数，"},{"id":"232","title":"使用同一个链接，  如何实现 PC 打开是 web 应用、手机打开是一个 H5 应用？","category":"小米","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/232","page":"q/小米-232.html","excerpt":"可以通过根据请求来源（User-Agent）来判断访问设备的类型，然后在服务器端进行适配。例如，可以在服务器端使用 Node.js 的 Express 框架，在路由中对不同的 User-Agent 进行判断，返回不同的页面或数据。具体实现可以参考以下步骤： 根据 User-Agent 判断访问设备的类型，例如判断是否为"},{"id":"227","title":"进程、线程、协程分别是什么概念？","category":"小米","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/227","page":"q/小米-227.html","excerpt":"进程（Process）和 线程（Thread） 进程（Process）和 线程（Thread）是操作系统中的重要概念。 **进程是指计算机中已经运行的程序，它是操作系统资源分配的最小单位**。进程拥有独立的内存空间和系统资源，如打开的文件、网络连接等。在操作系统中，每个进程都拥有一个唯一的标识符，称为进程ID。 **线"},{"id":"206","title":"浏览器缓存中 Memory Cache 和 Disk Cache， 有啥区别？","category":"字节跳动","labels":["网络","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/206","page":"q/字节跳动-206.html","excerpt":"Memory Cache 和 Disk Cache 的区别 在浏览器缓存中，Memory Cache 和 Disk Cache 是两种不同的缓存类型，它们有以下区别： 存储位置：Memory Cache 存储在内存中，而 Disk Cache 存储在硬盘中。 读取速度：Memory Cache 读取速度比 Disk C"},{"id":"202","title":"浏览器 和 Node 事件循环有区别吗？","category":"字节跳动","labels":["JavaScript","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/202","page":"q/字节跳动-202.html","excerpt":"浏览器和Node.js事件循环在本质上是相同的，它们都是基于事件循环模型实现异步操作。但是它们的实现细节和环境限制有所不同。 在浏览器中，事件循环模型基于浏览器提供的EventTarget接口，包括浏览器环境下的DOM、XMLHttpRequest、WebSocket、Web Worker等等，所有的异步任务都会被推入"},{"id":"201","title":"Redux 和 Vuex 的设计思想是什么？","category":"字节跳动","labels":["JavaScript","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/201","page":"q/字节跳动-201.html","excerpt":"Redux和Vuex都是用于在前端应用中管理状态的JavaScript库。它们的设计思想都基于Flux架构，强调单向数据流的概念，以避免数据的混乱和不可预测的状态变化。 Redux的设计思想可以总结为三个原则： 单一数据源：Redux中所有的状态数据都保存在单一的store对象中，便于管理和维护。 状态只读：Redux"},{"id":"1131","title":"用 css 实现一个 loading 动画， 该如何做（转圈）【热度: 180】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/1131","page":"q/css-1131.html","excerpt":"**关键词**：css 动画 作者备注 这个问题主要是对 css 动画的考察， 比直接问 animation 和 transform 属性有意义。 可以利用 CSS 的 animation 和 transform 属性，通过旋转一个带有渐变边框的元素来实现。 这个转圈 loading 动画的核心实现思路如下： **创建"},{"id":"1037","title":"z-index: 999 元素一定会置于 z-index: 0 元素之上吗【热度: 100】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/1037","page":"q/css-1037.html","excerpt":"**关键词**：z-index 生效情况 设置了z-index: 999的元素不一定会置于z-index: 0的元素之上。 **一、z-index 的作用机制** z-index属性用于控制元素在 z 轴上的堆叠顺序，即决定了元素在垂直于屏幕平面的方向上的前后显示顺序。 只有当元素的定位属性（如position: re"},{"id":"1032","title":"CSS 如何实现固定长宽比的元素【热度: 546】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/1032","page":"q/css-1032.html","excerpt":"**关键词**：固定长宽比 在 CSS 中，可以通过以下几种方式实现固定长宽比的元素： **一、使用 padding 实现** 原理： 利用元素的padding属性以百分比形式设置时是相对于父元素宽度的特点，通过设置padding-top或padding-bottom来实现固定的长宽比。 示例代码： 在这个例子中，设置"},{"id":"1008","title":"css 如何实现分栏布局【热度: 502】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/1008","page":"q/css-1008.html","excerpt":"**关键词**：分栏布局 在前端布局中，可以通过 CSS 实现分栏布局。以下是几种常见的实现方式： **一、使用float属性** **基本原理**： float属性可以让元素向左或向右浮动，从而实现多栏布局。通过将多个元素设置为浮动，可以让它们并排显示。 例如，可以将一个容器中的子元素设置为左浮动或右浮动，以实现两栏"},{"id":"975","title":"css 中属性选择器及类选择器的权重哪个高【热度: 642】","category":"CSS","labels":["CSS","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/975","page":"q/css-975.html","excerpt":"**关键词**：选择器权重 作者备注 这个是一个非常贼的问题， 可能很多都只是知道， 【类选择器、属性选择器和伪类选择器】 都为为一样的， 但是并不知道 【类选择器、属性选择器】之间还有优先级关系 在 CSS 中，类选择器的权重高于属性选择器。 **一、权重计算规则** CSS 的权重是一个用于确定当多个选择器应用于同"},{"id":"884","title":"介绍一下 position sticky【热度: 826】","category":"CSS","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/884","page":"q/css-884.html","excerpt":"**关键词**：position sticky position: sticky; 是 CSS 中的一个定位属性值，它允许元素在页面滚动到某个阈值时“固定”在位置上，而在达到这个阈值之前，元素会像正常文档流中的元素一样表现（也就是说，在特定条件下它表现得像 position: relative;，在另一些条件下表现得像"},{"id":"881","title":"flex 布局中子元素不压缩， 该如何设置属性【热度: 200】","category":"CSS","labels":["CSS","小米"],"url":"https://github.com/pro-collection/interview-question/issues/881","page":"q/css-881.html","excerpt":"**关键词**：flex 子元素不压缩 在 Flex 布局中，如果你想要子元素在容器内不被压缩，即保持其原始尺寸或指定尺寸，不受容器大小变化的影响，可以通过设置子元素的flex-shrink属性来实现。flex-shrink属性决定了当父容器大小小于其所有 flex 项总大小时，各 flex 项的缩小比例。默认值是 1"},{"id":"870","title":"内联加载样式和外联加载样式有啥区别【热度: 383】","category":"CSS","labels":["CSS","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/870","page":"q/css-870.html","excerpt":"**关键词**：样式加载 内联样式（Inline Style）和外联样式（External Style）是 CSS 应用在 HTML 文档中的两种不同方法，它们主要的区别在于如何将 CSS 规则与 HTML 元素关联起来。 内联样式 **定义方式**：通过元素的style属性直接在 HTML 标签内定义 CSS 样式。"},{"id":"868","title":"flex 布局中，有哪些常用的属性，分别作用是啥【热度: 300】","category":"CSS","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/868","page":"q/css-868.html","excerpt":"**关键词**：flex 属性 Flex 布局（即 Flexible Box 布局）提供了一种更有效的方式来布置、对齐和分布容器内项目的空间，即使它们的大小是未知或者动态变化的。以下是 Flex 布局中一些常用属性及其作用的简介： 容器属性（应用于 flex 容器） **display**： 设置为flex或inlin"},{"id":"832","title":"CSS 中隐藏元素的方法有哪些？【热度: 273】","category":"CSS","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/832","page":"q/css-832.html","excerpt":"**关键词**：CSS 隐藏元素 在 CSS 中，隐藏元素可以通过多种方式实现，每种方式有其特定的使用场景。这里列出了一些常用的方法： 1. display: none; 完全移除元素，使其不占据任何空间，也不会在文档流中占位。元素及其所有子元素都不会显示。 2. visibility: hidden; 使元素不可见，"},{"id":"814","title":"盒模型【热度: 753】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/814","page":"q/css-814.html","excerpt":"**关键词**：盒模型 盒模型 CSS3 中的盒模型有以下两种：标准盒子模型、IE 盒子模型 盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。 **在标准盒模型性中** 盒子在网页中实际占用: 宽 = width + padding2 + border2 + marg"},{"id":"798","title":"px 如何转为 rem【热度: 545】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/798","page":"q/css-798.html","excerpt":"**关键词**：移动端适配 px（像素）转换为 rem（根元素字体大小的相对单位）需要先确定一个基准的根元素字体大小。 通常，我们将根元素（<html>）的字体大小设置为一个特定的值，比如 16px（这是常见的默认值，但您可以根据设计需求进行修改）。 假设根元素的字体大小为 16px，那么转换公式为：rem 值 = p"},{"id":"792","title":"css 实现打字机效果【热度: 96】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/792","page":"q/css-792.html","excerpt":"**关键词**：animation 帧动画、animation steps 属性 主要是对 css 动画的一个实际应用考察 以下是一个使用 CSS 实现简单打字机效果的示例代码： 在上述代码中，.typewriter 类的元素用于实现打字机效果。 animation: typing 4s steps(30), blin"},{"id":"789","title":"css 实现翻牌效果【热度: 116】","category":"CSS","labels":["CSS","快手"],"url":"https://github.com/pro-collection/interview-question/issues/789","page":"q/css-789.html","excerpt":"**关键词**：css 动效应用 主要是考察几个属性的使用 transform: rotateY 用于 Y 轴旋转 transition 用于过度动画 还有一个要点： 翻转卡牌的时候，正面在上， 要将背面隐藏； 背面在上， 要将正面隐藏； 效果如下： **实现比较简单， 直接贴代码**："},{"id":"787","title":"flex：1 代表什么【热度: 400】","category":"CSS","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/787","page":"q/css-787.html","excerpt":"**关键词**：flex 布局相关属性问题 在 CSS 的弹性盒模型（Flexbox）中，flex: 1表示子项（flex 子项）的伸缩性。 具体来说，flex: 1是flex-grow、flex-shrink和flex-basis三个属性的简写。其默认值等同于flex: 1 1 0%，分别代表以下含义： flex-g"},{"id":"756","title":"CSS 属性计算函数 Calc 介绍一下【热度: 228】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/756","page":"q/css-756.html","excerpt":"**关键词**：属性计算函数 calc CSS 属性计算函数 calc() 是用来进行动态的尺寸计算以及数值混合运算的一种函数。它增强了纯 CSS 的灵活性，允许你在属性值的设置中直接执行基础的加（+）、减（-）、乘（*）、除（/）运算。 使用方式 calc() 函数用于各种 CSS 属性，如 width、height"},{"id":"755","title":"less 函数如何使用？【热度: 229】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/755","page":"q/css-755.html","excerpt":"**关键词**：less 函数 LESS 是一种基于 JavaScript 的 CSS 预处理器，它扩展了 CSS 的功能，提供了变量、嵌套、混合（Mixins）、函数等功能。LESS 中的函数允许你执行计算、转换和操纵值的操作，使得你的样式表更加灵活和动态。 使用 LESS 函数的基本步骤： **定义函数**：你可以"},{"id":"754","title":"介绍一下 CSS 变量怎么声明和使用？【热度: 688】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/754","page":"q/css-754.html","excerpt":"**关键词**：CSS 变量 CSS 自定义属性，又称 CSS 变量，是一种在 CSS 样式表中声明可以使用任意值的方法，这样的值在同一份 CSS 代码中可以多次引用并调用来替代特定的内容。使用 CSS 变量可以提高样式表的可维护性和灵活性。以下是如何声明和使用 CSS 变量的步骤： 声明 CSS 变量 CSS 变量的"},{"id":"751","title":"CSS 在2023 迎来重大更新， 更新内容是什么【热度: 548】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/751","page":"q/css-751.html","excerpt":"**关键词**：CSS 2023 年重大更新 新特性非常多，总结在下面 详情请看文档：https://juejin.cn/post/7320288231111016498 架构基础 级联层 嵌套 作用域 选择器 :is() 和 :where() 选择器 :has() 复杂的第 n-. 选择 CSS 三角函数 子网格 s"},{"id":"740","title":"vue 中 Scoped Styles 是如何实现样式隔离的， 原理是啥？【热度: 244】","category":"CSS","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/740","page":"q/css-740.html","excerpt":"**关键词**：Scoped Styles 样式隔离 在 Vue 中，.vue 单文件组件的 <style> 标签可以添加一个 scoped 属性来实现样式的隔离。通过这个 scoped 属性，Vue 会确保样式只应用到当前组件的模板中，而不会泄漏到外部的其他组件中。 这个效果是通过 PostCSS 在构建过程中对 C"},{"id":"739","title":"样式隔离方式有哪些【热度: 683】","category":"CSS","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/739","page":"q/css-739.html","excerpt":"**关键词**：样式个例 样式隔离意味着在一个复杂的前端应用中保持组件的样式私有化，使得不同组件之间的样式不会互相影响。以下是一些在前端开发中实现样式隔离的常见方式： 1. CSS 模块（CSS Modules） CSS 模块是一种在构建时将 CSS 类名局部作用域化的技术。每个类名都是独一无二的，通常通过添加哈希值来"},{"id":"713","title":"[css] 如何设置渐变色？【热度: 746】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/713","page":"q/css-713.html","excerpt":"**关键词**：设置渐变色 在 CSS 中，设置渐变色可以使用background属性和相应的渐变函数。CSS 提供两种类型的渐变：线性渐变（linear-gradient）和径向渐变（radial-gradient）。以下是如何分别设置这两种渐变色的示例。 线性渐变（Linear Gradient） 线性渐变是从一个"},{"id":"682","title":"CSS 属性值计算 - calc【热度: 320】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/682","page":"q/css-682.html","excerpt":"是的，CSS 支持计算值，这可以通过 calc() 函数实现。calc() 允许你进行数学运算，计算 CSS 属性值。这个功能非常有力，因为它可以混合使用不同的单位，并且可以用在几乎任何需要数值的地方。 以下是 calc() 函数的一些应用示例： **基本运算**：可以执行加 (+)、减 (-)、乘 (*) 和除 (/"},{"id":"681","title":"CSS 中的 display 属性有哪些值？【热度: 593】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/681","page":"q/css-681.html","excerpt":"CSS 中的display属性是一个非常重要的属性，它用于设置一个元素的显示类型。这个属性决定了元素是如何显示以及与其他元素如何交互。以下是一些常见的display属性值及其含义： none：元素不会被显示。 block：元素显示为块级元素，此类元素会新起一行。 inline：元素不会新起一行，其宽度只占据它的内容宽度"},{"id":"646","title":"css加载会造成阻塞吗【热度: 373】","category":"CSS","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/646","page":"q/css-646.html","excerpt":"**关键词**：css 加载阻塞渲染 css加载会造成阻塞吗？ js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？ 为了完成本次测试，先来科普一下，如何利用chrome来设置下载速度 打开chrome控制台(按下F12),可以看到下图，重点在我画红圈的地方 点击我画红圈的地方(No thr"},{"id":"589","title":"css  module 是什么？【热度: 346】","category":"CSS","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/589","page":"q/css-589.html","excerpt":"**关键词**：css module 概念、css module 作用 CSS Modules 是一种用于组织和管理 CSS 的技术。它通过在编译时为每个 CSS 类名生成唯一的标识符，并将它们作为 JavaScript 对象的属性导出。这样，可以确保每个类名在整个应用程序中的唯一性，避免样式冲突。 使用 CSS Mo"},{"id":"588","title":"全局样式命名冲突和样式覆盖问题怎么解决？【热度: 772】","category":"CSS","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/588","page":"q/css-588.html","excerpt":"**关键词**：全局样式命名冲突 在前端开发过程中，有几种常见的方法可以解决全局样式命名冲突和样式覆盖问题： 使用命名空间（Namespacing）：给样式类名添加前缀或命名空间，以确保每个组件的样式类名不会冲突。例如，在一个项目中，可以为每个组件的样式类名都添加一个唯一的前缀，例如.componentA-button"},{"id":"565","title":"CSS 如何实现文本溢出？【热度: 382】","category":"CSS","labels":["CSS","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/565","page":"q/css-565.html","excerpt":"**关键词**：文本溢出样式 **单行文本溢出** 在CSS中，可以使用text-overflow属性来实现单行文本的溢出省略样式。同时，还需要设置white-space属性为nowrap，使文本不换行，以及overflow属性为hidden，隐藏溢出的文本。 以下是一个示例： 然后，在HTML中，可以将这个类应用到指"},{"id":"483","title":"如何实现页面顶部， 自定义滚动进度条样式【热度: 1,220】","category":"CSS","labels":["CSS","快手"],"url":"https://github.com/pro-collection/interview-question/issues/483","page":"q/css-483.html","excerpt":"**关键词**：自定义滚动条、自定义顶部滚动条 要实现页面顶部的自定义滚动进度条样式，可以按照以下步骤进行： 在HTML中添加滚动进度条的容器元素，通常可以使用一个<div>元素作为容器，放在页面顶部的合适位置。 在CSS中定义滚动进度条的样式。可以使用背景颜色、高度、透明度等属性来自定义样式。 使用JavaScrip"},{"id":"422","title":"如何避免全局样式污染？【热度: 744】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/422","page":"q/css-422.html","excerpt":"**关键词**：避免样式污染、css 模块化 **要避免全局样式污染，可以采取以下几种方式**： 使用命名约定：给不同组件、模块或页面的样式类名添加特定的前缀，以确保它们的作用范围只在对应的组件、模块或页面内生效。例如，使用 BEM（Block Element Modifier）命名约定可以将样式类名划分为块、元素和修"},{"id":"421","title":"html 元素节点上， 有多个 class 名称，这几个class 名称对应的样式渲染优先级是如何的？【热度: 769】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/421","page":"q/css-421.html","excerpt":"**关键词**：class 名称样式优先级 当一个HTML元素节点上有多个class名称，并且这些class名称对应的样式存在冲突时，CSS的渲染优先级遵循以下规则： 内联样式（Inline Styles）具有最高优先级。如果在元素节点的style属性中定义了内联样式，它将覆盖所有其他样式规则。 如果多个class名称"},{"id":"420","title":"详细介绍一下 CSS Grid 布局【热度: 370】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/420","page":"q/css-420.html","excerpt":"**关键词**：栅格布局、grid 布局 CSS Grid 布局是一种强大的二维网格布局系统，它允许开发者以更灵活的方式创建复杂的网页布局。通过将页面划分为行和列，开发者可以精确控制元素的位置和尺寸，并在不同屏幕尺寸下实现响应式布局。 以下是 CSS Grid 布局的一些关键概念和特性： 网格容器（Grid Conta"},{"id":"419","title":"css 栅格布局是什么，如何实现【热度: 368】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/419","page":"q/css-419.html","excerpt":"**关键词**：栅格布局、grid 布局 CSS 栅格布局是一种用于创建响应式网格系统的布局技术。它基于将页面分为等宽的列，并使用行来组织内容。栅格布局提供了一种灵活的方式来创建自适应的网格布局，以便在不同屏幕尺寸和设备上显示良好。 实现 CSS 栅格布局的方法有多种，以下是一种常见的实现方式： HTML 结构：使用 "},{"id":"418","title":"postcss 是什么，作用是啥？【热度: 1,155】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/418","page":"q/css-418.html","excerpt":"**关键词**：postcss 作用、css 预处理、css 模块化 概念与作用 PostCSS 是一个用 JavaScript 编写的工具，用于对 CSS 进行转换和处理。它可以通过插件机制对 CSS 进行各种自定义的转换操作，从而扩展 CSS 的功能和语法。 PostCSS 的作用主要有以下几个方面： CSS 预处"},{"id":"417","title":"CSS3 中有哪些新特性【热度: 1,102】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/417","page":"q/css-417.html","excerpt":"CSS3引入了许多新特性和模块，以下是一些常见的CSS3新特性： 选择器增强： 属性选择器：支持更多的属性选择器，如属性值前缀、后缀、包含等。 伪类选择器：引入了新的伪类选择器，如:nth-child()、:nth-of-type()等。 盒子模型： 边框圆角（border-radius）：可以设置元素的边框圆角。 阴"},{"id":"416","title":"css 中 伪元素和伪类的区别和作用【热度: 429】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/416","page":"q/css-416.html","excerpt":"**关键词**：伪元素和伪类 伪元素和伪类是 CSS 中用于选择和样式化元素的特殊标记，它们有一些区别和不同的作用。 伪元素（Pseudo-Element）： 表示文档中不存在的元素，用于在元素的特定位置插入样式化内容。 通过双冒号 :: 来表示，例如 ::before、::after。 可以使用伪元素为元素添加额外的"},{"id":"415","title":"css 隐藏元素的方法有哪些【热度: 1,076】","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/415","page":"q/css-415.html","excerpt":"**关键词**：隐藏元素 有多种方法可以隐藏元素的CSS。 display: none;：将元素完全隐藏，不占据任何空间。 visibility: hidden;：将元素隐藏，但仍占据空间。 opacity: 0;：将元素透明化，但仍占据空间。 position: absolute; left: -9999px;：将元"},{"id":"356","title":"CSS 绘制三角形【热度: 324】","category":"CSS","labels":["CSS","小米"],"url":"https://github.com/pro-collection/interview-question/issues/356","page":"q/css-356.html","excerpt":"**关键词**：css 绘制、css 三角形 在CSS中，你可以使用多种方法来实现三角形。以下是几种常用的方法和相应的代码示例： 使用边框： 这个方法通过设置元素的边框来创建三角形，其中左右边框设为透明，底边框设置为你想要的颜色。 使用伪元素： 这个方法使用伪元素 ::before 来创建三角形，通过设置其边框的宽度和"},{"id":"355","title":"如何防止 CSS 阻塞渲染【热度: 213】","category":"CSS","labels":["CSS","网易"],"url":"https://github.com/pro-collection/interview-question/issues/355","page":"q/css-355.html","excerpt":"**关键词**：css 阻塞渲染、css 阻塞 当浏览器遇到一个 <link> 标签时，它会停止解析 HTML 并发出一个单独的网络请求去加载外部样式表。 这意味着，如果样式表很大或者网络速度很慢，它将阻止页面的渲染。阻止 CSS 渲染可能会导致页面看起来很糟糕，用户无法立即看到页面内容。 有一些方法可以防止或减轻 C"},{"id":"354","title":"CSS 伪类和伪元素有哪些，它们的区别和实际应用【热度: 317】","category":"CSS","labels":["CSS","京东"],"url":"https://github.com/pro-collection/interview-question/issues/354","page":"q/css-354.html","excerpt":"**关键词**：css 伪类、css 伪元素 CSS 中有伪类和伪元素两种，它们在用法和意义上有一些区别。 伪类是对元素在特定状态下的一种描述。比如 :hover 代表鼠标悬停状态下的样式，:active 代表元素被激活状态下的样式。伪类始终以冒号 : 开头，并放在选择器的最后。常用的 CSS 伪类有： :hover，"},{"id":"353","title":"CSS 选择器有哪些、优先级如何？【热度: 1,183】","category":"CSS","labels":["CSS","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/353","page":"q/css-353.html","excerpt":"**关键词**：css 选择器、css 优先级 CSS 选择器有以下几种： 1.元素选择器：通过标签名选择元素，例如：p {}。 2.类选择器：通过 .+类名的形式选择元素，例如：.my-class {}。 3.ID 选择器：通过 #+ID名的形式选择元素，例如：#my-id {}。 4.通配符选择器：通过 * 选择所"},{"id":"342","title":"Grid 布局了解多少？【热度: 653】","category":"CSS","labels":["CSS","美团"],"url":"https://github.com/pro-collection/interview-question/issues/342","page":"q/css-342.html","excerpt":"**关键词**：Grid 布局、Grid 属性 什么是 grid 布局 CSS Grid 布局是 CSS 中的一种新的布局系统，旨在通过 网格（grid）和 行（row）、列（column）的概念来创建灵活的、高效的、响应式网页布局。CSS Grid 布局可以将一个元素的内容划分为多个网格，根据需要，可以在这些网格中定"},{"id":"260","title":"介绍下 BFC、IFC、GFC 和 FFC？","category":"CSS","labels":["CSS","百度"],"url":"https://github.com/pro-collection/interview-question/issues/260","page":"q/css-260.html","excerpt":"BFC（Block Formatting Contexts）块级格式化上下文 什么是BFC？ BFC 全称：Block Formatting Context， 名为 **块级格式化上下文**。 W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block F"},{"id":"220","title":"`opacity: 0`、`visibility: hidden`、`display: none` 有啥区别， 主要使用场景是啥子？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/220","page":"q/css-220.html","excerpt":"opacity: 0、visibility: hidden、display: none 都可以使元素不可见，但它们之间有一些区别。 opacity: 0：设置元素透明度为0，元素依然占据原来的空间，并且可以接收到鼠标事件。通常用于实现淡出效果。 visibility: hidden：元素不可见，但是仍然占据原来的空间，"},{"id":"158","title":"CSS 中 position 常见属性有哪些，大概讲一下？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/158","page":"q/css-158.html","excerpt":"CSS 中 position 属性用于指定元素的定位方式，它有以下常见的属性值： static：默认值，元素在文档流中正常排列。 relative：元素在文档流中正常排列，但是可以通过设置 top、right、bottom、left 属性相对于其正常位置进行偏移，不会影响其它元素的位置。 absolute：元素脱离文档"},{"id":"157","title":"CSS 文档流 是什么概念？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/157","page":"q/css-157.html","excerpt":"CSS 的文档流（Document Flow）是指文档中元素按照其在 HTML 中出现的顺序自上而下布局的方式，也称为常规流（Normal Flow）或默认流。文档流定义了元素的布局顺序和定位方式，包括元素的位置、大小、间距等属性。 在文档流中，每个元素都会占据一定的空间并尽可能充满其包含块的宽度。每个元素的位置都会受"},{"id":"156","title":"实现 table header 吸顶， 有哪些实现方式？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/156","page":"q/css-156.html","excerpt":"实现 table header 吸顶的方法有多种，以下是一些基于 CSS 的实现方式： 使用 position: sticky 属性：在表格头部的 CSS 中，使用 position: sticky 属性可以使表格头部保持在视窗的顶部或底部，而不会随着滚动而消失。例如： 使用 CSS transform 属性：在表格头"},{"id":"117","title":"css 中 三栏布局的实现方案 的实现方案有哪些？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/117","page":"q/css-117.html","excerpt":"三栏布局指的是在一个页面中，将内容分为左、中、右三栏，并使它们具有相应的宽度和高度。实现三栏布局有多种方案，以下是其中的几种： 使用浮动 在这个方案中，左栏和右栏使用浮动来实现，中间栏使用 margin 来占据剩余的宽度。 使用绝对定位 在这个方案中，左栏和右栏使用绝对定位来实现，中间栏使用左右 padding 来占据"},{"id":"112","title":"CSS 尺寸单位有哪些？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/112","page":"q/css-112.html","excerpt":"CSS尺寸设置的单位包括： 像素（Pixel，缩写为px）：是最常用的单位，表示屏幕上的一个点，可以精确地指定元素的大小。 百分比（Percentage，缩写为%）：相对于父元素的大小，可以根据父元素的大小来设置子元素的大小。 em：相对于当前元素的字体大小，用于设置字体大小时很常用。 rem：相对于根元素（即html"},{"id":"110","title":"样式优先级的规则是什么？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/110","page":"q/css-110.html","excerpt":"在 CSS 中，当多个选择器应用于同一个元素并设置了相同的属性时，就会出现样式冲突的问题。此时，CSS 会根据一定的规则来决定哪个样式具有更高的优先级，从而确定最终的样式效果。CSS 样式优先级的规则如下： !important：具有最高优先级，用于强制覆盖其它样式。 内联样式：直接在 HTML 元素的 style 属"},{"id":"100","title":"flex 布局了解多少？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/100","page":"q/css-100.html","excerpt":"flex 布局的学习 $1 $1 $1 容器属性 以下6个属性设置在容器上。 flex-direction属性 属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-rev"},{"id":"99","title":"了解 BFC 吗？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/99","page":"q/css-99.html","excerpt":"小提示：先聊一聊BFC是什么； 然后再说说触发BFC的条件； 再说一说BFC的一些作用 BFC是块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。(俗称：**脱离文档流**) **触发条件** position: absolute/fixed：绝对定位"},{"id":"59","title":"`display: block;`和`display: inline;`的区别","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/59","page":"q/css-59.html","excerpt":"`block元素特点： 1.处于常规流中时，如果width没有设置，会自动填充满父容器 2.可以应用margin/padding 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略vertical-align inline元素特点 1.水"},{"id":"58","title":"`display: none;`与`visibility: hidden;`的区别是啥","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/58","page":"q/css-58.html","excerpt":"联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间； visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性"},{"id":"55","title":"常见清除浮动的解决方案有哪些","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/55","page":"q/css-55.html","excerpt":"清除浮动的解决方案 （以下提供了八种解决方式） 1、利用div定义height 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 **建议：不推荐使用，只建议高度固定的"},{"id":"43","title":"未知高度和宽度元素的水平垂直居中的方案有哪些， 简单手写一下？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/43","page":"q/css-43.html","excerpt":"未知高度和宽度元素的水平垂直居中 1、当要被居中的元素是inline或者inline-block元素 2、利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。 3、flex"},{"id":"42","title":"水平居中的方案有哪些， 简单手写一下？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/42","page":"q/css-42.html","excerpt":"水平居中的方案 1、要实现行内元素（<span>、<a>等）的水平居中：text-align:center; 2、要实现块状元素（display:block）的水平居中: margin:0 auto; 3、多个水平排列的块状元素的水平居中: 4、flexbox 5、一直宽度水平居中:绝对定位与负边距实现。 6、绝对定位"},{"id":"41","title":"垂直居中的方案有哪些， 简单手写一下？","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/41","page":"q/css-41.html","excerpt":"垂直居中的方案 1、 2、CSS Table 3、Absolute Positioning and Negative Margin 4、Absolute Positioning and Stretching 5、Equal Top and Bottom Padding"},{"id":"36","title":"水平垂直居中定位","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/36","page":"q/css-36.html","excerpt":"水平垂直居中定位 垂直居中的方案 1、 2、CSS Table 3、Absolute Positioning and Negative Margin 4、Absolute Positioning and Stretching 5、Equal Top and Bottom Padding 水平居中的方案 1、要实现行内元"},{"id":"35","title":"解释边距重叠","category":"CSS","labels":["CSS"],"url":"https://github.com/pro-collection/interview-question/issues/35","page":"q/css-35.html","excerpt":"什么是BFC BFC （block formatting context） 及块级格式化上下文，从样式上看，具有 BFC 的元素与普通的容器没有什么区别，从功能上看，BFC相当于构建了一个密闭的盒子模型，在BFC中的元素不受外部元素的影响； **个人理解**：BFC就是将盒子中子元素的属性锁在父元素中，例如margin"},{"id":"1126","title":"JS 里面， 对于对象的读写， 是使用 object 好，还是 Map，性能差异如何？【热度: 610】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1126","page":"q/javascript-1126.html","excerpt":"**关键词**：Object 与 Map 在 JavaScript 中，Object 和 Map 都可以用于存储键值对，但它们的设计目标和性能特性存在差异，选择哪一种取决于具体使用场景。 **核心差异与性能对比** 1. **内存占用** **Object**： 本质是原型链继承的对象，会默认一些额外属性（如 __pr"},{"id":"1066","title":"Object.defineProperty 是否可以监听拦截数组变化【热度: 144】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1066","page":"q/javascript-1066.html","excerpt":"**关键词**：Object.defineProperty 监听数组变化 **基本原理与部分可行性** Object.defineProperty可以用于监听和拦截数组的某些变化，但不是原生地对所有数组操作都能很好地监听。 数组在 JavaScript 中是特殊的对象，其索引可以看作是对象属性。理论上，我们可以使用Ob"},{"id":"1065","title":"proxy 可以拦截数组变化吗【热度: 133】","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1065","page":"q/javascript-1065.html","excerpt":"**关键词**：proxy set 拦截器 **可以拦截数组变化** Proxy可以有效地拦截数组的变化。当对数组进行各种操作，如修改元素、添加或删除元素等，Proxy都能够捕获这些操作并进行拦截。 **拦截数组的读取和设置操作** 对于数组元素的读取和设置操作，可以通过get和set拦截器来实现。 **get拦截器示"},{"id":"1064","title":"proxy set 拦截器，其中参数中第一个参数 target 和 最后一个参数 receiver 有何区别【热度: 132】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1064","page":"q/javascript-1064.html","excerpt":"**关键词**：proxy set 拦截器 **target参数** **本质和用途** target是被代理的原始对象。它代表了代理操作所基于的实际对象。在Proxy的set拦截器中，target的主要作用是提供对原始对象属性和状态的访问，以便在拦截属性设置操作时，可以正确地将新值应用到原始对象的相应属性上。 **示"},{"id":"1063","title":"在 JS 里面， proxy set 拦截器， 有那些参数， 分别表示什么含义【热度: 120】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1063","page":"q/javascript-1063.html","excerpt":"**关键词**：proxy set 拦截器 **target参数** **含义**：它是被代理的目标对象。这个对象是原始的、即将被操作（在set操作的情境下是被设置属性值）的对象。例如，如果你创建了一个代理来拦截对某个对象属性的设置操作，target就是那个实际拥有属性的原始对象。 **示例**： 在这个例子中，tar"},{"id":"1062","title":"如果一行文本展示不下，如何使其通过 popover 来展示全部内容？【热度: 325】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/1062","page":"q/javascript-1062.html","excerpt":"**关键词**：动态计算文本是否溢出 作者备注 主要考核 JS 动态计算文本是否溢出 以下是一种使用 HTML、CSS 和 JavaScript 来实现当文本一行展示不下时通过popover展示全部内容的基本方法。假设你在一个网页环境中操作。 **HTML 结构** 首先，创建一个包含文本的元素，例如一个span标签。"},{"id":"1060","title":"比如我把事件委托注册在 body 上面， 我如何去针对性的出发 不同的子元素【热度: 338】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1060","page":"q/javascript-1060.html","excerpt":"**关键词**：事件委托应用场景 这个问题属于一个典型的「事件委托」的应用场景 如果知识背诵八股文的同学， 可能这个问题就尴尬了 当把事件委托注册在 body 上时，可以通过以下方法针对性地触发不同子元素的特定行为： **一、利用事件对象的属性判断目标元素** event.target 属性： 当事件在 body 上触"},{"id":"1059","title":"绑定事件的元素节点销毁又重新创建， 绑定的事件还会生效吗【热度: 337】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1059","page":"q/javascript-1059.html","excerpt":"**关键词**：事件委托应用场景 比如我将事件绑定在 body 上面， 后来这个 body 人为移除掉了， 然后又重新创建了一个 body 标签， 那么之前绑定在 body 上面的事件还会生效吗？ 如果将事件绑定在 body 上，然后移除了这个 body 标签并重新创建一个 body 标签，之前绑定在旧 body 上的"},{"id":"1058","title":"如果特别多的事件都挂载到一个元素上，会存在什么问题【热度: 336】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1058","page":"q/javascript-1058.html","excerpt":"**关键词**：事件委托应用场景 如果将特别多的事件都挂载到一个元素上，比如在事件委托时将事件都绑定在 body 上，可能会存在以下问题： **一、性能问题** **事件处理开销增加**： 每次触发事件时，浏览器需要遍历所有绑定在该元素上的事件处理程序，确定哪个处理程序应该响应特定的事件。随着事件数量的增加，这个遍历过"},{"id":"1054","title":"解构复制对象， 是深拷贝还是浅拷贝【热度: 411】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1054","page":"q/javascript-1054.html","excerpt":"**关键词**：结构复制对象 **浅拷贝** 举例： 解释如下： 首先定义了一个对象obj，它包含一个基本类型属性prop1和一个嵌套对象属性prop2。 使用扩展运算符{...obj}创建了一个新的对象obj2，这看起来像是对obj进行了复制。 当修改obj2的基本类型属性prop1时，原始对象obj的prop1不受"},{"id":"1049","title":"JS 里面哪些类型是可以互转的【热度: 157】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1049","page":"q/javascript-1049.html","excerpt":"**关键词**：JS 类型转换 在 JavaScript（JS）中，以下类型之间是可以互相转换的： **一、数字（Number）与字符串（String）** 数字转字符串： 使用toString()方法。例如： 使用字符串拼接的方式自动转换。例如：let str = num + ''; 字符串转数字： 使用Number"},{"id":"1044","title":"如何判定一个属性来自于对象本身， 还是来自于原型链【热度: 224】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1044","page":"q/javascript-1044.html","excerpt":"**关键词**：对象与原型链 在 JavaScript 中，可以通过以下几种方式来判断一个属性是来自对象本身还是来自原型链： **一、使用 hasOwnProperty() 方法** 方法介绍： hasOwnProperty()是 JavaScript 对象的一个方法，用于判断一个对象自身是否具有指定的属性。 它不会检"},{"id":"1043","title":"JS 里面是否会存在，对象上有一个 name 属性，但是原型链上还有一个同名的 name 属性【热度: 724】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1043","page":"q/javascript-1043.html","excerpt":"在 JavaScript 中是可能存在对象上有一个name属性，同时原型链上也有一个同名的name属性的情况。 以下是一个示例： 在这个例子中，首先定义了一个构造函数Person，在其原型上设置了一个name属性。然后创建一个Person的实例person，并在实例上也设置了一个同名的name属性。当访问person."},{"id":"1042","title":"Reflect.get() 和直接通过对象 [.] 访问获取属性， 有何区别【热度: 225】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1042","page":"q/javascript-1042.html","excerpt":"**关键词**：Reflect 函数 Reflect.get()和直接通过对象[.]访问获取属性有以下一些区别： **一、返回值** Reflect.get()： 如果属性不存在，返回undefined。 例如： 对象直接访问： 如果属性不存在，在非严格模式下返回undefined；在严格模式下，会抛出一个Refere"},{"id":"1041","title":"详细讲一下 Reflect 内置函数【热度: 224】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1041","page":"q/javascript-1041.html","excerpt":"**关键词**：Reflect 函数 Reflect是 ES6 引入的一个内置对象，它提供了一组与对象操作对应的方法，这些方法与Object上的某些方法类似，但有一些重要的区别。 以下是对Reflect内置函数的详细介绍： **一、获取属性（Reflect.get()）** 作用： 用于获取对象的属性值。 类似于传统的"},{"id":"1039","title":"Object.is 与全等运算符(===)有何区别【热度: 320】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1039","page":"q/javascript-1039.html","excerpt":"**关键词**：等值判断 Object.is()与全等运算符（===）都用于比较两个值是否相等，但它们之间存在一些区别： **一、对特殊值的处理** NaN的比较： ===认为NaN不等于任何值，包括它自身。 Object.is()认为NaN只等于NaN。 例如： -0和+0的比较： ===认为-0和+0是相等的。 O"},{"id":"1036","title":"Object.keys 与 Object.getOwnPropertyNames() 有何区别【热度: 210】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1036","page":"q/javascript-1036.html","excerpt":"Object.keys()和Object.getOwnPropertyNames()都是用于获取对象自身属性名的方法，但它们之间存在一些区别： **一、返回值类型** Object.keys()： 返回一个由对象自身可枚举属性名组成的数组。 可枚举属性是指那些可以通过for...in循环遍历到的属性。 Object.g"},{"id":"1035","title":"事件委托是什么概念， 有何适用场景【热度: 265】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1035","page":"q/javascript-1035.html","excerpt":"**关键词**：事件委托概念 事件委托（Event Delegation）是一种利用事件冒泡机制，将事件处理程序添加到父元素上，通过判断事件的目标元素来处理子元素事件的方法。 **一、事件委托的原理** 当一个事件在 DOM 元素上触发时，它会从最具体的目标元素开始向上冒泡，经过它的祖先元素，直到到达文档的根元素。事件"},{"id":"1023","title":"JS 浏览器事循环有哪些使用案例？【热度: 526】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1023","page":"q/javascript-1023.html","excerpt":"**关键词**：事件循环案例 作者备注 这个是一个很好的问题， 大多数人在面试过程中， 大多数都是问到的 - 什么是事件循环 但是真是事件循环的场景可能大多数人不清楚， 所以也就是为了八股而八股。 这个问题很好的问到哪些场景下会使用到事件循环。 是属于原理考虑， 应用也要知道的场景 JavaScript 的事件循环在实"},{"id":"1022","title":"闭包有哪些使用场景，请举例【热度: 679】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1022","page":"q/javascript-1022.html","excerpt":"**关键词**：闭包使用场景 闭包在 JavaScript 中有很多实用的使用场景，以下是一些主要的场景： **一、数据隐藏和封装** 保护变量： 闭包可以创建一个私有作用域，将变量封装在函数内部，防止外部直接访问和修改。只有通过特定的函数接口才能访问和操作这些变量。 例如： 在这个例子中，count变量被封装在cre"},{"id":"994","title":"实现一个 JS 函数， 功能是从数组中随机取一个元素【热度: 215】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/994","page":"q/javascript-994.html","excerpt":"**关键词**：随机取数函数 以下是使用 JavaScript 实现从数组中随机取一个元素的函数： 你可以这样使用这个函数："},{"id":"987","title":"实现一个 once 函数，记忆返回结果只执行一次【热度: 319】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/987","page":"q/javascript-987.html","excerpt":"**关键词**：once 函数 以下是使用 JavaScript 实现一个once函数的方法： 你可以这样使用这个函数： 在这个实现中，once函数接收一个函数作为参数，并返回一个新的函数。新函数会记住第一次调用时的结果，后续调用直接返回这个结果，而不会再次执行传入的函数。"},{"id":"978","title":"iterator 和 数组 有什么关系【热度: 119】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/978","page":"q/javascript-978.html","excerpt":"**关键词**：iterator 对象、iterator 和 数组关系 在 JavaScript 中，Iterator（迭代器）和数组有着密切的关系： **一、数组作为可迭代对象** **可在迭代场景中使用**： 数组是一种内置的可迭代对象，这意味着它可以在需要可迭代对象的地方使用，比如在for...of循环、扩展运算"},{"id":"977","title":"iterator 对象有哪些特征【热度: 288】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/977","page":"q/javascript-977.html","excerpt":"**关键词**：iterator 对象 在 JavaScript 中，Iterator（迭代器）对象具有以下特征： **一、定义与目的** **实现特定迭代行为**： Iterator 对象是为了实现对可迭代对象（如数组、字符串、集合等）的遍历操作而设计的。它提供了一种标准化的方式来依次访问可迭代对象中的元素。 **二"},{"id":"951","title":"在 forEach 中和 for 循环 中调用异步函数的区别【热度: 371】","category":"JavaScript","labels":["JavaScript","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/951","page":"q/javascript-951.html","excerpt":"**关键词**：循环中的异步 在 JavaScript 中，处理异步函数时，for 循环和 forEach 方法之间的行为有显著差异，尤其是当你试图在循环体中使用 async/await 时。理解这些差异对于编写正确且高效的异步代码是很重要的。 使用 forEach 调用异步函数 Array.prototype.for"},{"id":"943","title":"数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少【热度: 775】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/943","page":"q/javascript-943.html","excerpt":"**关键词**：数组访问 在 JavaScript 中，从数组中获取第一个元素和获取最后一个元素（假设这里你说的第 10 万个元素相当于数组的最后一个元素）的时间差异通常非常小，几乎可以忽略不计。 数组在内存中通常是连续存储的，访问数组中的元素可以通过索引快速定位。无论是访问第一个元素还是最后一个元素，时间复杂度都是 "},{"id":"940","title":"防止对象被篡改有哪些方式【热度: 260】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/940","page":"q/javascript-940.html","excerpt":"**关键词**：防止对象篡改 在 JavaScript 中，可以通过以下几种方式防止对象被篡改： **一、使用Object.freeze()** 功能： 完全冻结一个对象，使其不能添加新属性、删除现有属性或修改现有属性的值。 对嵌套对象也会进行深度冻结。 示例： **二、使用Object.seal()** 功能： 密封"},{"id":"879","title":"JS 如何计算一段文本渲染之后的长度【热度: 648】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/879","page":"q/javascript-879.html","excerpt":"**关键词**：计算文本长度 追加描述 需要根据这个长度来动态计算文本是否折叠， 所以这个文本没有计算出长度是否折叠之前，还不能在用户可视区域渲染出来 要在 JavaScript 中计算一段文本渲染之后的长度，可以通过几种方法来实现。这里的“长度”可以是文本渲染后的像素宽度，它取决于具体的字体、字号、文本内容等因素。以"},{"id":"878","title":"长文本场景，中间显示省略号..., 两端正常展示【热度: 351】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/878","page":"q/javascript-878.html","excerpt":"**关键词**：长文本隐藏 在前端处理长文本且需要在中间显示省略号（...），两端保留完整文本的情况，通常有下面几种方法可以达到效果： 1. 纯 CSS 解决方案（对于单行文本） 对于单行的文本，可以使用 CSS 的text-overflow属性来实现，但这种方法一般只能实现末尾的省略号，无法直接实现中间省略的效果。 "},{"id":"877","title":"[] == ! [] 为什么返回 true【热度: 100】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/877","page":"q/javascript-877.html","excerpt":"**关键词**：js 隐式转换 这个问题涉及到 JavaScript 中的类型转换和比较操作的规则。 在 JavaScript 中，[] == ![]的比较过程如下： **![]的计算** !是逻辑非操作符，它会首先将右侧的操作数转换为布尔值，然后反转该布尔值。对于空数组[]，在 JavaScript 中，所有对象（包"},{"id":"844","title":"JS 数据类型里面， Set 和 数组分别有哪些适用场景，开发中该如何抉择【热度: 333】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/844","page":"q/javascript-844.html","excerpt":"**关键词**：Set 和 数组 适用场景 在 JavaScript 中，Set和数组（Array）都是用来存储一系列数据的集合，但它们具有不同的特性和适用场景。了解这些差异可以帮助你在特定情况下做出更合适的选择。 Set **特性**： Set是一种新的数据结构，被引入在 ES6 中。 它类似于数组，但是成员的值都是"},{"id":"842","title":"在创建对象的时候， new class 和 new function 可有什么区别【热度: 447】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/842","page":"q/javascript-842.html","excerpt":"**关键词**：创建对象实例 在 JavaScript 中，使用new操作符创建对象时，既可以使用类（class）也可以使用构造函数（function）。二者都可以用来实例化新的对象，但它们之间存在一些关键的区别和相似之处： 使用new操作符 当使用new操作符时，JavaScript 会执行以下步骤： 创建一个全新的"},{"id":"836","title":"proxy能够监听到对象中的对象的引用吗？【热度: 112】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/836","page":"q/javascript-836.html","excerpt":"**关键词**：proxy 监听引用 是的，Proxy 能够监听到对象属性的读取和设置操作，包括对象中嵌套的对象的引用操作。但是，要注意的是，如果你想要监听一个嵌套对象内部的变化（例如，对象的属性或者数组的元素），那么你需要单独为这个嵌套对象也创建一个 Proxy 实例。因为 Proxy 只能直接监听它直接代理的对象的"},{"id":"834","title":"实现一个函数，支持深度遍历 JS 对象，且允许再遍历的时候，修改对象的数据，得到新的对象【热度: 441】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/834","page":"q/javascript-834.html","excerpt":"**关键词**：深度遍历对象 实现一个这样的函数，我们需要考虑几个关键点： **深度遍历**：使用递归遍历对象的所有层级。 **修改数据**：在遍历过程中允许修改对象的数据。 **返回新对象**：保持原对象不变，对每个属性或值进行操作，将修改后的结果存储在新的对象中返回。 以下是一个简单示例，展示了如何实现上述功能： "},{"id":"829","title":"JS 脚本延迟加载的方式有哪些？【热度: 156】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/829","page":"q/javascript-829.html","excerpt":"**关键词**：JS 延迟加载、JS 异步加载 JavaScript 脚本的延迟加载是一种优化网页加载时间的技术，可以提高页面的加载速度，提升用户体验。以下是常见的几种 JS 脚本延迟加载的方式： 1. 使用 <script> 标签的 defer 属性 在 <script> 标签中使用 defer 属性可以使得脚本在文"},{"id":"827","title":"对象的遍历方式有哪些【热度: 848】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/827","page":"q/javascript-827.html","excerpt":"**关键词**：对象遍历方式 遍历 JavaScript 对象的属性可以使用几种不同的方法，每种方法都有其适用场景和特点。以下是一些常用的遍历对象属性的方法： 1. **for-in 循环** for-in 循环可以遍历一个对象的所有**可枚举属性**，包括其原型链上的属性。 使用 hasOwnProperty 方法检"},{"id":"826","title":"js 数据类型里面，Map 和 object 分别有哪些适用场景，开发中该如何抉择【热度: 395】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/826","page":"q/javascript-826.html","excerpt":"在 JavaScript 中，Map和普通的对象（Object）都可以用作键值对的集合，但它们各自的特性和使用场景有所不同。根据这些特性和场景，你可以选择最适合你需求的数据结构。 Object **特性**： 键（key）必须是字符串或符号（Symbol）。 适合少量和简单数据结构的场景，以及当你知道键集合不会经常变化"},{"id":"825","title":"promise 的三种状态分别是什么， 是怎么转换的， 转换时机呢?【热度: 323】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/825","page":"q/javascript-825.html","excerpt":"**关键词**：promise 状态 Promise 在 JavaScript 中是一种非常有用的异步编程构造，它代表了一个可能现在、将来或永远都不会完成的操作的结果。每个Promise对象都会经历以下三种状态之一： Promise 的三种状态： **Pending (待定)**: 这是Promise的初始状态，表示异"},{"id":"820","title":"手写瀑布流布局【热度: 551】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/820","page":"q/javascript-820.html","excerpt":"**关键词**：瀑布流布局 作者备注， 此文章属于转载 原文作者：有机后脑 链接：https://juejin.cn/post/7360534173718167579 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 --- 瀑布流布局 当前主流的一些软件当中我们常常可以看见这样的一"},{"id":"815","title":"0.1 + 0.2 不等于 0.3 这是什么原因，要怎么解决【热度: 389】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/815","page":"q/javascript-815.html","excerpt":"**关键词**：精度计算 在 JavaScript 中，0.1 + 0.2 不等于 0.3 的原因是浮点数的精度问题。 在计算机中，浮点数采用二进制存储，而有些十进制小数无法精确地用二进制表示。0.1 和 0.2 在二进制表示中是无限循环的，在进行运算时会产生舍入误差。 要解决这个问题，可以使用以下方法： 使用 Num"},{"id":"791","title":"判断一个对象是否为空，包含了其原型链上是否有自定义数据或者方法。 该如何判定？【热度: 546】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/791","page":"q/javascript-791.html","excerpt":"**关键词**：原型链相关知识 要判断一个对象是否为空，并且考虑到对象自身及其原型链上是否有自定义数据或方法，您可以使用以下的 JavaScript 函数来实现： 可以使用这个函数来判断对象是否为空，例如： Comments / Answers --- **whynyist** at 2024-07-31T09:51:"},{"id":"790","title":"js 如何判空？ 「空」包含了：空数组、空对象、空字符串、0、undefined、null、空 map、空 set , 都属于为空的数据【热度: 640】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/790","page":"q/javascript-790.html","excerpt":"**关键词**：判断 以下是一个 JavaScript 方法，用于校验您提到的各种“为空”的场景： 您可以使用这个方法来检测各种值是否为空，例如："},{"id":"738","title":"jsBridge 是什么？原理是啥？【热度: 220】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/738","page":"q/javascript-738.html","excerpt":"**关键词**：jsBridge 原理 jsBridge是一种在 Web 开发中常用的技术，通常指的是 JavaScript Bridge 的缩写，它是一种在 Web 视图（如 WebView）和原生应用之间进行通信的机制。jsBridge 使得原生代码（如 Android 的 Java/Kotlin 或 iOS 的 "},{"id":"737","title":"在 JS 中， 如何解决递归导致栈溢出问题？【热度: 269】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/737","page":"q/javascript-737.html","excerpt":"**关键词**：栈溢出问题 在 JavaScript 中，递归如果执行过深，确实有可能导致“栈溢出(stack overflow)”错误，因为每次函数调用都会向调用栈中添加一个新的帧，而每个线程的调用栈都有其最大容量限制。当这个容量被超过时，就会发生栈溢出。为了解决这个问题，你可以使用几种不同的方法： 尾调用优化（Ta"},{"id":"730","title":"mouseEnter、mouseLeave、mouseOver、mouseOut 有什么区别？【热度: 266】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/730","page":"q/javascript-730.html","excerpt":"**关键词**：mouseEnter、mouseLeave、mouseOver、mouseOut 区别 这四个事件都与鼠标指针与元素的交互有关，不过它们之间有一些关键的差异： **mouseEnter 和 mouseLeave**： mouseEnter 事件当鼠标指针进入元素时触发，但不冒泡，即只有指定的元素可以触发"},{"id":"716","title":"对象深拷贝的原理和代码实现【热度: 892】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/716","page":"q/javascript-716.html","excerpt":"**关键词**：对象什拷贝原理、避免循环引用和栈溢出 在 JavaScript 中，对象深拷贝指的是创建一个对象的副本，使得这个副本与原始对象不共享任何一个引用。这意味着，如果你修改了副本的属性，原始对象不会受到任何影响，反之亦然。 原理 在实现深拷贝时，有几个关键的概念需要理解： **值类型与引用类型**：值类型（如"},{"id":"715","title":"普通数据类型存储在哪里？堆还是栈","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/715","page":"q/javascript-715.html","excerpt":"作者备注 这个问题没有任何价值， 不做热度评分， 当做科普吧。 在 JavaScript 中，普通数据类型的存储位置通常取决于它们的使用方式和上下文。以下是一些具体情况： **栈（Stack）**：当涉及到基本数据类型时（如数字、字符串、布尔值、null、undefined、和符号(Symbol)），它们通常存储在栈上"},{"id":"695","title":"Proxy 和 Reflect 有什么关系？【热度: 361】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/695","page":"q/javascript-695.html","excerpt":"Proxy 和 Reflect 是 ES6 (ECMAScript 2015) 中引入的两个不同的构造函数，它们密切相关，通常在某些操作中一起使用。 **Proxy**： Proxy 对象用于定义基本操作的自定义行为，例如属性查找、赋值、枚举、函数调用等。当你对一个Proxy对象执行这些操作时，你可以拦截并重新定义这些"},{"id":"690","title":"ES6 中的 Map 对象该如何遍历【热度: 411】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/690","page":"q/javascript-690.html","excerpt":"Map 遍历 在 JavaScript 中，Map对象当然可以被遍历。Map 对象持有键值对，任何值(对象或者原始值) 都可以作为一个键或一个值。你可以使用 Map 对象的几种方法遍历其中的键值对。 以下是几种遍历 Map 对象的方法： **使用 forEach() 方法**： Map 对象有一个 forEach 方法"},{"id":"689","title":"ES6 中的 Set 对象该如何遍历【热度: 410】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/689","page":"q/javascript-689.html","excerpt":"Set 遍历 在 JavaScript 中，Set 对象表示值的集合，在这个集合中每个值只出现一次。Set 对象是可迭代的，因此你可以使用多种方法来遍历它： **for...of 循环**: 可以使用 for...of 循环来遍历 Set。 **forEach 方法**: Set 对象有一个 forEach 方法，就像"},{"id":"688","title":"JS 严格模式为什么会禁用 with 语句？【热度: 210】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/688","page":"q/javascript-688.html","excerpt":"作者备注： 实话实说， 这个问题真的很冷门。 如果有面试官问到这个问题了，感觉就是坏。 但是作为一个知识点儿， 还是有一丢丢意思。 所以顺手就记录下来了。 在 JavaScript 中，严格模式禁用了 with 语句，主要是出于以下三个原因： 性能问题：使用 with 语句会为 JavaScript 解释器带来优化难题"},{"id":"687","title":"JS 严格模式作用是啥？【热度: 530】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/687","page":"q/javascript-687.html","excerpt":"JavaScript的严格模式（\"use strict\"）是一种限制JavaScript语法的方式，目的是为了捕捉一些常见的编码错误，同时阻止或者抛出错误对于一些保险不良行为的使用。它通过在脚本或函数的顶部添加一个特殊的声明来启用，声明如下： 以下是严格模式的一些主要作用： **消除JavaScript语法的一些静默错"},{"id":"664","title":"递归和尾递归是什么概念?【热度: 649】","category":"JavaScript","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/664","page":"q/javascript-664.html","excerpt":"**关键词**：递归和尾递归 递归和尾递归都是指在函数内部调用自身的方式，但它们有一些关键的区别。 **概念** 递归是一种函数调用自身的方式。在递归中，函数会不断地调用自身，直到满足某个终止条件才停止递归。递归通常使用在解决可以通过重复拆分为更小的子问题来解决的问题上。但是，递归可能会导致函数调用的层级过深，消耗大量"},{"id":"615","title":"介绍一下迭代器 Iterator, 以及有哪些用法【热度: 645】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/615","page":"q/javascript-615.html","excerpt":"**关键词**：迭代器 Iterator 1、Iterator 的概念 JavaScript 原有的表示 “ 集合 ” 的数据结构，主要是数组（ Array ）和对象（ Object ）， ES6 又添加了 Map 和 Set 。 这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 M"},{"id":"613","title":"箭头函数的作用以及使用场景【热度: 760】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/613","page":"q/javascript-613.html","excerpt":"**特点** **简洁的语法形式**：箭头函数使用了更简洁的语法形式，省略了传统函数声明中的function关键字和大括号。它通常可以在更少的代码行数中表达相同的逻辑。 **没有自己的this**：箭头函数没有自己的this绑定，它会捕获所在上下文的this值。这意味着箭头函数中的this与其定义时所在的上下文中的th"},{"id":"570","title":"Object 对象有哪些场景 api ？【热度: 509】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/570","page":"q/javascript-570.html","excerpt":"**关键词**：Object对象api | 方法/属性 | 描述 | | ------------------------------ | ------------------------------------------------------------ | | Object.keys(obj) | 返回一个由给"},{"id":"564","title":"JavaScript 中， 隐藏类是什么概念？【热度: 146】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/564","page":"q/javascript-564.html","excerpt":"**关键词**：JavaScript隐藏类 隐藏类是JavaScript引擎中的一种优化技术，用于提高对象访问的性能。隐藏类是一种数据结构，用于跟踪对象的属性和方法的布局和类型，以便在代码运行时能够快速访问它们。 当JavaScript引擎在执行代码时，会动态地创建对象的隐藏类。隐藏类会跟踪对象的属性和方法，并为它们分"},{"id":"563","title":"JavaScript 如何做内存管理？【热度: 603】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/563","page":"q/javascript-563.html","excerpt":"**关键词**：JavaScript内存管理 JavaScript中的内存管理是由垃圾收集器负责的。垃圾收集器会自动追踪不再使用的对象，并在适当的时候释放它们占用的内存。 JavaScript的垃圾收集器使用了一种称为\"**标记-清除**\"（mark and sweep）的算法来确定哪些对象是不再需要的。该算法通过标记"},{"id":"562","title":"JavaScript 和 BOM、DOM 、ECMAScript、Nodejs 之间是什么关系","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/562","page":"q/javascript-562.html","excerpt":"**ECMAScript** ECMAScript是JavaScript的标准化规范，它定义了JavaScript的语法、数据类型、函数、控制流等。ECMAScript最早在1997年发布，由欧洲计算机制造商协会（ECMA）负责制定和维护。 ECMAScript的目的是为了确保不同厂商的JavaScript实现在语法和"},{"id":"561","title":"weakSet 是什么数据结构， 有什么应用场景【热度: 161】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/561","page":"q/javascript-561.html","excerpt":"**关键词**：weakSet 数据、weakSet 结构、weakSet 作用 WeakSet 是一种特殊的集合数据结构，它只能存储对象引用，并且这些对象是弱引用。WeakSet 中的对象是被弱引用的，意味着如果没有其他引用指向这个对象，垃圾回收机制就会自动将其回收，即使该对象存在于 WeakSet 中。与 Set "},{"id":"560","title":"splice 和 slice 有什么区别？【热度: 282】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/560","page":"q/javascript-560.html","excerpt":"**关键词**：Array 方法 splice、Array 方法 slice、splice 和 slice 区别 splice() 和 slice() 是 JavaScript 中用于操作数组的两个方法，它们的功能和用法有一些区别。 splice() 方法： 功能：从数组中添加、删除或替换元素。 用法：array.sp"},{"id":"559","title":"什么是匿名函数？【热度: 275】","category":"JavaScript","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/559","page":"q/javascript-559.html","excerpt":"**关键词**：匿名函数 在JavaScript中，匿名函数是一种没有名称的函数。它是一种可以直接被定义和使用的函数，而不需要通过函数名进行引用。匿名函数通常用于需要临时定义一个函数并在某个地方立即调用它的情况下使用。 匿名函数可以使用两种方式进行定义：函数表达式和箭头函数。 函数表达式： 在上述代码中，我们定义了一个"},{"id":"553","title":"WeakMap 是什么样的数据结构【热度: 431】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/553","page":"q/javascript-553.html","excerpt":"**关键词**：WeakMap应用、WeakMap数据、WeakMap api **基本概念** WeakMap 是一种键值对存储的数据结构，类似于 Map。它的特点是键必须是对象，值可以是任意类型的数据。 WeakMap 内部使用了引用计数的方式来判断键是否存活，当键不再被引用时，垃圾回收机制会自动清除对应的键值对。"},{"id":"541","title":"副作用是什么概念【热度: 230】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/541","page":"q/javascript-541.html","excerpt":"**关键词**：js副作用 在 JavaScript 中，副作用（side effect）是指函数或表达式在执行过程中对外部环境产生的影响，而不仅仅是返回一个值。副作用可能包括但不限于对全局变量、参数、数据结构、文件系统、网络请求等进行修改。 副作用可以是有意为之，也可以是无意之间发生的。在函数式编程中，减少副作用是一"},{"id":"540","title":"类型的转换有哪些【热度: 631】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/540","page":"q/javascript-540.html","excerpt":"**关键词**：js类型转换 可以将上述类型转换分为以下几类： 显式转换：显式转换是通过特定的函数或操作符来实现的，开发者明确地指定了类型转换的规则和目标类型。例如使用String()、Number()、Boolean()等函数进行类型转。 隐式转换：隐式转换是在特定的运算或操作中自动发生的，不需要开发者明确指定类型转"},{"id":"539","title":"箭头函数解决了什么问题【热度: 568】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/539","page":"q/javascript-539.html","excerpt":"**关键词**：箭头函数、箭头函数特点 箭头函数是ES6中引入的一种新的函数语法，它主要解决了以下几个问题： **简化函数表达式**：箭头函数提供了一种更简洁的函数定义方式，可以用更短的语法来定义函数，减少了冗余的代码。例如，使用箭头函数可以将一个函数表达式 function(x) { return x * x; } "},{"id":"538","title":"引用类型有哪些，有什么特点【热度: 902】","category":"JavaScript","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/538","page":"q/javascript-538.html","excerpt":"**关键词**：js引用类型 在JavaScript中，引用类型是指非基本数据类型，它们是由对象、数组、函数等复杂数据结构组成的。 常见的引用类型包括： 对象（Object）：对象是JavaScript中最基本的引用类型，它可以用来存储键值对，也可以通过原型链实现继承。 数组（Array）：数组是一种有序的集合，可以存"},{"id":"537","title":"typeof 与 instanceof 的区别【热度: 906】","category":"JavaScript","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/537","page":"q/javascript-537.html","excerpt":"**关键词**：typeof 与 instanceof、typeof 作用、instanceof 作用 在JavaScript中，typeof和instanceof是两个用于检查变量类型的操作符，但它们具有不同的用途和区别。 typeof是一个一元操作符，用于确定给定变量的数据类型。它返回一个字符串，表示变量的数据类型"},{"id":"520","title":"for...of、for...in、for 循环， 三者有什么区别【热度: 1,652】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/520","page":"q/javascript-520.html","excerpt":"**关键词**：for...in遍历、for...of遍历 以下是 for...of、for...in 和 for 循环的区别对比表格： | 特性 | for...of 循环 | for...in 循环 | for 循环 | |------------------|---------------------------"},{"id":"519","title":"[代码执行] 关于 this 的指向问题：下面代码执行结果是什么, 原因？","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/519","page":"q/javascript-519.html","excerpt":"代码如下，请问执行结果是多少？ **执行结果** 解释如下： obj.getName()：在箭头函数getName中，this指向的是全局对象（在浏览器中是window对象，Node.js 中是Global对象）。因此this.getName输出undefined。 obj.getAge()：在普通函数getAge中，"},{"id":"503","title":"如何判断一个单向链表是否是循环链表?【热度: 975】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/503","page":"q/javascript-503.html","excerpt":"**关键词**：循环链表 要判断一个单向链表是否成循环链表，可以使用快慢指针的方法。 快慢指针是两个指针，一个指针每次移动两个节点，另一个指针每次移动一个节点。如果链表中存在循环，那么快指针最终会追上慢指针，两个指针会相遇。 具体的判断过程如下： 初始化快指针和慢指针，都指向链表的头节点。 进入一个循环，每次迭代中，慢"},{"id":"487","title":"typeof null 的输出结果是什么，为什么？【热度: 93】","category":"JavaScript","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/487","page":"q/javascript-487.html","excerpt":"**关键词**：typeof null 输出结果 在 JavaScript 中，typeof null 的输出结果是 \"object\"。 这是因为在 JavaScript 中，null 被视为一个特殊的空值对象。尽管 null 实际上不是一个对象，它是一个原始类型的值，但 typeof null 返回 \"object\""},{"id":"486","title":"如何冻结一个 JS 对象【热度: 949】","category":"JavaScript","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/486","page":"q/javascript-486.html","excerpt":"**关键词**：Object.freeze、Object.freeze作用、深度冻结对象 **冻结对象** 要冻结一个 JavaScript 对象，以防止别人更改它，可以使用Object.freeze()方法。Object.freeze()方法会递归地冻结一个对象的所有属性，使其变为只读的，并防止更改、删除或添加新属性"},{"id":"484","title":"proxy 有那些实际使用场景【热度: 849】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/484","page":"q/javascript-484.html","excerpt":"**关键词**：proxy 应用场景、proxy 作用是什么 JavaScript的Proxy对象提供了一种拦截并定制JavaScript对象底层操作的机制。它允许你在对象上定义自定义行为，例如访问、赋值、函数调用等操作。Proxy对象包裹着目标对象，并拦截对目标对象的访问，使你能够自定义处理这些操作。 Proxy可以"},{"id":"481","title":"async/await 函数到底要不要加 try catch ?【热度: 645】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/481","page":"q/javascript-481.html","excerpt":"**关键词**：async/await函数、async/await函数 是否需要 try/catch、async/await函数 与 try/catch 关系、try/catch 使用场景 当使用 async 函数的时候，很多文章都说建议用 try catch 来捕获异常, 可是实际上很多项目的代码，遵循的并不是严谨，"},{"id":"479","title":"模拟new操作【热度: 1,186】","category":"JavaScript","labels":["JavaScript","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/479","page":"q/javascript-479.html","excerpt":"**关键词**：模拟 new 可以使用以下代码来模拟new操作： 使用示例： 在上述代码中，myNew函数模拟了new操作的过程： 首先，通过Object.create创建了一个新对象obj，并将构造函数的原型对象赋值给该新对象的原型。 然后，使用apply方法调用构造函数，并传入新对象obj作为this值，以及其他参"},{"id":"478","title":"下面代码的执行结果是多少（意义不大）","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/478","page":"q/javascript-478.html","excerpt":"**执行结果是多少， 为什么？** **执行结果是：** **原因:** 首先，变量foo被赋值为一个函数表达式function () { console.log(\"foo1\") }，然后立即调用foo()，输出结果为foo1。 接下来，变量foo再次被赋值为另一个函数表达式function () { console."},{"id":"462","title":"斐波拉契数列是什么，用 JS 实现，用尾调优化斐波拉契数列【热度: 923】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/462","page":"q/javascript-462.html","excerpt":"**关键词**：斐波拉契数列、尾调优化 斐波那契数列是指：0、1、1、2、3、5、8、13、21、34、……，在数学上，斐波那契数列以如下被以递归的方法定义： F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) (n > 1) 用 JS 实现斐波那契数列可以如下： 这个函数用递归的方式实"},{"id":"457","title":"JS里的类就是构造函数的语法糖，这个说法是否正确【热度: 541】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/457","page":"q/javascript-457.html","excerpt":"**关键词**：JS构造函数、JS类的语法糖 这个说法是正确的。 在 JavaScript 中，类实际上是构造函数的语法糖，也就是说，通过类的语法创建的对象和通过构造函数创建的对象是一样的。 例如，下面是一个通过构造函数创建对象的示例： 而使用类的语法创建对象的示例代码如下： 可以看到，使用类的语法创建对象时，实际上是"},{"id":"456","title":"requestAnimationFrame 了解多少","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/456","page":"q/javascript-456.html","excerpt":"requestAnimationFrame 是一种优化动画性能的方法，它会在浏览器重绘之前执行指定的回调函数。相比于传统的 setInterval 或 setTimeout 方法，requestAnimationFrame 会在浏览器的下一次重绘之前执行回调函数，能够更好地与浏览器的渲染机制结合，减少页面的卡顿和闪烁。"},{"id":"455","title":"异步编程的实现方式?【热度: 809】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/455","page":"q/javascript-455.html","excerpt":"**关键词**：JS异步编程、JS异步编程实现方式 异步编程的实现方式有以下几种： 回调函数 回调函数是最基本的异步编程方式。在执行异步操作时，将回调函数作为参数传递给异步函数，异步函数在操作完成后将结果传递给回调函数，回调函数再进行下一步操作。例如： Promise Promise 是一种更高级的异步编程方式。通过 "},{"id":"454","title":"原型链的终点是什么？【热度: 1,325】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/454","page":"q/javascript-454.html","excerpt":"**关键词**：原型链的终点 在JavaScript中，原型链的终点是 null。当访问一个对象的属性或方法时，如果当前对象没有该属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法或者到达原型链的终点 null。 每个对象都有一个原型（prototype）属性，指向它的原型对象。原型对象也是"},{"id":"453","title":"hasOwnProperty 与 instanceof 区别【热度: 490】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/453","page":"q/javascript-453.html","excerpt":"**关键词**：hasOwnProperty、instanceof、hasOwnProperty作用、instanceof作用 hasOwnProperty 和 instanceof 是两个不同的操作符，用于不同的目的。 hasOwnProperty hasOwnProperty 是一个对象的原型方法，用来检测一个对象"},{"id":"452","title":"JS 创建对象的方式有哪些？【热度: 894】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/452","page":"q/javascript-452.html","excerpt":"**关键词**：JS 创建对象 使用对象字面量创建对象。 使用 Object 构造函数创建对象。 使用构造函数创建对象。 使用 Object.create() 方法创建对象。 使用类和继承创建对象。 Comments / Answers --- **yanlele** at 2023-07-26T14:30:19Z 补"},{"id":"451","title":"函数声明与函数表达式的区别【热度: 551】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/451","page":"q/javascript-451.html","excerpt":"**关键词**：函数声明、函数表达式 JavaScript中有两种主要的方式来定义函数：函数声明（Function Declaration）和函数表达式（Function Expression）。 函数声明（Function Declaration）： 函数声明是通过使用 function 关键字后面跟着函数名称来创建"},{"id":"450","title":"普通函数动态参数 和 箭头函数的动态参数有什么区别？【热度: 927】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/450","page":"q/javascript-450.html","excerpt":"**关键词**：JS函数动态参数 普通函数和箭头函数在处理动态参数方面有以下区别： 普通函数的动态参数： 在普通函数中，可以使用 arguments 对象来访问传递给函数的所有参数，无论是否定义了具名参数。arguments 是一个类数组对象，可以通过索引访问每个参数的值。 普通函数可以使用剩余参数语法（Rest pa"},{"id":"449","title":"JS 执行上下文的生命周期阶段有哪些【热度: 713】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/449","page":"q/javascript-449.html","excerpt":"**关键词**：JS 执行阶段、JS执行上下文生命周期 在JavaScript中，执行上下文的生命周期可以分为三个阶段：创建阶段（Creation phase）、执行阶段（Execution phase）和回收阶段（Cleanup phase）。 创建阶段（Creation phase）： 在创建阶段，JavaScri"},{"id":"447","title":"JS 中的数组和函数在内存中是如何存储的？【热度: 815】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/447","page":"q/javascript-447.html","excerpt":"**关键词**：数组和函数在内存中存储方式 在JavaScript中，数组和函数在内存中的存储方式有一些不同。 数组（Array）的存储： 数组是一种线性数据结构，它可以存储多个值，并且这些值可以是不同类型的。在内存中，数组的存储通常是连续的。当创建一个数组时，JavaScript引擎会为其分配一段连续的内存空间来存储"},{"id":"445","title":"执行上下文栈是什么【热度: 632】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/445","page":"q/javascript-445.html","excerpt":"**关键词**：执行上下文栈 在JavaScript中，执行上下文栈（Execution Context Stack）是用于跟踪和管理函数执行的机制。每当JavaScript代码执行到一个函数时，就会创建一个执行上下文（Execution Context）并被推入执行上下文栈的顶部。当函数执行完毕后，执行上下文将从栈中"},{"id":"443","title":"深度遍历广度遍历的区别？【热度: 867】","category":"JavaScript","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/443","page":"q/javascript-443.html","excerpt":"**关键词**：深度遍历广度遍历 深度遍历（Depth-First Search，DFS）和广度遍历（Breadth-First Search，BFS）是两种常用的图遍历算法，用于访问和搜索图或树中的节点。它们在遍历顺序和搜索策略上有所不同。 深度遍历（DFS）： 深度遍历从一个节点开始，递归地访问该节点的子节点，直到"},{"id":"441","title":"解释性语言和编译型语言的区别【热度: 858】","category":"JavaScript","labels":["JavaScript","快手"],"url":"https://github.com/pro-collection/interview-question/issues/441","page":"q/javascript-441.html","excerpt":"**关键词**：解释性语言和编译型语言 解释性语言和编译型语言是两种不同的编程语言类型，它们在代码的执行方式和运行过程中的一些特点上存在区别。 编译型语言： 编译型语言的代码在运行之前需要经过编译器的处理，将源代码一次性地转换成机器语言的可执行文件（通常是二进制文件）。 编译器将源代码转换为目标代码的过程包括词法分析、"},{"id":"440","title":"use strict是什么? 它有什么用？【热度: 758】","category":"JavaScript","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/440","page":"q/javascript-440.html","excerpt":"**关键词**：JS 编译指示、JS 严格模式 \"use strict\" 是 JavaScript 中的一个编译指示（directive），用于启用严格模式（strict mode）。 严格模式是 JavaScript 的一种执行模式，它增强了代码的健壮性、可维护性和安全性，并减少了一些常见的错误。启用严格模式后，Ja"},{"id":"439","title":"escape、encodeURI、encodeURIComponent 区别【热度: 367】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/439","page":"q/javascript-439.html","excerpt":"**关键词**：js URL 编码解码 在 JavaScript 中，escape()、encodeURI() 和 encodeURIComponent() 都是用于编码 URL 或字符串的函数，但它们有一些区别： escape() 函数用于编码字符串中的特殊字符，使其能够安全地传输。它对字符进行编码，包括非 ASCI"},{"id":"438","title":"为什么函数的 arguments 参数是类数组而不是数组？【热度: 669】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/438","page":"q/javascript-438.html","excerpt":"**关键词**：arguments 参数、arguments 参数遍历 在 JavaScript 中，函数的 arguments 参数被设计为类数组对象，而不是真正的数组。这是因为 arguments 对象包含了函数调用时传入的所有参数，包括未命名的参数。它提供了一种方便的方式来访问和操作这些参数。 要遍历类数组对象，"},{"id":"437","title":"类数组转换成数组的方法有哪些【热度: 1,094】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/437","page":"q/javascript-437.html","excerpt":"**关键词**：类数组对象转换为真正的数组 有几种常见的方法可以将类数组对象转换为真正的数组： Array.from()：使用 Array.from() 方法可以将可迭代对象或类数组对象转换为数组。 Array.prototype.slice.call()：通过调用 Array.prototype.slice() 方法"},{"id":"435","title":"什么是伪数组、什么是类数组【热度: 1,510】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/435","page":"q/javascript-435.html","excerpt":"**关键词**：伪数组、类数组 伪数组（Array-like）和类数组（Array-like Object）都是描述一种类似数组的对象结构，它们在外观和行为上类似于数组，但实际上不是真正的数组。 伪数组（Array-like）： 伪数组是指具有类似数组的结构，但不具备数组的方法和属性的对象。 伪数组对象通常拥有一个 l"},{"id":"434","title":"Object.is() 与比较操作符 “===”、“==” 有什么区别【热度: 1,425】","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/434","page":"q/javascript-434.html","excerpt":"**关键词**：Object.is()、js 相等比较 Object.is() 方法和比较操作符 \"===\"、\"==\" 用于比较两个值的相等性，但它们在比较方式和行为上有一些区别。 Object.is() 方法是严格相等比较，而 \"===\" 操作符也是严格相等比较，但 \"==\" 操作符是相等比较。 严格相等比较（==="},{"id":"433","title":"js 函数有默认值的时候， 如果传递的参数是 undefined 那么会被默认值赋值吗？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/433","page":"q/javascript-433.html","excerpt":"是的，如果函数在调用时某个参数被传递为 undefined，那么它会被默认值赋值。 当为函数的参数设置默认值时，只有当参数的值为 undefined 时才会生效。如果传递的参数为 null、空字符串 '' 或者未提供参数，则默认值不会被应用。 以下是一个示例： 在上面的例子中，当参数 name 被传递为 undefin"},{"id":"432","title":"typeof null 的结果是什么，为什么？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/432","page":"q/javascript-432.html","excerpt":"typeof null 的结果是 \"object\"。 这是 JavaScript 中的一个历史遗留问题。在 JavaScript 最初的实现中，将 JavaScript 的值分为了几种类型，其中 null 被当作一个空对象指针。为了与其他对象类型区分开，typeof null 返回了 \"object\"。 实际上，nul"},{"id":"431","title":"判断数组的方式有哪些【热度: 509】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/431","page":"q/javascript-431.html","excerpt":"**关键词**：js判断数组方法 在 JavaScript 中，判断一个值是否为数组有多种方式，以下是几种常见的方法： Array.isArray(): 使用 Array.isArray() 方法可以判断一个值是否为数组。它是 ES5 中新增的方法，返回一个布尔值。 instanceof 操作符：可以使用 instan"},{"id":"397","title":"了解哪些基础算法","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/397","page":"q/javascript-397.html","excerpt":"6 种基础算法思想 递归算法 分治算法 贪心算法 回溯算法 动态规划 枚举算法 **参考文档**: https://www.toutiao.com/article/7199435823970828857"},{"id":"389","title":"JS 作用域链链接多少?【热度: 882】","category":"JavaScript","labels":["JavaScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/389","page":"q/javascript-389.html","excerpt":"**关键词**：JS 作用域链链、JS 作用域链链应用 概念 JavaScript 作用域链（Scope Chain）是指变量和函数的可访问性和查找规则。它是由多个执行上下文（Execution Context）的变量对象（Variable Object）按照它们被创建的顺序组成的链式结构。 在 JavaScript "},{"id":"388","title":"哪些原因会导致js里this指向混乱?【热度: 1,282】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/388","page":"q/javascript-388.html","excerpt":"**关键词**：js 指向 JavaScript 中 this 指向混乱的原因主要有以下几个： 函数调用方式不同：JavaScript 中函数的调用方式决定了 this 的指向。常见的函数调用方式有函数调用、方法调用、构造函数调用和箭头函数调用。不同的调用方式会导致 this 指向不同的对象，容易引发混乱。 丢失绑定："},{"id":"387","title":"Generator 是如何做到中断和恢复的【热度: 1,558】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/387","page":"q/javascript-387.html","excerpt":"**关键词**：Generator 中断、Generator 回复 Generator 是 JavaScript 中一种特殊的函数，它能够通过迭代器协议（Iterator Protocol）实现中断和恢复的功能。 Generator 函数使用 function* 声明，内部可以使用 yield 关键字来定义中断点。当调"},{"id":"385","title":"使用 Promise 实现一个异步流量控制的函数(限制并发数)【热度: 517】","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/385","page":"q/javascript-385.html","excerpt":"**关键词**：异步流量控制的函数 下面是使用 Promise 实现异步流量控制的函数的示例： 以上示例中的 asyncFlowControl 函数接受一个任务数组 tasks 和一个并发限制 limit，它会按照并发限制逐个执行任务，并返回一个 Promise 对象。在示例中，任务数组中的每个任务都是一个返回 Pro"},{"id":"371","title":"Object.prototype.hasOwnProperty() 作用是啥【热度: 1,176】","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/371","page":"q/javascript-371.html","excerpt":"**关键词**：Object.prototype.hasOwnProperty Object.prototype.hasOwnProperty() Object.prototype.hasOwnProperty()是JavaScript中Object原型对象上的方法。它用于检查一个对象是否具有指定的属性（即对象自身拥有"},{"id":"363","title":"模版引擎实现原理【热度: 1,241】","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/363","page":"q/javascript-363.html","excerpt":"**关键词**：模版引擎 前端模板引擎实现原理 前端模板引擎是一种用于处理 HTML 字符串的工具，它允许开发人员在 HTML 中嵌入特殊语法，然后使用模板引擎把数据与这些语法结合，生成最终的 HTML 字符串。这种方式有助于实现数据与表示的分离，使得代码更易于维护。 前端模板引擎的实现原理通常包括以下几个步骤： **"},{"id":"362","title":"手写 JSON.stringify 和 手写 JSON.parse 实现【热度: 134】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/362","page":"q/javascript-362.html","excerpt":"**关键词**：手写 JSON.stringify、手写 JSON.parse 手写JSON.stringify JSON.stringify 是一个将 JavaScript 对象或值转换为 JSON 字符串的函数。下面是一个简化的实现，主要考虑以下几种类型：字符串、数字、布尔值、对象和数组。 请注意，这个实现有很多限"},{"id":"361","title":"函数柯里化了解多少【热度: 529】","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/361","page":"q/javascript-361.html","excerpt":"**关键词**：函数柯里化、柯里化应用场景、柯里化优势 函数柯里化是什么？ 函数柯里化（Currying）是一种在函数式编程中使用的技术，其主要目的是将一个接受多个参数的函数转换成一系列使用一个参数的函数。 这样做的好处是允许你创建一些部分应用的函数，预先固定一些参数，使得代码更简洁，便于复用和组合。 以下是一个简单的"},{"id":"350","title":"如何做 promise 缓存？上一次调用函数的 promise 没有返回， 那么下一次调用函数依然返回上一个 promise","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/350","page":"q/javascript-350.html","excerpt":"基础实现 可以使用闭包实现 promise 缓存的功能。下面是一个示例代码： 在上面的代码中，我们先定义了一个 cachedPromise 函数，它接收一个返回 Promise 的异步函数 promiseFunction，并返回一个新的函数。这个新函数会维护一个 lastPromise 变量，用来记录上一次调用 pro"},{"id":"347","title":"Javascript 数组中有那些方法可以改变自身，那些不可以","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/347","page":"q/javascript-347.html","excerpt":"可以改变自身的数组方法： pop(): 删除数组最后一项，并返回删除项的值。 push(): 向数组末尾添加一个或多个元素，并返回新数组的长度。 reverse(): 反转数组的顺序，返回逆序后的原数组。 shift(): 删除数组第一项，并返回删除项的值。 unshift(): 方法将指定元素添加到数组的开头，并返回"},{"id":"346","title":"new Function 了解多少？【热度: 1,042】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/346","page":"q/javascript-346.html","excerpt":"**关键词**：new Function 概念、js new Function 执行性能、js new Function 使用场景 基本概念 new Function() 是 JavaScript 中的一个构造函数，它可以实例化一个新的函数对象并返回。该函数对象可以使用传递给 new Function() 的字符串参数"},{"id":"345","title":"eval 了解多少？【热度: 538】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/345","page":"q/javascript-345.html","excerpt":"**关键词**：eval 使用场景、eval 性能、eval 优点、eval 缺点 什么是 eval eval() 是 JavaScript 的一个全局函数，用于解析并执行字符串代码。 它接受一个字符串参数，该字符串包含 JavaScript 表达式或语句。在 eval 函数执行期间，该字符串的内容将被视为有效 Jav"},{"id":"340","title":"值类型和引用类型 的区别?【热度: 1,625】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/340","page":"q/javascript-340.html","excerpt":"**关键词**：值类型和引用类型区别 在JavaScript中，值类型和引用类型是两种不同的数据类型，它们之间的区别在于数据存储和传递的方式不同。 值类型（也称为“原始类型”）包括 undefined、null、boolean、number和string。这些数据类型的值是可以直接存储在变量中的，这意味着如果我们将一个"},{"id":"339","title":"JavaScript 中的变量在内存中的具体存储形式是什么【热度: 183】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/339","page":"q/javascript-339.html","excerpt":"**关键词**：JavaScript 变量存储形式 在JavaScript中，变量的存储方式是基于所存储值的数据类型。JavaScript有7种内置数据类型：undefined、null、boolean、number、string、symbol和object。 对于基础数据类型（除了object），变量值会直接存储在内"},{"id":"338","title":"JavaScript 对象的底层数据结构是什么【热度: 517】","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/338","page":"q/javascript-338.html","excerpt":"**关键词**：JavaScript 对象数据结构 在JavaScript中，对象是一种无序的键值对集合，可以保存和传递信息。对象是一种非常重要的数据类型，在JavaScript中，几乎所有东西都是对象。 在底层，JavaScript对象的数据结构是哈希表（Hash Table），也可以称为散列表。哈希表是一种使用哈希"},{"id":"303","title":"dom 渲染能使用 GPU 加速吗？【热度: 494】","category":"JavaScript","labels":["JavaScript","网易"],"url":"https://github.com/pro-collection/interview-question/issues/303","page":"q/javascript-303.html","excerpt":"只有部分情况可以使用 GPU 加速渲染。浏览器将 DOM 元素转换为图层（Layer），然后将图层绘制到屏幕上。在某些情况下，这些图层可以使用 GPU 加速，从而提高渲染性能。 浏览器将具有以下属性之一的元素视为单独的图层： 使用 CSS 3D 变换或透视属性的元素 使用 CSS 滤镜的元素 使用 will-chang"},{"id":"300","title":"canvas 性能为何会比 html/css 好？【热度: 242】","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/300","page":"q/javascript-300.html","excerpt":"Canvas 和 HTML/CSS 是两种不同的技术，各自有着自己的优势和适用场景。 Canvas 是一种基于 JavaScript 的 2D/3D 绘图技术，它允许开发者直接操作像素，可以实现复杂的图形、动画和游戏等效果，其性能比 HTML/CSS 要好的原因主要有以下几点： 直接操作像素：Canvas 允许开发者直"},{"id":"291","title":"promise 是否可以取消？","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/291","page":"q/javascript-291.html","excerpt":"在原生的 JavaScript Promise 中，它没有内建的取消机制。一旦一个 Promise 被创建并开始执行，就无法直接取消它。 通常情况下，Promise 一旦被创建，就会一直执行直到成功(resolve)或失败(reject)。但是，你可以通过一些手动的方式来模拟取消 Promise 的效果。下面是几种常见"},{"id":"274","title":"实现一个类似关键字new功能的函数","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/274","page":"q/javascript-274.html","excerpt":"在js中new关键字主要做了：首先创建一个空对象，这个对象会作为执行new构造函数之后返回的对象实例，将创建的空对象原型（__proto__）指向构造函数的prototype属性，同时将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显式返回值。"},{"id":"266","title":"实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/266","page":"q/javascript-266.html","excerpt":"题目如下 以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下： 解法 解法1： 大型找爹现场 时间复"},{"id":"265","title":"react-router 里的 `<Link>` 标签和 `<a>` 标签有什么区别","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/265","page":"q/javascript-265.html","excerpt":"从最终渲染的 DOM 来看，这两者都是链接，都是 <a> 标签，区别是： <Link> 是 react-router 里实现路由跳转的链接，一般配合 <Route> 使用，react-router 接管了其默认的链接跳转行为，区别于传统的页面跳转，<Link> 的“跳转”行为只会触发相匹配的 <Route> 对应的页面"},{"id":"264","title":"请实现一个 add 函数，满足以下功能","category":"JavaScript","labels":["JavaScript","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/264","page":"q/javascript-264.html","excerpt":"题目如下 解法 Comments / Answers --- **wuhuaizai** at 2023-09-14T06:59:56Z 解法1，2只是柯里化的话，不能实现add(1) // 1这种操作吧，只是柯里化的话add(1)得到的应该还是函数，是不是漏了些代码了？ --- **wuhuaizai** at 20"},{"id":"263","title":"算法题之「移动零」","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/263","page":"q/javascript-263.html","excerpt":"题目如下 解法 解法1： 解法2：算法思路"},{"id":"262","title":"数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/262","page":"q/javascript-262.html","excerpt":"数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1) **得出结论：消耗时间几乎一致，差异可以忽略不计** **原因**: JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第"},{"id":"259","title":"为什么普通 for 循环的性能远远高于 forEach 的性能？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/259","page":"q/javascript-259.html","excerpt":"首先问题说\"for循环优于forEach\"并不完全正确 循环次数不够多的时候， forEach 性能优于 for 循环次数越大， for 的性能优势越明显 先做一下对比 |对比类型|for|forEach| |:---|:---|:---| |遍历|for循环按顺序遍历|forEach 使用 iterator 迭代器遍"},{"id":"227","title":"进程、线程、协程分别是什么概念？","category":"JavaScript","labels":["JavaScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/227","page":"q/javascript-227.html","excerpt":"进程（Process）和 线程（Thread） 进程（Process）和 线程（Thread）是操作系统中的重要概念。 **进程是指计算机中已经运行的程序，它是操作系统资源分配的最小单位**。进程拥有独立的内存空间和系统资源，如打开的文件、网络连接等。在操作系统中，每个进程都拥有一个唯一的标识符，称为进程ID。 **线"},{"id":"226","title":"前端动画有哪些实现方式？","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/226","page":"q/javascript-226.html","excerpt":"主要的实现方式 **JS 的实现方式** 通过定时器(setTimeout, setInterval)来间隔改变元素样式 requestAnimationFrame **CSS 3** 过度动画：transition animation 动画 **HTML 5** Canvas WebGL svg requestAni"},{"id":"225","title":"ES6 代码转成 ES5 代码的实现思路是什么？","category":"JavaScript","labels":["JavaScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/225","page":"q/javascript-225.html","excerpt":"ES6 代码转成 ES5 代码的实现思路主要是通过使用 Babel 这样的工具来实现。Babel 是一个广泛使用的 JavaScript 编译器，可以将 ES6 代码转换成向后兼容的 ES5 代码，从而在现有的浏览器和环境中运行。其主要实现思路如下： 词法分析：Babel 首先会将输入的代码进行词法分析，将代码分割成一"},{"id":"224","title":"对象取值中 a.b.c.d 和 a['b']['c']['d'] 有何区别？","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/224","page":"q/javascript-224.html","excerpt":"使用区别 在 JavaScript 中，对象的取值可以使用两种方式，即使用点号（.）和使用方括号（\\[\\]）。对于对象的多层嵌套属性，可以使用两种方式分别取值，例如： 这两种方式获取的结果是相同的，都是 123。其中，使用点号取值的方式称为“点操作符”，使用方括号取值的方式称为“方括号操作符”。 两种方式的区别在于： "},{"id":"222","title":"给定两个数组，写一个方法来计算它们的交集？","category":"JavaScript","labels":["JavaScript","腾讯","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/222","page":"q/javascript-222.html","excerpt":"可以使用 ES6 的 Set 数据结构来实现数组交集。 首先，将一个数组转化为 Set，然后遍历另一个数组，将数组中存在于 Set 中的元素存入结果数组中。 以下是一个示例代码： 使用示例： 该算法的时间复杂度为 O(m+n)，其中 m 和 n 分别为两个数组的长度。 Comments / Answers --- **"},{"id":"221","title":"箭头函数为何不能作为构造函数使用？","category":"JavaScript","labels":["JavaScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/221","page":"q/javascript-221.html","excerpt":"在箭头函数中，this指向的是定义时所在的对象，而不是使用时所在的对象。换句话说，**箭头函数没有自己的this，而是继承父作用域中的this**。 看个例子: person.getName()中this指向函数的调用者，也就是person实例，因此this.name = \"张三\"。 getAge()通过箭头函数定义，"},{"id":"218","title":"对象引用类问题：以下代码的执行结果是什么，并解释原因","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/218","page":"q/javascript-218.html","excerpt":"代码如下， 请问执行结果 执行结果和原因 结果是 undefined 和 {n: 2}。 这段代码可以分解为以下步骤： 创建一个对象 a，属性 n 的值为 1。 将变量 b 指向 a，b 现在也引用了这个对象。 执行赋值语句 a.x = a = {n: 2}，其中 a.x 引用的是对象 a 的 x 属性，但是此时 a "},{"id":"216","title":"实现 (5).add(3).minus(2) 功能","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/216","page":"q/javascript-216.html","excerpt":"可以通过在 Number 原型上定义 add 和 minus 方法来实现该功能，代码如下： 上述代码中，通过在 Number.prototype 上定义 add 和 minus 方法，实现了将数字类型的值转换为 Number 对象，并且可以链式调用这两个方法。最终返回的结果是一个数值类型的值。"},{"id":"214","title":"this指向与对象继承数组方法：输出以下代码执行的结果并解释为什么？","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/214","page":"q/javascript-214.html","excerpt":"代码如下 执行结果如何， 为什么？ 执行结果 代码的执行结果是： 在代码中，我们创建了一个名为 obj 的对象，它包含了一些属性和方法： 2 和 3 是对象的属性名，对应的属性值分别为 3 和 4。 length 属性的值为 2。 splice 和 push 是对象的两个方法，它们均继承自 Array.prototyp"},{"id":"212","title":"[3, 15, 8, 29, 102, 22].sort(), 结果是多少， 为什么？","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/212","page":"q/javascript-212.html","excerpt":"输出结果为： 原因： Array.prototype.sort() 如果没有指明 compareFn ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 \"Banana\" 会被排列到 \"cherry\" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFn"},{"id":"211","title":"下面代码中 a 在什么情况下会打印 1 ?","category":"JavaScript","labels":["JavaScript","京东"],"url":"https://github.com/pro-collection/interview-question/issues/211","page":"q/javascript-211.html","excerpt":"问题 回答 这是一个经典的面试题，可以通过重写 valueOf 或者 toString 方法来实现，在这些方法中动态返回变量 a 的值，以满足条件。例如： 在这个例子中，a 被定义为一个对象，有一个属性 i 初始化为 1，同时重写了 toString 方法，在每次调用时返回 i 的值，并且每次返回后将 i 自增。这样在"},{"id":"208","title":"使用迭代的方式实现 flatten 函数？","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/208","page":"q/javascript-208.html","excerpt":"可以使用迭代的方式实现 flatten 函数，具体思路如下： 创建一个新数组 result 来存放结果。 创建一个栈 stack，将原数组作为第一个元素压入栈中。 当栈不为空时，取出栈顶元素，如果该元素是一个数组，则将其展开后的每个元素压入栈中。 如果该元素不是一个数组，则将其加入到 result 中。 重复步骤 3 "},{"id":"205","title":"全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？","category":"JavaScript","labels":["JavaScript","百度"],"url":"https://github.com/pro-collection/interview-question/issues/205","page":"q/javascript-205.html","excerpt":"用 const 或 let 声明的变量不会挂在在 window 对象上，而是在一个称为块级作用域（block scope）的作用域内。这个作用域可以是一个函数、一个代码块（比如 {} 之间的语句），或者全局作用域。 在块级作用域中声明的变量无法通过 window 对象访问，只能在当前作用域内访问。如果要在全局作用域中访"},{"id":"202","title":"浏览器 和 Node 事件循环有区别吗？","category":"JavaScript","labels":["JavaScript","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/202","page":"q/javascript-202.html","excerpt":"浏览器和Node.js事件循环在本质上是相同的，它们都是基于事件循环模型实现异步操作。但是它们的实现细节和环境限制有所不同。 在浏览器中，事件循环模型基于浏览器提供的EventTarget接口，包括浏览器环境下的DOM、XMLHttpRequest、WebSocket、Web Worker等等，所有的异步任务都会被推入"},{"id":"201","title":"Redux 和 Vuex 的设计思想是什么？","category":"JavaScript","labels":["JavaScript","字节跳动"],"url":"https://github.com/pro-collection/interview-question/issues/201","page":"q/javascript-201.html","excerpt":"Redux和Vuex都是用于在前端应用中管理状态的JavaScript库。它们的设计思想都基于Flux架构，强调单向数据流的概念，以避免数据的混乱和不可预测的状态变化。 Redux的设计思想可以总结为三个原则： 单一数据源：Redux中所有的状态数据都保存在单一的store对象中，便于管理和维护。 状态只读：Redux"},{"id":"200","title":"手写订阅-发布模式","category":"JavaScript","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/200","page":"q/javascript-200.html","excerpt":"订阅-发布模式是一种常用的设计模式，它可以实现对象间的解耦，让它们不需要相互知道对方的存在，只需要关注自己需要订阅的事件即可。当一个对象的状态发生变化时，它可以发布一个事件通知其他对象，其他对象可以订阅该事件，当事件发生时得到通知并执行相应的处理。 在 JavaScript 中，订阅-发布模式也被称为事件模型。事件模型"},{"id":"199","title":"手写 观察者模式","category":"JavaScript","labels":["JavaScript","网易","阿里巴巴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/199","page":"q/javascript-199.html","excerpt":"观察者模式（又称发布-订阅模式）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，其相关的依赖对象都能够得到通知并被自动更新。 在 JavaScript 中实现观察者模式，可以分为以下几个步骤： 创建一个主题对象（Subject），用来存储观察者对象，并提供添加、删除、通知观察者的"},{"id":"198","title":"介绍下观察者模式和订阅-发布模式的区别？","category":"JavaScript","labels":["JavaScript","网易","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/198","page":"q/javascript-198.html","excerpt":"观察者模式和订阅-发布模式都属于事件模型，它们都是为了解耦合而存在，但是它们之间还是有一些不同之处的： 观察者模式中，主题（被观察者）和观察者之间是直接联系的，观察者订阅主题，主题状态发生变化时会直接通知观察者；而订阅-发布模式中，发布者和订阅者之间没有直接的联系，发布者发布消息到消息中心，订阅者从消息中心订阅消息。 "},{"id":"196","title":"如何从 http1.1 迁移到 http2 ?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/196","page":"q/javascript-196.html","excerpt":"从 HTTP 1.1 迁移到 HTTP/2 通常需要进行以下步骤： 升级服务器：首先，你需要将你的服务器升级到支持 HTTP/2。大多数主流服务器，如Apache、Nginx等，都已经支持 HTTP/2。 使用 HTTPS：HTTP/2 只支持加密连接，因此需要使用 HTTPS。所以，你需要获得一个 SSL 证书，并使"},{"id":"195","title":"Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/195","page":"q/javascript-195.html","excerpt":"Promise 构造函数是同步执行的，而 then 方法是异步执行的。 在 Promise 构造函数中，Promise 的状态（pending/resolved/rejected）是同步确定的。但是 Promise 中的异步操作可能还没有完成，因此 Promise 对象本身的值可能还没有可用的值。所以，当我们在构造函数"},{"id":"194","title":"JavaScript 异步解决方案的发展历程主要有哪些阶段？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/194","page":"q/javascript-194.html","excerpt":"JavaScript异步解决方案的发展历程主要有以下几个阶段： 回调函数 最初，JavaScript采用回调函数的方式来解决异步编程问题。回调函数即在异步任务完成后调用的回调函数。例如，setTimeout函数就是一个使用回调函数的例子。 回调函数的优点是简单易懂，缺点是嵌套层次多、代码难以维护。 jQuery.Def"},{"id":"193","title":"请分别用深度优先思想和广度优先思想实现一个拷贝函数？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/193","page":"q/javascript-193.html","excerpt":"深度优先思想实现拷贝函数可以采用递归的方式遍历对象或数组，对每个元素进行复制。如果当前元素是一个对象或数组，则递归调用拷贝函数，如果是基本数据类型则直接进行复制。以下是一个用深度优先思想实现拷贝函数的示例代码： 广度优先思想实现拷贝函数可以使用队列的方式，将每个元素放入队列中，然后循环遍历队列。如果当前元素是一个对象或"},{"id":"192","title":"介绍下深度优先遍历和广度优先遍历，如何实现？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/192","page":"q/javascript-192.html","excerpt":"深度优先遍历（Depth-First-Search，DFS）和广度优先遍历（Breadth-First-Search，BFS）是图和树的两种遍历方式。 深度优先遍历（DFS） 深度优先遍历采用深度优先的策略遍历整张图或树，即从当前节点开始，先访问其所有子节点，再依次访问子节点的子节点，直到遍历完整张图或树。 DFS 可"},{"id":"191","title":"['1', '2', '3'].map(parseInt) 结果是啥，为什么？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/191","page":"q/javascript-191.html","excerpt":"执行 ['1', '2', '3'].map(parseInt) 会得到 [1, NaN, NaN]，这个结果可能和人们预期的不一样。 这是因为 map 方法会传入三个参数：当前遍历到的元素、当前遍历到的索引、原数组本身。而 parseInt 函数则接受两个参数：需要被解析的值、用于解析的进制数。在执行 ['1', '"},{"id":"176","title":"WebWorker、SharedWorker 和 ServiceWorker 有哪些区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/176","page":"q/javascript-176.html","excerpt":"前言 众所周知，JavaScript 是单线程的语言。当我们面临需要大量计算的场景时（比如视频解码等），UI 线程就会被阻塞，甚至浏览器直接卡死。现在前端遇到大量计算的场景越来越多，为了有更好的体验，HTML5 中提出了 Web Worker 的概念。Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，"},{"id":"175","title":"Promise finally 怎么实现的？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/175","page":"q/javascript-175.html","excerpt":"Promise.finally() 方法是在 ES2018 中引入的，用于指定不管 Promise 状态如何都要执行的回调函数。与 Promise.then() 和 Promise.catch() 不同的是，Promise.finally() 方法不管 Promise 是成功还是失败都会执行回调函数，而且不会改变 Pr"},{"id":"174","title":"Promise then 第二个参数和 Promise.catch 的区别是什么?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/174","page":"q/javascript-174.html","excerpt":"Promise.then() 方法可以接受两个参数，第一个参数是 onFulfilled 回调函数，第二个参数是 onRejected 回调函数。当 Promise 状态变为 fulfilled 时，将会调用 onFulfilled 回调函数；当 Promise 状态变为 rejected 时，将会调用 onRejec"},{"id":"172","title":"es6 class 装饰器是如何实现的？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/172","page":"q/javascript-172.html","excerpt":"ES6 中的装饰器是一种特殊的语法，用于动态修改类的行为。在 JavaScript 中，装饰器本质上是一个函数，它可以接受一个类作为参数，并返回一个新的类，实现了类的增强或修改。装饰器可以被用于类、方法、属性等各种地方，可以方便地实现类似 AOP、元编程等功能。 装饰器是 ES7 中的一个提案，目前还没有正式纳入标准。"},{"id":"155","title":"常见的前端检测内存泄露的方法有哪些？","category":"JavaScript","labels":["JavaScript","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/155","page":"q/javascript-155.html","excerpt":"怎么检测内存泄漏 内存泄漏主要是指的是内存持续升高，但是如果是正常的内存增长的话，不应该被当作内存泄漏来排查。排查内存泄漏，我们可以借助Chrome DevTools的Performance和Memory选项。举个栗子： 我们新建一个memory.html的文件，完整代码如下： 页面上有一个按钮用来开始函数调用，方便我"},{"id":"154","title":"常见的前端内存泄露场景有哪些？","category":"JavaScript","labels":["JavaScript","浏览器"],"url":"https://github.com/pro-collection/interview-question/issues/154","page":"q/javascript-154.html","excerpt":"大多数情况下，垃圾回收器会帮我们及时释放内存，一般不会发生内存泄漏。但是有些场景是内存泄漏的高发区，我们在使用的时候一定要注意： 我们在开发的时候经常会使用console在控制台打印信息，但这也会带来一个问题：被console使用的对象是不能被垃圾回收的，这就可能会导致内存泄漏。因此在生产环境中不建议使用console"},{"id":"142","title":"事件循环原理?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/142","page":"q/javascript-142.html","excerpt":"通过一道题进入浏览器事件循环原理： 可以先试一下，手写出执行结果，然后看完这篇文章以后，在运行一下这段代码，看结果和预期是否一样 单线程 定义 单线程意味着所有的任务需要排队，前一个任务结束，才能够执行后一个任务。如果前一个任务耗时很长，后面一个任务不得不一直等着。 原因 javascript的单线程，与它的用途有关。"},{"id":"127","title":"如何实现可过期的 localstorage 数据?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/127","page":"q/javascript-127.html","excerpt":"以下是一个封装了支持过期时间的localStorage的示例代码： 使用方法如下： 在这个封装中，使用了一个自定义的前缀来避免与普通的localStorage键冲突。设置项时，会记录一个过期时间，如果有过期时间且当前时间超过了过期时间，在获取项时会返回null并自动删除该项。"},{"id":"126","title":"es5 和 es6 使用 new 关键字实例化对象的流程是一样的吗？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/126","page":"q/javascript-126.html","excerpt":"ES5 和 ES6 使用 new 关键字实例化对象的流程基本上是一样的，只是在细节上存在一些差异。 在 ES5 中，当使用 new 关键字调用一个函数时，会创建一个新的对象，并将这个新对象的 [[Prototype]] 属性指向构造函数的 prototype 属性。此外，new 关键字还会将构造函数内部的 this 关"},{"id":"125","title":"当使用 new 关键字创建对象时, 会经历哪些步骤？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/125","page":"q/javascript-125.html","excerpt":"在 JavaScript 中，new 关键字用于创建一个对象实例。当使用 new 关键字创建对象时，会发生以下几个步骤： 创建一个空的对象。 将这个空对象的 [[Prototype]] 属性设置为构造函数的 prototype 属性。 将这个空对象赋值给构造函数内部的 this 关键字，用于初始化属性和方法。 如果构造"},{"id":"116","title":"React Diff算法是怎么实现的？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/116","page":"q/javascript-116.html","excerpt":"原理 React 中的 Diff 算法，是用于比较新旧两个虚拟 DOM 树，找出需要更新的节点并进行更新的算法。React 的 Diff 算法实现基于以下假设： 两个不同类型的元素会产生不同的树形结构。 对于同一层级的一组子节点，它们可以通过唯一 id 匹配到相同的节点。 每个组件都有一个唯一标识符 key。 基于以上"},{"id":"115","title":"Proxy 和 Object.defineProperty 的区别是啥？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/115","page":"q/javascript-115.html","excerpt":"Proxy 和 Object.defineProperty 是 JavaScript 中两个不同的特性，它们的作用也不完全相同。 Object.defineProperty 允许你在一个对象上定义一个新属性或者修改一个已有属性。通过这个方法你可以精确地定义属性的特征，比如它是否可写、可枚举、可配置等。该方法的使用场景通"},{"id":"111","title":"null 和 undefined 的区别，如何让一个属性变为 null？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/111","page":"q/javascript-111.html","excerpt":"null和undefined都是JavaScript中表示缺失或无值的特殊值。 undefined是一个变量没有被赋值时的默认值，或者在访问对象属性或数组元素不存在时返回的值。例如： 而null表示一个变量被明确地赋值为没有值。例如： 要将一个属性的值设置为null，可以像这样： 如果要删除对象的属性并将其值设置为nu"},{"id":"109","title":"JavaScript 有几种方法判断变量的类型（类型检测）？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/109","page":"q/javascript-109.html","excerpt":"JavaScript 中有以下几种方法可以判断变量的类型 typeof 运算符：可以用于判断基本数据类型（如字符串、数字、布尔值、Undefined 等）和函数类型，但对于对象类型（如数组、日期、正则表达式等）不能准确判断。 instanceof 运算符：可以用于判断一个对象是否为某个构造函数的实例，但不能判断基本数据"},{"id":"108","title":"手写实现 Promise.allSettled","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/108","page":"q/javascript-108.html","excerpt":"Promise.allSettled 方法会接收一个 Promise 数组，并返回一个新的 Promise 对象。该新 Promise 对象会在所有输入的 Promise 都被 resolved 或 rejected 后变为 settled 状态，并且它的值是一个包含所有 Promise 状态的对象数组。 以下是手写实"},{"id":"105","title":"promise.race、promise.all、promise.allSettled 有哪些区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/105","page":"q/javascript-105.html","excerpt":"Promise.race()、Promise.all()、Promise.allSettled() 都是 JavaScript 中的 Promise 相关 API，它们的区别如下： Promise.race() Promise.race() 接收一个包含多个 Promise 的数组作为参数，返回一个新的 Promise"},{"id":"104","title":"说一说 cookie sessionStorage localStorage 区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/104","page":"q/javascript-104.html","excerpt":"cookie、sessionStorage和localStorage都是存储在浏览器端的客户端存储方式，用于存储一些客户端数据。 它们之间的区别如下： 生命周期 cookie的生命周期由Expires和Max-Age两个属性控制。当设置了Expires属性时，cookie的生命周期为设置的过期时间；当设置了Max-Ag"},{"id":"103","title":"箭头函数和普通函数的区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/103","page":"q/javascript-103.html","excerpt":"箭头函数和普通函数是 JavaScript 中两种不同的函数定义方式，它们有以下的区别： **语法不同**：箭头函数使用箭头 => 来定义函数，而普通函数使用 function 关键字来定义函数。 **箭头函数没有自己的 this**，它会继承其所在作用域的 this 值。而普通函数的 this 则由函数调用时的上下文"},{"id":"102","title":"map 和 weakMap 的区别 ?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/102","page":"q/javascript-102.html","excerpt":"Map 和 WeakMap 都是 JavaScript 中的键值对数据结构，它们的主要区别在于其键的存储方式和内存管理。 Map 对象中的键可以是任何类型的值，包括基本类型和引用类型，而 WeakMap 对象中的键必须是对象。在 Map 中，如果一个键不再被引用，它仍然会被 Map 对象保留，因为 Map 对象对其进行"},{"id":"97","title":"JS 中 this 有哪些使用场景？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/97","page":"q/javascript-97.html","excerpt":"this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 "},{"id":"95","title":"实现：setObjectValue(obj: object, keys: string[], value: any) 方法， 支持安全设置对象的值","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/95","page":"q/javascript-95.html","excerpt":"可以使用递归实现安全设置对象的值。以下是一个实现setObjectValue方法的例子： 这个方法接受三个参数：要设置值的对象，一个字符串数组表示对象的键的路径，和要设置的值。例如，如果要设置对象user的address字段的city属性为\"New York\"，可以调用方法： 在这个例子中，keys数组的第一个元素是\""},{"id":"94","title":"纯 TS 项目工程中, 如何使用 alias path?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/94","page":"q/javascript-94.html","excerpt":"TODO 待补充内容 可以看这个文档： https://www.miganzi.com/tech/typescript-s-paths-config/"},{"id":"93","title":"如何做一个前端项目工程的自动化部署， 有哪些规范和流程设计？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/93","page":"q/javascript-93.html","excerpt":"// TODO 待补充"},{"id":"92","title":"如何给自己团队的大型前端项目设计单元测试？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/92","page":"q/javascript-92.html","excerpt":"基本原则和步骤 调研基本的前端测试框架有哪些， 有哪些优劣 需要分别针对 utils 静态方法测试与 UI 交互测试（2E2测试） 针对测试， 产出衡量指标与实践规范 针对项目产出最佳实践 通过 CI 工具进行测试检查、覆盖、定时回归 参考文档 https://juejin.cn/post/70391083575541"},{"id":"91","title":"Iterator 和 for...of 了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/91","page":"q/javascript-91.html","excerpt":"Iterator 和 for...of 循环 <!-- toc --> $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 <!-- tocstop --> 1、Iterator 的概念 JavaScript 原有的表示 “ 集"},{"id":"85","title":"知道 JS 中的尾调用吗，如何做尾调优化？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/85","page":"q/javascript-85.html","excerpt":"深入理解 JavaScript 中的尾调用 $1 $1 1、什么是尾调用 尾调用是函数式编程里比较重要的一个概念，尾调用的概念非常简单， 一句话就能说清楚，它的意思是在函数的执行过程中，如果最后一个动作是一个函数的调用， 即这个调用的返回值被当前函数直接返回，则称为尾调用。 上面代码中，函数 f 的最后一步是调用函数 "},{"id":"84","title":"手写实现 call、apply、bind？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/84","page":"q/javascript-84.html","excerpt":"深入 call、apply、bind实现原理 $1 简单粗暴地来说，call，apply，bind是用于绑定this指向的。 什么是call和apply方法 我们单独看看ECMAScript规范对apply的定义，看个大概就行： 通过定义简单说一下call和apply方法，他们就是参数不同，作用基本相同。 1、每个函数"},{"id":"77","title":"虚拟 dom 原理是啥，手写一个简单的虚拟 dom 实现？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/77","page":"q/javascript-77.html","excerpt":"vdom 概念 用JS模拟DOM结构。 DOM变化的对比，放在JS层来做。 提升重绘性能。 比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。这样做的成本会非常高。 用JS模拟 dom 例如下面的一个dom 结构： 这样的dom 结构，可以"},{"id":"76","title":"JS 内存泄露问题该如何排查？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/76","page":"q/javascript-76.html","excerpt":"什么是内存泄露 该问题转载自：https://github.com/zhansingsong/js-leakage-patterns **内存泄漏**指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的"},{"id":"70","title":"前端做错误监控？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/70","page":"q/javascript-70.html","excerpt":"错误监控 **错误分类**：即时运行错误（代码错误）、资源加载错误 错误的捕获方式： **即时运行错误:** try...catch window.onerror **资源加载错误:** 1)、object.onerror 2)、performance.getEntries() 3)、Error事件捕获 perform"},{"id":"68","title":"如何避免重绘或者重排？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/68","page":"q/javascript-68.html","excerpt":"如何触发重排和重绘 任何改变用来构建渲染树的信息都会导致一次重排或重绘： 添加、删除、更新DOM节点 通过display: none隐藏一个DOM节点-触发重排和重绘 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化 移动或者给页面中的DOM节点添加动画 添加一个样式表，调整样式"},{"id":"60","title":"海量数据的处理问题: 如何从10亿个数中找出最大的10000个数？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/60","page":"q/javascript-60.html","excerpt":"从10亿个数中找出最大的10000个数是一项非常具有挑战性的任务，需要使用高效的算法和数据结构来处理。 以下是一种基于分治思想的常见方法： 将10亿个数分成1000个小文件，每个文件包含100万个数。 对每个小文件进行排序，选出每个文件中最大的1000个数，并将它们放入一个临时文件中。 将1000个临时文件合并成一个大"},{"id":"57","title":"手写 Promise , 并描述其原理与实现","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/57","page":"q/javascript-57.html","excerpt":"Primise原理与实现 目录 <!-- toc --> $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 <!-- tocstop --> Promise 核心 Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要） Promise 规范"},{"id":"56","title":"[ES6]模块与[CommonJS]模块的差异有哪些？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/56","page":"q/javascript-56.html","excerpt":"差异主要有如下几点： CommonJS 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值，ES6静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 加载的是整个模块，即将所有的"},{"id":"54","title":"请设计一个算法, 将两个有序数组合并为一个数组, 请不要使用concat以及sort方法","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/54","page":"q/javascript-54.html","excerpt":"可以使用双指针法来合并两个有序数组。具体步骤如下： 创建一个新的数组来存储合并后的结果。 初始化两个指针，分别指向两个数组的起始位置。 比较两个指针所指向的元素，将较小的元素添加到新数组中，并将对应指针向后移动一位。 重复步骤3，直到其中一个数组的指针超出了数组的范围。 将剩余的未合并元素直接添加到新数组的末尾。 返回"},{"id":"53","title":"手写实现函数节流","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/53","page":"q/javascript-53.html","excerpt":"实现函数节流 $1 函数节流是什么 **对于持续触发的事件，规定一个间隔时间（n秒），每隔一段只能执行一次。** 函数防抖（debounce）与本篇说的函数节流（throttle）相似又不同。 函数防抖一般是指对于**在事件被触发n秒后再执行的回调，如果在这n秒内又重新被触发，则重新开始计时。** 二者都能防止函数过于"},{"id":"52","title":"process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/52","page":"q/javascript-52.html","excerpt":"process.nextTick, setTimeout 以及 setImmediate 三者的执行顺序 $1 首先来看一个非常经典的例子： macro-task(宏任务): script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering. "},{"id":"51","title":"手写防抖函数","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/51","page":"q/javascript-51.html","excerpt":"实现函数防抖 参考文档： $1 函数防抖是什么 函数防抖是指对于在事件被触发n秒后再执行的回调，如果在这n秒内又重新被触发，则重新开始计时，是常见的优化，适用于 表单组件输入内容验证 防止多次点击导致表单多次提交 等情况，防止函数过于频繁的不必要的调用。 代码实现 思路 用 setTimeout 实现计时，配合 cle"},{"id":"50","title":"数字字符串千分位处理(正则与非正则)？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/50","page":"q/javascript-50.html","excerpt":"先介绍几种基本的数字处理技巧 实现数字千分法方法总结 以上方法性能总结： 原生api大法："},{"id":"48","title":"commonjs 模块引用规范有哪些？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/48","page":"q/javascript-48.html","excerpt":"commonjs 模块引用管理规范 规范定义： 每一个文件是一个模块，有自己的作用域 在模块内部的module变量代表模块本身 module.exports属性代表模块对外接口 require规则： /表示绝路径，./表示相对于当前文件的路径 支持js、json、node扩展名，不写就依次尝试 不写路径名就认为是bui"},{"id":"47","title":"js 宏任务与微任务都是指什么， 优先级如何？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/47","page":"q/javascript-47.html","excerpt":"在JavaScript中，宏任务（macro-task）和微任务（micro-task）是指异步操作的两种类型。 基本操作 **宏任务通常包括以下操作：** setTimeout和setInterval定时器回调函数 事件回调函数（例如，鼠标点击、键盘输入等） AJAX请求的回调函数 请求动画帧（requestAnim"},{"id":"46","title":"银行卡号四位空一位， 例如：6222023100014763381 -->6222 0231 0001 4763 381","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/46","page":"q/javascript-46.html","excerpt":"Comments / Answers --- **r-qx** at 2024-12-21T04:20:07Z 如果是字符串声明的话太简单了，建议用BigInt转为字符串"},{"id":"44","title":"数组去重方式有哪些，简单手写一下？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/44","page":"q/javascript-44.html","excerpt":"数组去重 **1、双层循环，外层循环元素，内层循环时比较值如果有相同的值则跳过，不相同则push进数组** **2、利用splice直接在原数组进行操作** 双层循环，外层循环元素，内层循环时比较值 值相同时，则删去这个值 注意点:删除元素之后，需要将数组的长度也减1. **3、利用对象的属性不能相同的特点进行去重**"},{"id":"40","title":"JS 深拷贝有哪些方式， 手写实现一下？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/40","page":"q/javascript-40.html","excerpt":"关于深拷贝和浅拷贝的实现 目录 <!-- toc --> $1 $1 $1 $1 $1 $1 <!-- tocstop --> No.1 浅拷贝存在的问题 extend(person,programer) programer.schools[0]='lelele' person.schools[0] //输出结果也是l"},{"id":"39","title":"JS 中 this 指向问题了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/39","page":"q/javascript-39.html","excerpt":"关于 this 指针的研究 基础实例说明 实例1： 如果在html 端， 这个this.name 是可以调用全局对象name的， 这个this实际上是指向的window的， var 也是把变量挂在到window对象上面的。 但是同样的这个实例如果放在node 端，就是一个undefined ,原因是node端没有win"},{"id":"38","title":"手写实现一下 lodash.get？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/38","page":"q/javascript-38.html","excerpt":"lodash.get 是一个 JavaScript 库 Lodash 中的函数，它允许您在对象中安全地获取深层嵌套的属性值，即使在中间的属性不存在时也不会引发错误。以下是一个简单的实现： 使用示例："},{"id":"37","title":"关于 JS 闭包了解多少","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/37","page":"q/javascript-37.html","excerpt":"关于闭包的研究 <div id=\"class01\">一、什么是闭包和闭包的几种写法和用法</div> 1.1、什么是闭包 闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。"},{"id":"34","title":"DOM事件类相关问题","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/34","page":"q/javascript-34.html","excerpt":"DOM事件级别、DOM事件模型、DOM事件流、DOM事件捕获的具体流程、Event对象的常见应用、自动以事件 dom 级别 DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。 DOM级别其实就是标准的迭代，对于版本的称呼，类似ES5、ES6。 1、DOM0级 DOM没有被W3C定为标准之前"},{"id":"32","title":"解释一下 原型、构造函、实例、原型链 之间的关系？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/32","page":"q/javascript-32.html","excerpt":"创建对象有哪几种方式？ 解释一下 原型、构造函、实例、原型链 之间的关系？ 1、基础 构造函数可以通过new来生成一个实例、构造函数也是函数； 函数都有一个prototype属性，这个就是原型对象； 原型对象可以通过构造器constructor来指向它的构造函数； 实例的__proto__属性，指向的是其构造函数的原型"},{"id":"31","title":"JS 中继承方式有哪些？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/31","page":"q/javascript-31.html","excerpt":"1、借助构造函数实现继承 call和apply改变的是JS运行的上下文: 父类的this指向到了子类上面去，改变了实例化的this 指向，导致了父类执行的属性和方法，都会挂在到 子类实例上去； 缺点：父类原型链上的东西并没有被继承； 2、通过原型链实现继承 Child2.prototype是Child2构造函数的一个属"},{"id":"30","title":"实现一个双向链表， 具备添加节点、删除节点、在特定位置插入节点、查找节点、遍历等功能","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/30","page":"q/javascript-30.html","excerpt":"必须要掌握的知识 在 JavaScript 中实现双向链表需要掌握以下知识点： 如何使用构造函数和类创建双向链表节点，以及如何在节点之间建立双向连接。 双向链表的常用操作，包括添加节点、删除节点、在特定位置插入节点、查找节点等。 双向链表的遍历和迭代，包括正向遍历、反向遍历、循环遍历等。 链表的常见问题，例如链表是否为"},{"id":"24","title":"JS数据类型有哪些，区别是什么？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/24","page":"q/javascript-24.html","excerpt":"在 JavaScript 中，数据类型可以分为两类：**原始类型和对象类型**。原始类型包括：数字（number）、字符串（string）、布尔值（boolean）、null、undefined 和 Symbol（ES6 新增），对象类型包括：对象（object）、数组（array）、函数（function）等。 区别"},{"id":"23","title":"详细讲一下 Symbol 数据类型特征与实际使用案例？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/23","page":"q/javascript-23.html","excerpt":"Symbol 概要简介 Symbol 是 ECMAScript 6 引入的一种新的原始数据类型，用来表示独一无二的值。每个 Symbol 值都是唯一的，因此可以用来创建一些独特的标识符。 定义 Symbol 的定义非常简单，只需要调用 Symbol() 方法即可，例如： 在使用 Symbol 的时候，可以给它传递一个可"},{"id":"22","title":"js 对象可以使用 for...of 迭代吗？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/22","page":"q/javascript-22.html","excerpt":"JavaScript **对象本身并不能直接使用 for...of 迭代**，因为它并不是一个可迭代对象（iterable）。 但是，如果我们想要遍历对象的属性，可以使用 for...in 循环，例如： 需要注意的是，for...in 循环会遍历对象自身的所有可枚举属性，包括非数字键和继承的属性。如果只想遍历对象自身的"},{"id":"21","title":"如何使对象 iterable 化， 以其可以支持 for...of 迭代","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/21","page":"q/javascript-21.html","excerpt":"在 JavaScript 中，如果一个对象要被 for...of 迭代，那么它必须是可迭代的。可迭代对象是一种具有 Symbol.iterator 方法的对象，该方法返回一个迭代器对象，该迭代器对象实现了 next() 方法，每次调用 next() 方法都返回一个包含 value 和 done 属性的对象，用于迭代对象"},{"id":"20","title":"JS 有哪些迭代器，该如何使用？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/20","page":"q/javascript-20.html","excerpt":"迭代器分类 在 JavaScript 中，有三种类型的迭代器： **Array Iterator（数组迭代器）**：通过对数组进行迭代以访问其元素。 **String Iterator（字符串迭代器）**：通过对字符串进行迭代以访问其字符。 **Map Iterator（映射迭代器）和 Set Iterator（集合迭"},{"id":"18","title":"手写创建一个 ajax 请求","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/18","page":"q/javascript-18.html","excerpt":"手动创建一个 ajax 请求 一般来说，我们可以使用XMLHttpRequest对象来创建Ajax请求，其流程如下： 创建XMLHttpRequest对象，通过调用其构造函数来实现。 使用open()方法指定请求的方法、URL以及是否异步请求。 使用setRequestHeader()方法设置请求头，例如设置请求的Co"},{"id":"17","title":"ajax如何获取下载进度?","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/17","page":"q/javascript-17.html","excerpt":"ajax如何获取下载进度? 要获取下载进度，可以使用 XMLHttpRequest 对象提供的 onprogress 事件。 使用 onprogress 事件，可以获取文件的下载进度信息，可以通过 loaded 和 total 属性获取当前已经下载的字节数和文件的总字节数，从而计算出当前的下载进度。 下面是一个使用 o"},{"id":"11","title":"常见数组排序算法有哪些？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/11","page":"q/javascript-11.html","excerpt":"常见排序算法中，时间复杂度和空间复杂度是怎样的？ 如图所示： 快速排序： 先从数列中取出一个数作为“基准”。 分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。 再对左右区间重复第二步，直到各区间只有一个数。 选择排序： 首先在未排序序列中找到最小（大）元素，存放到排序序"},{"id":"10","title":"let 和 const 与 var 的区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/10","page":"q/javascript-10.html","excerpt":"let 和 const 与 var 的区别 1、不存在变量提升 必须先定义后使用，否则报错 2、暂时性死区 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 3、不允许重复申明/不允许在函数内部重新申明参数（也算重复申明）"},{"id":"9","title":"call、apply、bind 的区别和用法？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/9","page":"q/javascript-9.html","excerpt":"call、apply 和 bind 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法，它们的区别和用法如下： call call 方法可以改变函数的 this 指向，同时还能传递多个参数。 **call 方法的语法如下：** fun：要调用的函数。 thisArg：函数内部 this 指"},{"id":"8","title":"Proxy 和 Reflect 了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/8","page":"q/javascript-8.html","excerpt":"Proxy 基本概念 Proxy(代理) 是 ES6 中新增的一个特性。Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。 使用 Proxy 的好处是：对象只需关注于核心逻辑，一些非核心的逻辑 （如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某"},{"id":"7","title":"es6 数据结构 Set 了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/7","page":"q/javascript-7.html","excerpt":"Set 基本概念 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。 另外，NaN 和 undefined 都可以被存储在 Set 中，NaN 之间被视为相同的值（NaN 被认为是相同"},{"id":"6","title":"如何检测对象是否循环引用？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/6","page":"q/javascript-6.html","excerpt":"检测循环引用 例如下面的场景， 已经出现循环引用了， 如何检测？ 解答：使用 WeakSet 特性解决； 参考：$1 Comments / Answers --- **Guan-Erjia** at 2025-05-31T06:36:33Z JSON.stringify 如果报错就是循环引用 --- **canvasc"},{"id":"5","title":"Map 和 Object 有哪些主要的区别？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/5","page":"q/javascript-5.html","excerpt":"不过 Map 和 Object 有一些重要的区别，在下列情况中使用 Map 会是更好的选择： <table class=\"standard-table\"> <thead> <tr> <th scope=\"row\"></th> <th scope=\"col\">Map</th> <th scope=\"col\">Object"},{"id":"4","title":"ES6 Map 数据结构了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/4","page":"q/javascript-4.html","excerpt":"基本概念 Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。 Map 对象是键值对的集合。Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。Map 对象按键值对迭代——一个 for...of 循环在每次迭代后会返回一个形式为 [key，value"},{"id":"3","title":"ES6 Generator 了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/3","page":"q/javascript-3.html","excerpt":"Generator 基本概念 ES6中的 Generator（生成器）是一种特殊类型的函数，它可以被暂停和恢复。这意味着在调用Generator函数时，它不会立即执行，而是返回一个可暂停执行的Generator对象。在需要的时候，可以通过调用.next()方法来恢复函数的执行。这使得我们能够编写更具表现力和灵活性的代码"},{"id":"2","title":"async/await 原理， 手写 async 函数？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/2","page":"q/javascript-2.html","excerpt":"async/await 的本质 async/await 是 ECMAScript 2017（ES8）中引入的一个语言特性，用于处理异步编程。async/await 实际上是对 Promise 的封装，通过让开发者以同步的方式编写异步代码，使得代码更加易读和易于维护。 async/await 是一种更加高级的异步编程方式"},{"id":"1","title":"Promise 了解多少？","category":"JavaScript","labels":["JavaScript"],"url":"https://github.com/pro-collection/interview-question/issues/1","page":"q/javascript-1.html","excerpt":"Promise 对象 1、Promise 的含义 Promise 是异步编程的一种解决方案，比传统的解决方案 —— 回调函数和事件 —— 更合理和更强大。它由社区最早提出和实现， ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 Promise对象有以下两个特点。 **（ 1 ）对象的状态不受外界"},{"id":"1091","title":"node 里面 stream 是什么, 有啥应用场景【热度: 495】","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/1091","page":"q/nodejs-1091.html","excerpt":"**关键词**：node stream 一、stream 的概念与应用场景 **概念引入与文件读取对比**：文章以一个简单的 HTTP 服务读取文件并返回响应的示例引入。起初，使用fs.readFileSync读取小文件并返回响应，这种方式在文件较小时可行。但当文件增大到几百 M 时，全部读取完再返回会导致长时间等待，"},{"id":"1025","title":"什么是 semver 规范，~1.2.3 与 ^1.2.3 的版本号范围是多少【热度: 233】","category":"Nodejs","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1025","page":"q/nodejs-1025.html","excerpt":"SemVer（Semantic Versioning，语义化版本）是一种规范，用于管理软件版本号的命名和变更。它的目的是通过明确的版本号规则，让开发者和用户能够更好地理解软件的变化和兼容性。 SemVer 版本号由三个部分组成：主版本号（major）、次版本号（minor）和修订版本号（patch），格式为major."},{"id":"1024","title":"如何使用 node 做一个全局命令行工具【热度: 141】","category":"Nodejs","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1024","page":"q/nodejs-1024.html","excerpt":"作者备注 这个问题， 其实本质就是一个 package.json 配置里面的 bin 配置， 没有多大的价值 以下是使用 Node.js 创建一个全局命令行工具的步骤： **一、创建项目结构** 创建一个新的文件夹作为项目目录，例如my-cli-tool。 在项目目录中，初始化一个新的 Node.js 项目，可以使用n"},{"id":"991","title":"部署一个 node 应用要考虑哪些因素【热度: 98】","category":"Nodejs","labels":["Nodejs","工程化","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/991","page":"q/nodejs-991.html","excerpt":"**关键词**：node 应用部署 **一、选择服务器和环境** **服务器选择**： 可以选择云服务器提供商（如阿里云、腾讯云、AWS 等）的虚拟服务器或容器服务。根据应用的需求和预算，确定服务器的配置（CPU、内存、存储等）。 考虑服务器的地理位置和网络连接质量，以确保用户能够快速访问应用。 **操作系统**： 常"},{"id":"979","title":"node 中 nextTick 与 setTimeout 有什么区别【热度: 220】","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/979","page":"q/nodejs-979.html","excerpt":"**关键词**：nextTick 与 setTimeout 区别 在 Node.js 中，process.nextTick()和setTimeout()有以下区别： **一、执行时机** process.nextTick()： nextTick会在当前事件循环的当前阶段结束后立即执行回调函数。这意味着它会在所有同步代码"},{"id":"831","title":"在低版本的 node 中想使用 es module 该如何做？【热度: 188】","category":"Nodejs","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/831","page":"q/nodejs-831.html","excerpt":"**关键词**：node 使用 es module 在低版本的 Node.js 中想要使用 ES Modules (ESM)，你主要有以下几种方法。但是，请注意，这些方法或许涉及到一定程度的实验性特性或依赖第三方工具，可能不会像在高版本 Node.js 中那样稳定。 1. 使用实验性支持 在 Node.js 版本 8."},{"id":"830","title":"node 里面可以使用 es module 吗【热度: 187】","category":"Nodejs","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/830","page":"q/nodejs-830.html","excerpt":"**关键词**：node 使用 es module 是的，从 Node.js 的较新版本开始，你可以在 Node.js 中使用 ES Modules（ESM）。 如何启用 ES Modules 要在 Node.js 中使用 ES Modules，你可以采取以下几种方式之一： **使用 .mjs 扩展名**: 你可以将你"},{"id":"721","title":"前端渲染和后端渲染各有啥优缺点， 为何现在技术大方向又逐渐往【后端渲染】方向靠了呢？【热度: 470】","category":"Nodejs","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/721","page":"q/nodejs-721.html","excerpt":"**关键词**：前端渲染优缺点、后端渲染优缺点 前端渲染（Client-Side Rendering，CSR）和后端渲染（Server-Side Rendering，SSR）是两种不同的网页渲染策略，每种方法都有其固有的优势和劣势。近几年来，后端渲染之所以又开始受到重视，主要是由于它在某些方面更加适应了新的技术需求和趋"},{"id":"720","title":"express 里面的 中间件 和 插件， 是一个意思吗？【热度: 469】","category":"Nodejs","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/720","page":"q/nodejs-720.html","excerpt":"**关键词**：express 中间件、express 插件 在 Express.js 中，\"中间件\" 和 \"插件\" 这两个术语有时被交替使用，但实际上它们可能指向不同类型的组件，其差异取决于上下文。 中间件 (Middleware) 中间件是 Express 架构的核心部分，它是具有访问请求对象（req），响应对象（"},{"id":"641","title":"nodejs 如何充分利用多核 CPU?【热度: 725】","category":"Nodejs","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/641","page":"q/nodejs-641.html","excerpt":"**关键词**：nodejs 多CPU使用 总所周知， NodeJS 是单线程执行任务， 不同于 浏览器还可以使用 web worker 等手段多线程执行任务。那么 NodeJS 中， 是如何充分利用物理机的多核 CPU 呢？ 有三种方式 在 Node.js 中，JS 也是单线程的，只有一个主线程用于执行任务。但是，在"},{"id":"598","title":"PM2 部署 nodejs 有哪些优势？【热度: 199】","category":"Nodejs","labels":["Nodejs","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/598","page":"q/nodejs-598.html","excerpt":"**关键词**：PM2 Nodejs PM2部署Node.js应用程序有以下几个优势： 进程管理和监控：PM2可以自动监控Node.js应用程序的运行状态，并在进程崩溃或无响应时自动重启进程。它还提供了实时的日志输出和监控面板，方便查看和分析应用程序的运行情况。 无缝部署和热重载：使用PM2可以实现无缝部署Node.j"},{"id":"386","title":"不使用任何中间件， koa 如何解析 post 请求参数【热度: 1,359】","category":"Nodejs","labels":["Nodejs","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/386","page":"q/nodejs-386.html","excerpt":"**关键词**：koa 请求、koa 解析、koa body-parser 如果你不想使用任何中间件来解析 POST 请求参数，你可以手动解析请求体数据。在 Koa 中，你可以通过以下步骤来解析 POST 请求的参数： 使用 ctx.req 获取原始的 Node.js 请求对象。 将请求对象的数据流通过 ctx.req"},{"id":"383","title":"node 子进程了解多少【热度: 1,424】","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/383","page":"q/nodejs-383.html","excerpt":"**关键词**：node 子进程 开启子进程 在Node.js中，可以通过child_process模块来开启子进程。child_process模块提供了一些方法来创建和操作子进程。 以下是一些常用的方法用于开启子进程： spawn(command[, args][, options]): 这个方法用于启动一个新的进程"},{"id":"228","title":"单线程的 nodejs 是如何充分利用计算机 CPU 资源的呢？","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/228","page":"q/nodejs-228.html","excerpt":"虽然 Node.js 是单线程的，但是它能够充分利用计算机的 CPU 资源的原因在于其采用了事件驱动和异步 I/O 的方式来处理请求，而不是采用阻塞式 I/O 的方式。这使得 Node.js 能够在处理一个请求时不会因为等待 I/O 操作而阻塞，从而可以处理更多的请求。 具体来说，当 Node.js 启动一个程序时，会"},{"id":"146","title":"nodejs 进程间如何通信?","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/146","page":"q/nodejs-146.html","excerpt":"在 Node.js 中，进程间通信（IPC）可以通过以下几种方式进行： 使用子进程模块：可以使用 Node.js 的子进程模块（child\\_process）来创建子进程，并使用进程间通信机制（如进程间管道）来实现通信。 使用共享内存：Node.js 中的共享内存模块（sharedArrayBuffer）可以在多个进程"},{"id":"87","title":"如何进行 node 内存优化？","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/87","page":"q/nodejs-87.html","excerpt":"目录 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 V8内存生命周期 假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程： 1、这个对象被分配到了 new space；"},{"id":"86","title":"V8 引擎了解多少？","category":"Nodejs","labels":["Nodejs","网络"],"url":"https://github.com/pro-collection/interview-question/issues/86","page":"q/nodejs-86.html","excerpt":"目录 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 渲染引擎与网页渲染 编程分类 编程语言分为 **编译型语言和解释型语** 言两类。 编译型语言在执行之前要先进行完全编译，而 **解释型语言一边编译一边执行**， 很明显解释型语言的执行速度是慢于编译型语言"},{"id":"73","title":"express middleware(中间件) 工作原理是什么？？","category":"Nodejs","labels":["Nodejs"],"url":"https://github.com/pro-collection/interview-question/issues/73","page":"q/nodejs-73.html","excerpt":"express middleware 工作原理是什么？ Express middleware 的工作原理是通过拦截 HTTP 请求，对请求进行处理，然后将请求传递给下一个中间件或应用程序的路由处理。在 Express 中，中间件可以是一个或多个函数，每个函数都可以对请求进行操作或响应，从而实现对请求的处理和过滤。 当 "},{"id":"1062","title":"如果一行文本展示不下，如何使其通过 popover 来展示全部内容？【热度: 325】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/1062","page":"q/pdd-1062.html","excerpt":"**关键词**：动态计算文本是否溢出 作者备注 主要考核 JS 动态计算文本是否溢出 以下是一种使用 HTML、CSS 和 JavaScript 来实现当文本一行展示不下时通过popover展示全部内容的基本方法。假设你在一个网页环境中操作。 **HTML 结构** 首先，创建一个包含文本的元素，例如一个span标签。"},{"id":"1028","title":"npm install 之后需要执行一些处理工作，应该如何处理【热度: 162】","category":"PDD","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/1028","page":"q/pdd-1028.html","excerpt":"**关键词**：html 标签元素 如果在执行npm install之后需要执行一些处理工作，可以通过以下几种方式来实现： **一、使用postinstall脚本** 在package.json文件中添加scripts字段，并在其中定义一个postinstall脚本： - 例如，如果需要在安装后运行一个构建脚本，可以设"},{"id":"827","title":"对象的遍历方式有哪些【热度: 848】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/827","page":"q/pdd-827.html","excerpt":"**关键词**：对象遍历方式 遍历 JavaScript 对象的属性可以使用几种不同的方法，每种方法都有其适用场景和特点。以下是一些常用的遍历对象属性的方法： 1. **for-in 循环** for-in 循环可以遍历一个对象的所有**可枚举属性**，包括其原型链上的属性。 使用 hasOwnProperty 方法检"},{"id":"791","title":"判断一个对象是否为空，包含了其原型链上是否有自定义数据或者方法。 该如何判定？【热度: 546】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/791","page":"q/pdd-791.html","excerpt":"**关键词**：原型链相关知识 要判断一个对象是否为空，并且考虑到对象自身及其原型链上是否有自定义数据或方法，您可以使用以下的 JavaScript 函数来实现： 可以使用这个函数来判断对象是否为空，例如： Comments / Answers --- **whynyist** at 2024-07-31T09:51:"},{"id":"790","title":"js 如何判空？ 「空」包含了：空数组、空对象、空字符串、0、undefined、null、空 map、空 set , 都属于为空的数据【热度: 640】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/790","page":"q/pdd-790.html","excerpt":"**关键词**：判断 以下是一个 JavaScript 方法，用于校验您提到的各种“为空”的场景： 您可以使用这个方法来检测各种值是否为空，例如："},{"id":"788","title":"请求失败会弹出一个 toast , 如何保证批量请求失败， 只弹出一个 toast【热度: 420】","category":"PDD","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/788","page":"q/pdd-788.html","excerpt":"**关键词**：单例 toast 要确保批量请求失败时只弹出一个 toast，可以通过以下几种方式实现： 设置全局标志位：定义一个全局变量（如 isToastShown）来表示是否已经弹出过 toast。在请求失败的处理逻辑中，首先检查该标志位。如果尚未弹出 toast，则进行弹出操作，并设置标志位为 true；如果标"},{"id":"786","title":"一般是怎么做代码重构的【热度: 191】","category":"PDD","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/786","page":"q/pdd-786.html","excerpt":"**关键词**：代码重构 在前端项目中进行代码重构，一般可以遵循以下步骤： 明确重构目标 确定需要解决的问题，例如提高代码的可读性、可维护性、性能，或者去除重复代码等。 代码分析 对现有代码进行全面的审查和理解，包括代码结构、逻辑流程、函数和模块之间的关系等。 可以使用工具如 ESLint 检查代码风格和潜在问题，使用"},{"id":"773","title":"技术选型上有一些什么标准【热度: 622】","category":"PDD","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/773","page":"q/pdd-773.html","excerpt":"**关键词**：技术选型 作者推荐一下五个标准，适用于编程语言、框架、大小工具库 等方向 可控性 稳定性 适用性 易用性 唯一性 当然，以下是对你提出的五个前端技术选型原则的详细描述： **可控性**： **定义**：选择的技术应该使团队能够对产品的开发过程有充分的控制，包括代码质量、部署流程、性能优化和错误处理等方面"},{"id":"741","title":"[React] forwardsRef 作用是啥， 有哪些使用场景？【热度: 336】","category":"PDD","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/741","page":"q/pdd-741.html","excerpt":"**关键词**：forwardsRef 作用、forwardsRef 使用场景 在 React 中，forwardRef 是一个用来传递 ref 引用给子组件的技术。通常情况下，refs 是不会透传给子组件的，因为 refs 并不是像 props 那样的属性。forwardRef 提供了一种机制，可以将 ref 自动地"},{"id":"654","title":"[webpack] webpack-dev-server 作用是啥？【热度: 387】","category":"PDD","labels":["工程化","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/654","page":"q/pdd-654.html","excerpt":"**关键词**：webpack-dev-server 作用 webpack-dev-server 是一个开发服务器，它提供了一个快速开发的环境，并且配合Webpack使用。它的作用主要有以下几个方面： **自动编译和打包**：webpack-dev-server 可以监听源文件的变化，当文件发生改动时，它会自动重新编译"},{"id":"621","title":"IndexedDB 存储空间大小是如何约束的？【热度: 116】","category":"PDD","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/621","page":"q/pdd-621.html","excerpt":"**关键词**：IndexedDB 存储空间大小设置 IndexedDB 有大小限制。具体来说，IndexedDB 的大小限制通常由浏览器实现决定，因此不同浏览器可能会有不同的限制。 一般来说，IndexedDB 的大小限制可以分为两个方面： 单个数据库的大小限制：每个 IndexedDB 数据库的大小通常会有限制，这"},{"id":"620","title":"浏览器的存储有哪些【热度: 814】","category":"PDD","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/620","page":"q/pdd-620.html","excerpt":"**关键词**：浏览器存储 在浏览器中，有以下几种常见的存储方式： Cookie：Cookie 是一种存储在用户浏览器中的小型文本文件。它可以用于存储少量的数据，并在浏览器与服务器之间进行传输。Cookie 可以设置过期时间，可以用于维持用户会话、记录用户偏好等功能。 Web Storage：Web Storage 是"},{"id":"526","title":"html 标签属性 src 和 href 有什么区别【热度: 1,134】","category":"PDD","labels":["浏览器","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/526","page":"q/pdd-526.html","excerpt":"**关键词**：src和href 有什么区别 下面是一个表格，展示了src和href属性之间的异同点： | 特点 | src属性 | href属性 | |----------------|----------------------------------------|-------------------------"},{"id":"514","title":"[Vue] 组件之间的通信方式有哪些？【热度: 1,109】","category":"PDD","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/514","page":"q/pdd-514.html","excerpt":"**关键词**：vue组件通信、vue通信、Vuex组件通信、$refs组件通信 在Vue中 组件之间的通信总结 在Vue中，组件之间的通信可以通过以下几种方式实现： Props/Attributes：父组件通过向子组件传递属性（props），子组件通过props接收父组件传递的数据。这是一种单向数据流的方式。 Eve"},{"id":"505","title":"[React] 如何给 children 添加额外的属性【热度: 527】","category":"PDD","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/505","page":"q/pdd-505.html","excerpt":"**关键词**：cloneElement、children 添加额外属性 在 React 中，可以使用 React.cloneElement() 方法来给 children 添加额外的属性。 React.cloneElement(element, props, ...children) 其中，element 是需要克隆"},{"id":"504","title":"[React] hooks 和 memorizedState 是什么关系?【热度: 836】","category":"PDD","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/504","page":"q/pdd-504.html","excerpt":"**关键词**：memorizedState、添加和管理状态 **hooks 和 memorizedState 之间的关系** 在React中，Hooks是一种特殊的函数，用于在函数组件中添加和管理状态以及其他React特性。而memorizedState是React内部用于存储和管理Hooks状态的数据结构。 当你在"},{"id":"476","title":"[React] 函数组件和 class 组件有什么区别？【热度: 1,029】","category":"PDD","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/476","page":"q/pdd-476.html","excerpt":"**关键词**：React函数组件对比类组件、React函数组件对比类组件性能、React函数组件对比类组件状态管理、React函数组件与类组件 函数组件和类组件是React中两种定义组件的方式，它们有以下区别： 语法：函数组件是使用函数声明的方式定义组件，而类组件是使用ES6的class语法定义组件。 写法和简洁性："},{"id":"460","title":"[代码实现] 手写实现 instanceof【热度: 535】","category":"PDD","labels":["PDD","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/460","page":"q/pdd-460.html","excerpt":"**关键词**：instanceof原理、instanceof实现、instanceof手写 instanceof 运算符用于检测一个对象是否是某个构造函数的实例。其作用是判断一个对象是否属于某个类（或其父类）的实例，类似于类的继承关系，如果是则返回 true，否则返回 false。通常情况下，用于判断一个对象的类型或"},{"id":"447","title":"JS 中的数组和函数在内存中是如何存储的？【热度: 815】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/447","page":"q/pdd-447.html","excerpt":"**关键词**：数组和函数在内存中存储方式 在JavaScript中，数组和函数在内存中的存储方式有一些不同。 数组（Array）的存储： 数组是一种线性数据结构，它可以存储多个值，并且这些值可以是不同类型的。在内存中，数组的存储通常是连续的。当创建一个数组时，JavaScript引擎会为其分配一段连续的内存空间来存储"},{"id":"440","title":"use strict是什么? 它有什么用？【热度: 758】","category":"PDD","labels":["JavaScript","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/440","page":"q/pdd-440.html","excerpt":"**关键词**：JS 编译指示、JS 严格模式 \"use strict\" 是 JavaScript 中的一个编译指示（directive），用于启用严格模式（strict mode）。 严格模式是 JavaScript 的一种执行模式，它增强了代码的健壮性、可维护性和安全性，并减少了一些常见的错误。启用严格模式后，Ja"},{"id":"967","title":"http 缓存 header 中的 Date 与 Last-Modified 有什么不同【热度: 276】","category":"Shopee","labels":["网络","web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/967","page":"q/shopee-967.html","excerpt":"**关键词**：http 缓存 header 在 HTTP 响应头中，Date和Last-Modified有以下不同： **一、含义不同** Date：表示消息产生的时间。服务器用这个时间来标记响应报文的生成时间，它反映了服务器生成响应的时刻。例如，“Mon, 07 Oct 2024 12:34:56 GMT”，这个时"},{"id":"870","title":"内联加载样式和外联加载样式有啥区别【热度: 383】","category":"Shopee","labels":["CSS","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/870","page":"q/shopee-870.html","excerpt":"**关键词**：样式加载 内联样式（Inline Style）和外联样式（External Style）是 CSS 应用在 HTML 文档中的两种不同方法，它们主要的区别在于如何将 CSS 规则与 HTML 元素关联起来。 内联样式 **定义方式**：通过元素的style属性直接在 HTML 标签内定义 CSS 样式。"},{"id":"745","title":"[webpack] mode 是做什么用？【热度: 475】","category":"Shopee","labels":["工程化","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/745","page":"q/shopee-745.html","excerpt":"**关键词**：webpack mode 在 webpack 中，mode 属性用来指定当前的构建环境是：development、production 或者是 none。设置 mode 可以使用 webpack 内置的函数，默认值为 production。 mode 属性的主要作用是：根据当前的构建环境，启用 webp"},{"id":"744","title":"V8 里面的 JIT 是什么？【热度: 694】","category":"Shopee","labels":["工程化","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/744","page":"q/shopee-744.html","excerpt":"**关键词**：V8 JIT 在计算机科学中，JIT 是“Just-In-Time”（即时编译）的缩写，它是一种提高代码执行性能的技术。具体来说，在 V8 引擎（Google Chrome 浏览器和 Node.js 的 JavaScript 引擎）中，JIT 编译器在 JavaScript 代码运行时，将其编译成机器语"},{"id":"714","title":"不同标签页或窗口间的 【主动推送消息机制】 的方式有哪些？（不借助服务端）【热度: 401】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/714","page":"q/shopee-714.html","excerpt":"**关键词**：不同页签信息主动推送 在不借助服务器端的帮助下，实现不同标签页或窗口间的主动推送消息机制，可以使用以下客户端技术： 作者备注： 这里要注意一下， 这里讨论的不是跨页签通信，而是**跨页签主动推送信息** 。如果仅仅是跨页签通信， 那么浏览器的本地存储都可以都可以使用了。 所以排除了本地存储类 API 的"},{"id":"653","title":"需要在跨域请求中携带另外一个域名下的 Cookie 该如何操作？【热度: 254】","category":"Shopee","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/653","page":"q/shopee-653.html","excerpt":"**关键词**：跨域 cookie 在跨域请求中携带另外一个域名下的 Cookie，需要通过设置响应头部的Access-Control-Allow-Credentials字段为true，并且请求头部中添加withCredentials字段为true。 在服务端需要设置响应头部的Access-Control-Allow-"},{"id":"644","title":"封装一个请求超时， 发起重试的代码【热度: 789】","category":"Shopee","labels":["Shopee","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/644","page":"q/shopee-644.html","excerpt":"**关键词**：请求重试 看过很多请求超时重试的样例， 很多都是基于 axios interceptors 实现的。 但是有没有牛逼的原生方式实现呢？ 最近在看 fbjs 库里面的代码， 发现里面有一个超时重试的代码， 只有一百多行代码， 封装的极其牛逼。 不过这里的代码是 Flow 类型检测的代码， 而且有一些外部小"},{"id":"639","title":"你认为组件封装的一些基本准则是什么？【热度: 625】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/639","page":"q/shopee-639.html","excerpt":"**关键词**：组件封装原则 组件封装的一些基本准则包括： 单一职责原则：一个组件应该具有单一的功能，并且只负责完成该功能，避免组件过于庞大和复杂。 高内聚低耦合：组件内部的各个部分之间应该紧密相关，组件与其他组件之间应该尽量解耦，减少对外部的依赖。 易用性：组件应该易于使用，提供清晰的接口和文档，使用户能够方便地使用"},{"id":"576","title":"[Vue] 为什么 data 属性是一个函数而不是一个对象？【热度: 448】","category":"Shopee","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/576","page":"q/shopee-576.html","excerpt":"**关键词**：vue data 函数 **实例和组件定义data的区别** vue 实例的时候定义data属性既可以是一个对象，也可以是一个函数 组件中定义data属性，只能是一个函数 如果为组件data直接定义为一个对象 则会得到警告信息 警告说明：返回的data应该是一个函数在每一个组件实例中 **组件data定"},{"id":"571","title":"[Vue] 动态给 data 添加一个新的属性时会发生什么【热度: 164】","category":"Shopee","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/571","page":"q/shopee-571.html","excerpt":"**关键词**：vue更改data属性 **直接添加属性的问题** 我们从一个例子开始 定义一个p标签，通过v-for指令进行遍历 然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行 实例化一个vue实例，定义data属性和methods方法 点击按钮，发现结果不及预期，数据虽然"},{"id":"565","title":"CSS 如何实现文本溢出？【热度: 382】","category":"Shopee","labels":["CSS","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/565","page":"q/shopee-565.html","excerpt":"**关键词**：文本溢出样式 **单行文本溢出** 在CSS中，可以使用text-overflow属性来实现单行文本的溢出省略样式。同时，还需要设置white-space属性为nowrap，使文本不换行，以及overflow属性为hidden，隐藏溢出的文本。 以下是一个示例： 然后，在HTML中，可以将这个类应用到指"},{"id":"555","title":"vue-cli 都做了哪些事儿，有哪些功能？【热度: 386】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/555","page":"q/shopee-555.html","excerpt":"**关键词**：vue-cli 作用、vue-cli 功能 Vue CLI 是一个基于 Vue.js 的命令行工具，用于快速搭建、开发和构建 Vue.js 项目。它提供了一系列的功能来简化 Vue.js 项目的开发和部署流程，包括： 项目脚手架：Vue CLI 可以通过简单的命令行交互方式快速生成一个新的 Vue.js"},{"id":"537","title":"typeof 与 instanceof 的区别【热度: 906】","category":"Shopee","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/537","page":"q/shopee-537.html","excerpt":"**关键词**：typeof 与 instanceof、typeof 作用、instanceof 作用 在JavaScript中，typeof和instanceof是两个用于检查变量类型的操作符，但它们具有不同的用途和区别。 typeof是一个一元操作符，用于确定给定变量的数据类型。它返回一个字符串，表示变量的数据类型"},{"id":"536","title":"http 请求中 GET 和 POST 有什么区别【热度: 505】","category":"Shopee","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/536","page":"q/shopee-536.html","excerpt":"**关键词**：GET 和 POST 区别 | | GET请求 | POST请求 | | --- | --------------------------------------------------------- | -------------------------------------------------"},{"id":"492","title":"[代码实现] 实现管道函数【热度: 540】","category":"Shopee","labels":["Shopee","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/492","page":"q/shopee-492.html","excerpt":"**关键词**：JS 管道函数、JS 管道函数实现 管道函数是一种函数编程的概念，它可以将多个函数串联起来，将前一个函数的输出作为后一个函数的输入。以下是一个简单的实现示例： 在上述示例中，我们首先定义了三个简单的示例函数：addOne、double和square。然后，通过调用pipe函数，将这三个函数串联起来创建了"},{"id":"489","title":"[Vue] 你做过哪些性能优化【热度: 969】","category":"Shopee","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/489","page":"q/shopee-489.html","excerpt":"**关键词**：vue 项目优化、vue 开发优化 1、v-if和v-show 频繁切换时使用v-show，利用其缓存特性 首屏渲染时使用v-if，如果为false则不进行渲染 2、v-for的key 列表变化时，循环时使用唯一不变的key，借助其本地复用策略 列表只进行一次渲染时，key可以采用循环的index 3、"},{"id":"487","title":"typeof null 的输出结果是什么，为什么？【热度: 93】","category":"Shopee","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/487","page":"q/shopee-487.html","excerpt":"**关键词**：typeof null 输出结果 在 JavaScript 中，typeof null 的输出结果是 \"object\"。 这是因为在 JavaScript 中，null 被视为一个特殊的空值对象。尽管 null 实际上不是一个对象，它是一个原始类型的值，但 typeof null 返回 \"object\""},{"id":"486","title":"如何冻结一个 JS 对象【热度: 949】","category":"Shopee","labels":["JavaScript","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/486","page":"q/shopee-486.html","excerpt":"**关键词**：Object.freeze、Object.freeze作用、深度冻结对象 **冻结对象** 要冻结一个 JavaScript 对象，以防止别人更改它，可以使用Object.freeze()方法。Object.freeze()方法会递归地冻结一个对象的所有属性，使其变为只读的，并防止更改、删除或添加新属性"},{"id":"485","title":"script 标签上有那些属性，分别作用是啥？【热度: 744】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/485","page":"q/shopee-485.html","excerpt":"**关键词**：script 标签属性、script 标签属性作用、常用 script 标签属性 在HTML中，<script>标签用于引入或嵌入JavaScript代码。<script>标签可以使用以下属性来调整脚本的行为： **常用属性** src：指定要引入的外部JavaScript文件的URL。例如：<scri"},{"id":"471","title":"webpack 如何配置按需加载的模块【热度: 693】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/471","page":"q/shopee-471.html","excerpt":"**关键词**：webpack 配置按需加载、webpack 按需加载、react lazy 加载 如何配置 webpack 按需加载 要配置webpack项目模块按需加载，你可以使用webpack的代码分割（code splitting）功能和动态导入（dynamic import）语法。 以下是一些配置步骤： 在w"},{"id":"469","title":"如何通过设置失效时间清除本地存储的数据？【热度: 1,085】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/469","page":"q/shopee-469.html","excerpt":"**关键词**：定时清除本地存储 要清除本地存储的数据，可以通过设置失效时间来实现。以下是一种常见的方法： 将数据存储到本地存储中，例如使用localStorage或sessionStorage。 在存储数据时，同时设置一个失效时间。可以将失效时间存储为一个时间戳或特定的日期时间。 在读取数据时，检查当前时间是否超过了"},{"id":"463","title":"[vue] vue2.x 响应式原理是什么【热度: 669】","category":"Shopee","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/463","page":"q/shopee-463.html","excerpt":"**关键词**：vue响应式、Observe、Compile、Watcher Vue.js 的响应式原理主要是通过数据劫持（Object.defineProperty()）实现。当我们在Vue实例中定义了一个 data 属性时，Vue 会对这个属性进行劫持，即在getter和setter时做一些操作。 具体实现流程如下"},{"id":"442","title":"ajax、axios、fetch的区别【热度: 855】","category":"Shopee","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/442","page":"q/shopee-442.html","excerpt":"**关键词**：ajax、axios、fetch、前端网络请求库 Ajax、Axios和Fetch都是用于进行HTTP请求的工具或技术，但它们在实现细节和功能方面有所不同。 Ajax（Asynchronous JavaScript and XML）: Ajax是一种用于在后台与服务器进行异步通信的技术。 Ajax使用X"},{"id":"429","title":"html 中前缀为 data- 开头的元素属性是什么？【热度：903】","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/429","page":"q/shopee-429.html","excerpt":"HTML 中前缀为 data- 开头的元素属性被称为自定义数据属性（Custom Data Attributes）或者数据属性（Data Attributes）。 这些属性的命名以 data- 开头，后面可以跟上任意自定义的名称。这样的属性可以用来存储与元素相关的自定义数据，以便在 JavaScript 或 CSS 中"},{"id":"409","title":"进程和线程的区别是什么？","category":"Shopee","labels":["网络","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/409","page":"q/shopee-409.html","excerpt":"进程（Process）和线程（Thread）是计算机操作系统中的两个核心概念，它们在程序执行和资源管理方面有着不同的特点和作用。下面是它们之间的区别： 定义：进程是程序的一次执行过程，是资源分配的基本单位；线程是进程的一部分，是程序执行的最小单位。 资源拥有：每个进程都拥有独立的内存空间和系统资源，包括文件、设备、网络"},{"id":"395","title":"[vue] vue3 性能提升主要是体现在哪些方面【热度: 324】","category":"Shopee","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/395","page":"q/shopee-395.html","excerpt":"**关键词**：vue3 性能提升、vue3 编译优化、vue3 初始化优化、vue3 Tree-shaking支持、vue3 虚拟DOM优化 Vue 3.0在性能方面进行了多项改进和优化，主要体现在以下几个方面： 响应式系统优化：Vue 3.0使用了基于Proxy的响应式系统，相比Vue 2.x中的Object.de"},{"id":"393","title":"实现一个JS 函数， 解析 url 参数， 返回一个对象","category":"Shopee","labels":["Shopee","滴滴","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/393","page":"q/shopee-393.html","excerpt":"基础版本 下面是一个简单的 JavaScript 函数，用于解析 URL 参数并返回一个包含参数键值对的对象： 这个函数接受一个 URL 字符串作为参数，并返回解析后的参数对象。例如： 这个函数的实现思路是先从 URL 字符串中提取查询字符串部分，然后将查询字符串按照 & 分割成键值对数组。接着遍历键值对数组，将每个键"},{"id":"391","title":"小程序为什么会有两个线程","category":"Shopee","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/391","page":"q/shopee-391.html","excerpt":"小程序之所以有两个线程，是为了实现小程序的高效运行和良好的用户体验。 渲染线程（UI 线程）： 渲染线程负责小程序界面的渲染和响应用户的交互。它使用 WebView 进行页面渲染，包括解析和绘制 DOM、布局、样式计算和渲染等操作。渲染线程是单线程的，所有的界面操作都在这个线程中进行。 逻辑线程（JS 线程）： 逻辑线"},{"id":"1045","title":"canvas 是如何处理复杂事件交互的呢【热度: 120】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/1045","page":"q/top100互联网-1045.html","excerpt":"**关键词**：canvas 事件交互 在 HTML5 的canvas中处理复杂事件交互可以通过以下方法实现： **一、基本原理** 由于canvas只是一个像素绘制区域，本身并不像常规 HTML 元素那样具有内置的事件处理机制。所以需要通过以下方式来处理事件交互： 监听整个文档或包含canvas的容器元素的事件。 根"},{"id":"1013","title":"介绍一下 URLSearchParams API【热度: 10】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/1013","page":"q/top100互联网-1013.html","excerpt":"**关键词**：URLSearchParams API 介绍 URLSearchParams是 JavaScript 中的一个内置 API，用于处理 URL 的查询参数部分。它提供了一系列方法来方便地操作和获取 URL 中的查询参数。 **一、创建URLSearchParams对象** **从现有 URL**： 可以从"},{"id":"989","title":"有哪些前端性能分析工具【热度: 400】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/989","page":"q/top100互联网-989.html","excerpt":"**关键词**：前端性能分析 以下是一些常用的前端性能分析工具： **一、浏览器开发者工具** **Chrome DevTools**： 功能强大，提供了丰富的性能分析选项。 在“Performance”（性能）面板中，可以录制页面的交互过程，分析 CPU 使用率、内存占用、网络请求等，找出性能瓶颈。 “Network"},{"id":"988","title":"[React]在应用中如何排查性能问题【热度: 255】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/988","page":"q/top100互联网-988.html","excerpt":"**关键词**：React 性能排查 在 React 应用中，可以通过以下方法来排查性能问题： **一、使用 Chrome 开发者工具** **性能分析（Performance）**： 打开 Chrome 浏览器，进入开发者工具。选择“Performance”选项卡。 点击“Record”按钮开始录制页面的交互过程。进"},{"id":"921","title":"[Vue] 都是支持响应式， defineModel 和 reactive 有何不同【热度: 344】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/921","page":"q/top100互联网-921.html","excerpt":"**关键词**：defineModel 和 reactive 异同 在 Vue 3 中，defineModel和reactive虽然都与响应式相关，但它们有以下不同之处： **一、功能目的** **reactive**： 主要用于创建响应式对象。它接收一个普通的 JavaScript 对象，并将其转换为响应式对象，使得"},{"id":"920","title":"[Vue] 介绍一下 defineModel【热度: 433】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/920","page":"q/top100互联网-920.html","excerpt":"**关键词**：vue3 双向绑定 defineModel 在 Vue 3 中，defineModel是一个用于简化双向绑定的函数，通常与组合式函数（composition function）一起使用。 **一、主要作用** **自动解包响应式对象**： 当在组合式函数中使用响应式对象时，使用defineModel可以"},{"id":"919","title":"[Vue] 子组件是否能使用 未定义的 props 【热度: 266】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/919","page":"q/top100互联网-919.html","excerpt":"**关键词**：组件定义 props 在 Vue 中，子组件默认情况下不能使用未在 props 选项中明确定义的属性。Vue 的组件系统旨在明确组件之间的接口，其中 props 作为组件公开的属性，必须被明确声明。这样做的目的是为了增强代码的可读性和可维护性，确保组件之间的通信清晰和有序。 但是，有几种方式可以绕过这个"},{"id":"918","title":"[Vue] 子组件定义接受的 props 方式有哪些【热度: 465】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/918","page":"q/top100互联网-918.html","excerpt":"**关键词**：组件定义 props 在 Vue 中，子组件可以通过 props 接收来自父组件的数据。props 是组件的可配置项之一，它允许外部环境传递数据给组件。有几种不同的方式来定义组件的 props，这些方式提供了不同级别的验证和默认值设置。以下是 Vue 中定义 props 的不同方式及其特点： 1. **"},{"id":"917","title":"[Vue] vue 全局注册组件很方便，为何不都是用全局注册【热度: 592】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/917","page":"q/top100互联网-917.html","excerpt":"Vue 的全局注册组件确实提供了便利，特别是在组件需要跨多个视图或组件重复使用时。但是，如果全部或大量使用全局注册，也会带来一些缺点或问题。下面列举了几个不推荐全面使用全局注册组件的原因： 1. **应用启动性能** 全局注册的组件会在应用启动时全部加载和注册，这对于小至中等规模的应用可能不是问题。但对于大型或超大型的"},{"id":"895","title":"http 的 请求和 响 应报文分 别是什么样的","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/895","page":"q/top100互联网-895.html","excerpt":"HTTP（HyperText Transfer Protocol，超文本传输协议）的请求和响应报文都遵循特定的格式。理解这些格式对于开发 Web 应用和 API 非常重要。以下是 HTTP 请求和响应报文的一般结构： HTTP 请求报文 HTTP 请求报文由三个主要部分组成：请求行、请求头部（Headers）、消息主体"},{"id":"894","title":"http的请求和响应报文 有啥区别","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/894","page":"q/top100互联网-894.html","excerpt":"作者备注 可以当做一个科普来看， 单纯的八股， 没有实际价值， 所以不做评分 HTTP 请求和响应报文都遵循类似的结构，但它们服务于通信过程中的不同阶段，并具有一些关键的区别。下面是请求和响应报文之间的主要区别： 结构上的区别 **请求行 vs 状态行**： **请求报文**的第一行是**请求行**，包含了方法（如 G"},{"id":"836","title":"proxy能够监听到对象中的对象的引用吗？【热度: 112】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/836","page":"q/top100互联网-836.html","excerpt":"**关键词**：proxy 监听引用 是的，Proxy 能够监听到对象属性的读取和设置操作，包括对象中嵌套的对象的引用操作。但是，要注意的是，如果你想要监听一个嵌套对象内部的变化（例如，对象的属性或者数组的元素），那么你需要单独为这个嵌套对象也创建一个 Proxy 实例。因为 Proxy 只能直接监听它直接代理的对象的"},{"id":"835","title":"[React] 类组件中，为什么修改状态要使用 setState 而不是用 this.state.xxx = xxx【热度: 414】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/835","page":"q/top100互联网-835.html","excerpt":"**关键词**：react state 问题 在 React 类组件中，状态（state）是组件的局部状态，你可以通过调用 setState 方法来异步更新组件的状态。有几个重要原因解释了为什么在 React 类组件中应该使用 setState 而不是直接修改 this.state： 1. **保证状态的不可变性（Im"},{"id":"819","title":"[React] 为什么要自定义合成事件【热度: 132】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/819","page":"q/top100互联网-819.html","excerpt":"**关键词**：React 合成事件 React 选择自定义合成事件系统主要是为了提供一个统一的事件处理接口，解决浏览器原生事件的兼容性问题，并优化性能。以下是自定义合成事件系统的几个关键原因： **跨浏览器一致性**： 不同的浏览器对事件的实现存在差异，这可能导致在不同浏览器上运行的代码行为不一致。React 的合成"},{"id":"818","title":"[React] useState 的原理是什么，背后怎么执行的【热度: 446】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/818","page":"q/top100互联网-818.html","excerpt":"**关键词**：useState 的原理 useState 是 React 库中的一个 Hook，它允许你在函数组件中添加 React 状态。使用 useState，你可以给组件添加内部状态，并且能够通过调用这个 Hook 来更新状态，从而触发组件的重新渲染。 原理简述 useState 的工作原理基于 React 的"},{"id":"817","title":"[React] 类组件里面 setState 做了哪些事儿【热度: 200】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/817","page":"q/top100互联网-817.html","excerpt":"**关键词**：setState 做了哪些事儿 在 React 的类组件中，setState 方法主要做了以下几件事情： 触发组件的重新渲染：当调用 setState 时，React 会标记该组件为“脏”状态，在下一个渲染周期中重新渲染组件。 合并状态更新：setState 接受一个对象或函数作为参数。如果是对象，它会"},{"id":"816","title":"[webpack] 构建过程中， 是如何将我们 es6 代码 编译为 es5【热度: 420】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/816","page":"q/top100互联网-816.html","excerpt":"**关键词**：es6 编译为 es5 Webpack 本身是一个模块打包器（bundler），它并不直接负责将 ES6 代码编译为 ES5 代码。Webpack 的主要功能是将项目中的所有模块（JavaScript、图片、CSS 等）打包成一个或多个 bundle，以供浏览器加载。然而，Webpack 可以通过加载器"},{"id":"813","title":"[React] useRef 是如何实现的【热度: 299】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/813","page":"q/top100互联网-813.html","excerpt":"**关键词**：useRef 实现 该问题也是非常复杂， 需要深入源码， 可以看下面文章解析： https://juejin.cn/post/7341757372188065792 以下是题库作者对上面文档的一些提炼总结 什么是数据共享层 hooks 如何确定 fiber 对应的 hook 上下文？ hook 是如何存"},{"id":"812","title":"[React] scheduler 调度机制原理【热度: 660】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/812","page":"q/top100互联网-812.html","excerpt":"**关键词**：scheduler 调度机制原理 细节过于复杂， 可以参考一下文档： https://juejin.cn/post/7331135154209308687 后续是题库作者对上述文档的一些重点信息总结： scheduler 概念 时间片与优先级 概念 优先级切分 任务队列 scheduleCallback"},{"id":"811","title":"日志监控：如何还原用户操作流程【热度: 450】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/811","page":"q/top100互联网-811.html","excerpt":"**关键词**：日志监控 - 还原现场、日志监控 - 前端录制用户行为技术方案 需求 一种手段来获取用户某一时段连续的操作行为，也就是录制用户行为，包括整个会话中的每一个点击、滑动、输入等行为，同时支持回放录制的操作行为，完整且真实地重现用户行为以帮助我们回溯或分析某些使用场景。 实现方式 **方案对比** | 对比内"},{"id":"810","title":"axios 请求的底层依赖是什么？【热度: 266】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/810","page":"q/top100互联网-810.html","excerpt":"**关键词**：axios 请求依赖 Axios 的底层依赖会根据运行环境而有所不同： 在浏览器环境中，Axios 通常会优先使用 XMLHttpRequest 对象来发送请求。但它也可以使用 fetch API （如果浏览器支持）。 在 Node.js 环境中，Axios 依赖于 Node.js 的 http 或 h"},{"id":"809","title":"ajax 和 xhr 是什么关系？【热度: 332】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/809","page":"q/top100互联网-809.html","excerpt":"**关键词**：ajax 和 xhr **Ajax** 全称为 Asynchronous JavaScript and XML（异步 JavaScript 和 XML），是一种在不重新加载整个网页的情况下，与服务器进行数据交换并更新部分网页内容的技术方法。 Ajax 主要基于以下几个关键概念和技术： 异步通信：允许网页"},{"id":"802","title":"如何在划词选择的文本上添加右键菜单（划词：鼠标滑动选择一组字符， 对组字符进行操作）【热度: 100】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/802","page":"q/top100互联网-802.html","excerpt":"**关键词**：DOM getSelection 方法 应用场景 主要考察 dom 方法， getSelection 属于很冷门知识， 只会在做过富文本的同学面试过程中可能会问得到。 要在划词选择的文本上添加右键菜单，可以按照以下步骤进行操作： 监听鼠标右键事件 在文档或富文本区域上添加 contextmenu 事件的"},{"id":"801","title":"富文本里面， 是如何做到划词的（鼠标滑动选择一组字符， 对组字符进行操作）？【热度: 100】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/801","page":"q/top100互联网-801.html","excerpt":"**关键词**：DOM getSelection 方法 主要考察 dom 方法， getSelection 属于很冷门知识， 只会在做过富文本的同学面试过程中可能会问得到。 在富文本环境中实现划词（鼠标滑动选择一组字符并对其进行操作）通常涉及以下几个关键步骤和技术： 事件监听 监听鼠标按下、鼠标移动和鼠标松开这三个主要"},{"id":"797","title":"浏览器有同源策略， 但是为何 cdn 请求资源的时候不会有跨域限制【热度: 579】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/797","page":"q/top100互联网-797.html","excerpt":"**关键词**：同源策略、跨域限制 同源策略是啥 浏览器的同源策略（Same-origin policy）是一种重要的安全机制，用于限制不同源的文档或脚本之间的交互操作。 “源”（origin）由三部分组成：协议（protocol）、域名（domain）和端口（port）。如果两个 URL 的协议、域名和端口都完全相同"},{"id":"796","title":"cookie 可以实现不同域共享吗【热度: 533】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/796","page":"q/top100互联网-796.html","excerpt":"**关键词**：cookie 共享 通常，Cookie不能直接在不同域间共享，这源于浏览器同源策略，该策略由协议、域名和端口号共同界定“源”，只有三者完全相同才属同源，Cookie才能在其间共享。但在特定条件和技术手段下，可实现不同域间一定程度的Cookie共享，同时，Cookie也能设置为在同主域下的子域间共享，具体"},{"id":"795","title":"axios 是否可以取消请求【热度: 532】","category":"TOP100互联网","labels":["网络","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/795","page":"q/top100互联网-795.html","excerpt":"**关键词**：取消请求 Axios 可以取消请求。官方文档指出有两种方法可以取消请求，分别是cancelToken和AbortController，示例代码如下： 使用cancelToken的方法一： 使用 cancelToken的方法二： 使用AbortController： 通过文档描述和示例代码，可以总结出以下"},{"id":"794","title":"前端如何实现折叠面板效果？【热度: 113】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/794","page":"q/top100互联网-794.html","excerpt":"**关键词**：transition 过度动画 以下是在您给出的折叠面板示例基础上添加动画效果的版本： **HTML 结构**（与您之前给出的相同） **CSS 样式** **JavaScript 功能** 这样，当点击折叠面板的标题时，内容会以平滑的动画效果展开或收起。您可以根据实际需求调整动画的时长和内容展开的最大"},{"id":"793","title":"dom 里面， 如何判定 a 元素是否是 b 元素的子元素【热度: 400】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/793","page":"q/top100互联网-793.html","excerpt":"**关键词**：dom.contains 方法 在 DOM（文档对象模型）中，要判断元素 a 是否是元素 b 的子元素，您可以使用以下的 JavaScript 代码： 可以这样使用上述函数："},{"id":"792","title":"css 实现打字机效果【热度: 96】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/792","page":"q/top100互联网-792.html","excerpt":"**关键词**：animation 帧动画、animation steps 属性 主要是对 css 动画的一个实际应用考察 以下是一个使用 CSS 实现简单打字机效果的示例代码： 在上述代码中，.typewriter 类的元素用于实现打字机效果。 animation: typing 4s steps(30), blin"},{"id":"779","title":"[React] 循环渲染中 为什么推荐不用 index 做 key【热度: 320】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/779","page":"q/top100互联网-779.html","excerpt":"**关键词**：React 循环渲染问题 在 React 的循环渲染中，不推荐使用数组的index（索引）作为元素的key，主要基于以下几点理由： **列表项顺序的变化**：如果列表项的顺序会发生变化（如排序、增加、删除操作），使用index作为key可能会导致性能问题和组件状态的错误。这是因为 React 依赖key"},{"id":"778","title":"[React] 如何避免使用 context 的时候， 引起整个挂载节点树的重新渲染【热度: 420】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/778","page":"q/top100互联网-778.html","excerpt":"**关键词**：React Context 渲染问题 要避免在 React 开发中使用 context 时引起整个挂载节点树的重新渲染，可以采取以下方法： React Context 数据分割：把提供 context value 的部分提取到单独的组件中，并且仅在该组件中修改 context value。这样，当 co"},{"id":"777","title":"[Webpack] 配置代码太多，达到数千行，这个时候该如何优化配置代码【热度: 186】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/777","page":"q/top100互联网-777.html","excerpt":"**关键词**：webpack 配置代码优化 当 Webpack 配置代码变得冗长和难以管理时，可以采取以下方法来优化配置： **配置文件拆分** 将配置文件分成多个部分，每个文件只负责一部分逻辑。比如基础配置、开发环境配置、生产环境配置等。 **使用环境变量** 通过环境变量来区分不同的配置环境，使用 webpack"},{"id":"776","title":"[Webpack] 你用过哪些可以提高效率的插件？【热度: 179】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/776","page":"q/top100互联网-776.html","excerpt":"**关键词**：webpack 效率提升 webpack-dashboard：可以更友好的展示相关打包信息。 webpack-merge：提取公共配置，减少重复配置代码 speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有"},{"id":"775","title":"[React] 如何针对 react hooks 写单测【热度: 170】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/775","page":"q/top100互联网-775.html","excerpt":"**关键词**：hooks 单测 如果你想对一个独立的 React Hook 函数进行单元测试，不涉及对它在组件中使用的测试，那么你可以使用由react-hooks-testing-library提供的工具来完成。这个库允许你在一个隔离的环境中渲染和测试 hook 函数，而不必担心组件的其他部分。 首先，你需要安装@t"},{"id":"774","title":"[React] useEffect 依赖为空数组与 componentDidMount 区别【热度: 366】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/774","page":"q/top100互联网-774.html","excerpt":"**关键词**：useEffect 与 componentDidMount 区别 useEffect 是 React 函数组件的生命周期钩子，它是替代类组件中 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法的统一方式。 当你给 use"},{"id":"767","title":"[Webpack] 如何提取复用代码给多个 entry 使用？【热度: 292】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/767","page":"q/top100互联网-767.html","excerpt":"**关键词**：代码复用 在 Webpack 中提取源码里被多个入口点复用的代码，例如一个 utils 文件，可以通过配置 optimization.splitChunks 来实现。Webpack 会将这些频繁复用的模块提取出来，打包到一个独立的 chunk 中，使得浏览器可以单独缓存这部分代码，并在多个页面间共享使用"},{"id":"766","title":"[Webpack] 如何将一些通用的依赖打包成一个独立的 bundle【热度: 643】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/766","page":"q/top100互联网-766.html","excerpt":"**关键词**：依赖打包 在 Webpack 中，将一些通用的依赖，如 React、React DOM、React Router 等库和框架，打包成一个独立的 bundle，通常是为了长期缓存和减少每次部署更新的下载量。这可以通过 \"代码分割\" (code splitting) 和 \"优化\" (optimization"},{"id":"765","title":"[Webpack] output 配置里面， chunkFilename 和 filename 区别是什么？【热度: 210】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/765","page":"q/top100互联网-765.html","excerpt":"**关键词**：chunkFilename 和 filename 在 Webpack 中的 output 配置对象中，filename 和 chunkFilename 是用来指定输出文件的命名方式的关键属性。它们之间的区别主要涉及到最终生成的 JavaScript 文件的类型。 **filename**: filena"},{"id":"764","title":"[Webpack] 多入口打包共享模块【热度: 337】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/764","page":"q/top100互联网-764.html","excerpt":"**关键词**：webpack 多入口共享模块 默认情况下，每个入口 chunk 保存了全部其用的模块(modules)。使用 dependOn 选项你可以与另一个入口 chunk 共享模块: app 这个 chunk 就不会包含 react-vendors 拥有的模块了. dependOn 选项的也可以为字符串数组："},{"id":"763","title":"[Webpack] 如何使用 ts 来编写配置文件？【热度: 251】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/763","page":"q/top100互联网-763.html","excerpt":"**关键词**：webpack ts 编写配置文件 要使用 $1 来编写 webpack 配置，你需要先安装必要的依赖，比如 Typescript 以及其相应的类型声明，类型声明可以从 $1 项目中获取，依赖安装如下所示： 完成依赖安装后便可以开始编写配置文件，示例如下： **webpack.config.ts** 该"},{"id":"762","title":"[Webpack] 内部执行原理【热度: 668】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/762","page":"q/top100互联网-762.html","excerpt":"**关键词**：webpack 执行原理 这部分可以直接转官网，官网讲得非常好： https://www.webpackjs.com/concepts/under-the-hood/"},{"id":"761","title":"[Webpack] 为何不支持 CMD 模块化【热度: 255】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/761","page":"q/top100互联网-761.html","excerpt":"**关键词**：webpack 模块化支持 作者总结一下原因： CMD 是国内产品， webpack 是国外产品， 而且 CMD 还没有火起来的时候， 就已经被 ESM 替代了 CMD 是更加懒惰，是依赖就近，延迟执行。也就是说，在模块中需要用到依赖时，才去引入依赖。这和 Webpack 的理念以及模块收集和打包机制不"},{"id":"760","title":"[Webpack] 支持哪些模块化加载？【热度: 154】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/760","page":"q/top100互联网-760.html","excerpt":"**关键词**：webpack 模块化支持 Webpack 支持以下几种模块化标准： **ESM (ECMAScript Modules)**: 这是 JavaScript ES6 中引入的官方标准模块系统。使用 import 和 export 语句来导入和导出模块。 **CommonJS**: 主要用于 Node.j"},{"id":"759","title":"前端如何做 页面主题色切换【热度: 538】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/759","page":"q/top100互联网-759.html","excerpt":"**关键词**：主题色切换 页面主题色切换通常涉及到修改网页中的颜色方案，以提供不同的视觉体验，例如从明亮模式切换到暗黑模式。实现这一功能，可以通过配合使用 CSS、JavaScript 和本地存储来进行。以下是实施页面主题色切换的几种方法： 使用 CSS 自定义属性 定义一套主题变量： 应用自定义属性到 CSS 规则"},{"id":"758","title":"前端视角 - 如何保证系统稳定性【热度: 566】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/758","page":"q/top100互联网-758.html","excerpt":"**关键词**：稳定性 前端视角来做稳定性， 本是一个开放性话题，这里没有统一的解法， 作者在此提供几个思路和反向： 静态资源多备份（需要有备份） 首屏请求缓存 请求异常报警 页面崩溃报警 E2E 定时全量跑用例"},{"id":"757","title":"如何统计长任务时间、长任务执行次数【热度: 489】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/757","page":"q/top100互联网-757.html","excerpt":"**关键词**：长任务统计 在 JavaScript 中，可以使用 Performance API 中的 PerformanceObserver 来监视和统计长任务（Long Task）。长任务是指那些执行时间超过 50 毫秒的任务，这些任务可能会阻塞主线程，影响页面的交互性和流畅性。 使用 PerformanceOb"},{"id":"756","title":"CSS 属性计算函数 Calc 介绍一下【热度: 228】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/756","page":"q/top100互联网-756.html","excerpt":"**关键词**：属性计算函数 calc CSS 属性计算函数 calc() 是用来进行动态的尺寸计算以及数值混合运算的一种函数。它增强了纯 CSS 的灵活性，允许你在属性值的设置中直接执行基础的加（+）、减（-）、乘（*）、除（/）运算。 使用方式 calc() 函数用于各种 CSS 属性，如 width、height"},{"id":"755","title":"less 函数如何使用？【热度: 229】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/755","page":"q/top100互联网-755.html","excerpt":"**关键词**：less 函数 LESS 是一种基于 JavaScript 的 CSS 预处理器，它扩展了 CSS 的功能，提供了变量、嵌套、混合（Mixins）、函数等功能。LESS 中的函数允许你执行计算、转换和操纵值的操作，使得你的样式表更加灵活和动态。 使用 LESS 函数的基本步骤： **定义函数**：你可以"},{"id":"754","title":"介绍一下 CSS 变量怎么声明和使用？【热度: 688】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/754","page":"q/top100互联网-754.html","excerpt":"**关键词**：CSS 变量 CSS 自定义属性，又称 CSS 变量，是一种在 CSS 样式表中声明可以使用任意值的方法，这样的值在同一份 CSS 代码中可以多次引用并调用来替代特定的内容。使用 CSS 变量可以提高样式表的可维护性和灵活性。以下是如何声明和使用 CSS 变量的步骤： 声明 CSS 变量 CSS 变量的"},{"id":"753","title":"[React] React 19 有哪些新特性？【热度: 879】","category":"TOP100互联网","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/753","page":"q/top100互联网-753.html","excerpt":"**关键词**：React 19 新特性 更多详细信息可以看下面这个文章： https://juejin.cn/post/7362057701792923684 作者总结上文的重点信息内容 React 19 的新功能 新型 hook：useActionState React DOM：<form> Action Reac"},{"id":"752","title":"webpack 的主要配置项有哪些【热度: 766】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/752","page":"q/top100互联网-752.html","excerpt":"**关键词**：webpack 主要配置项 Webpack 是一个现代 JavaScript 应用程序的静态模块打包器。配置文件名通常为 webpack.config.js，它提供了一种配置 Webpack 的方式。下面是一些主要的 Webpack 配置选项： **entry**: 入口起点(entry point)指"},{"id":"751","title":"CSS 在2023 迎来重大更新， 更新内容是什么【热度: 548】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/751","page":"q/top100互联网-751.html","excerpt":"**关键词**：CSS 2023 年重大更新 新特性非常多，总结在下面 详情请看文档：https://juejin.cn/post/7320288231111016498 架构基础 级联层 嵌套 作用域 选择器 :is() 和 :where() 选择器 :has() 复杂的第 n-. 选择 CSS 三角函数 子网格 s"},{"id":"750","title":"[webpack] optimize 配置中， 分割代码配置 splitChunks 怎么使用【热度: 546】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/750","page":"q/top100互联网-750.html","excerpt":"**关键词**：webpack 分割代码 在 webpack 中，splitChunks选项是optimization对象的一个属性，可以用来定义如何分割代码块。默认情况下，webpack 会将所有来自node_modules的模块分割到一个叫做vendors的 chunk 中，并且将共享或来自异步请求的模块分割成不同"},{"id":"749","title":"[webpack] optimize 配置有哪些作用【热度: 280】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/749","page":"q/top100互联网-749.html","excerpt":"**关键词**：webpack optimize Webpack 的 optimize 选项是在指定 Webpack 配置对象时，用于配置优化选项的一个属性。该属性下包含了一系列用于调整构建输出质量和性能的设置。这里是一些 optimize 属性中可能包含的选项： **splitChunks**：这用于代码分割，可以将"},{"id":"716","title":"对象深拷贝的原理和代码实现【热度: 892】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/716","page":"q/top100互联网-716.html","excerpt":"**关键词**：对象什拷贝原理、避免循环引用和栈溢出 在 JavaScript 中，对象深拷贝指的是创建一个对象的副本，使得这个副本与原始对象不共享任何一个引用。这意味着，如果你修改了副本的属性，原始对象不会受到任何影响，反之亦然。 原理 在实现深拷贝时，有几个关键的概念需要理解： **值类型与引用类型**：值类型（如"},{"id":"715","title":"普通数据类型存储在哪里？堆还是栈","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/715","page":"q/top100互联网-715.html","excerpt":"作者备注 这个问题没有任何价值， 不做热度评分， 当做科普吧。 在 JavaScript 中，普通数据类型的存储位置通常取决于它们的使用方式和上下文。以下是一些具体情况： **栈（Stack）**：当涉及到基本数据类型时（如数字、字符串、布尔值、null、undefined、和符号(Symbol)），它们通常存储在栈上"},{"id":"713","title":"[css] 如何设置渐变色？【热度: 746】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/713","page":"q/top100互联网-713.html","excerpt":"**关键词**：设置渐变色 在 CSS 中，设置渐变色可以使用background属性和相应的渐变函数。CSS 提供两种类型的渐变：线性渐变（linear-gradient）和径向渐变（radial-gradient）。以下是如何分别设置这两种渐变色的示例。 线性渐变（Linear Gradient） 线性渐变是从一个"},{"id":"712","title":"html的行内元素和块级元素的区别【热度: 796】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/712","page":"q/top100互联网-712.html","excerpt":"**关键词**：行内元素、块级元素 HTML 中的行内元素（Inline elements）和块级元素（Block-level elements）在布局行为、外观以及如何参与文档流方面有所不同。以下是它们的主要区别： | 特性 | 块级元素(Block-level elements) | 行内元素(Inline ele"},{"id":"711","title":"[React] react-router 和 原生路由区别【热度: 434】","category":"TOP100互联网","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/711","page":"q/top100互联网-711.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 React Router 和浏览器原生 history API 在路由管理上主要有以下几个区别： **抽象级别**: **React Router** 提供了更高层次的抽象，如 <Router>、<Route>、和 <Link> 等组件，这些都是专门为"},{"id":"710","title":"[React] 在 react 项目开发过程中， 是否可以不用 react-router， 使用浏览器原生 history 路由来组织页面路由？【热度: 632】","category":"TOP100互联网","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/710","page":"q/top100互联网-710.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 作者备注 此问题实际上是在问：原生 路由 history api 和 react-router 的差距是啥， 或者说 react-router 做了啥 在 React 项目中，你完全可以不使用 react-router 而是使用浏览器原生的 histo"},{"id":"708","title":"介绍一下 scrollIntoView api【热度: 286】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/708","page":"q/top100互联网-708.html","excerpt":"**关键词**：scrollIntoView api scrollIntoView 是一个 Web API，允许网页开发者控制元素如何被滚动到浏览器的可视区域。这个方法可以对任何 Element 使用，以改变窗口的滚动位置，以便最终元素位于屏幕可见范围内。它对于某些需要用户立即看到的表单错误、警告，或者在执行完某些操作"},{"id":"704","title":"如何一次性渲染十万条数据还能保证页面不卡顿【热度: 426】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/704","page":"q/top100互联网-704.html","excerpt":"原理其实就是 通过 requestAnimationFrame 实现分块儿加载。 requestAnimationFrame + fragment（时间分片） 既然定时器的执行时间和浏览器的刷新率不一致，那么我就可以用requestAnimationFrame来解决 requestAnimationFrame也是个定时"},{"id":"703","title":"[webpack] 打包时 hash 码是如何生成的【热度: 167】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/703","page":"q/top100互联网-703.html","excerpt":"**关键词**：webpack hash 码的生成 Webpack 在打包过程中生成 hash 码主要用于缓存和版本管理。主要有三种类型的 hash 码： hash：是和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改。这意味着任何一个文件的改动都会影响到整体的 hash 值。 chunkh"},{"id":"702","title":"如何从 0 到 1 搭建前端基建【热度: 404】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/702","page":"q/top100互联网-702.html","excerpt":"**关键词**：前端基建 如何从 0 到 1 搭建前端基建 有一个非常经典的文章， 直接参考即可： $1 这里简单总结一下文章里面的要点 1.什么是基建？ 2.为什么要做前端基建？ 业务复用； 提升研发效率； 规范研发流程； 团队技术提升； 团队的技术影响力； 开源建设； 3.前端基建如何推动落地？ 要合适的同学（资源"},{"id":"697","title":"JS 的加载会阻塞浏览器渲染吗？【热度: 243】","category":"TOP100互联网","labels":["浏览器","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/697","page":"q/top100互联网-697.html","excerpt":"**关键词**：浏览器渲染阻塞、JS 阻塞浏览器渲染 JavaScript 的加载、解析和执行默认情况下会阻塞浏览器的渲染过程。这是因为浏览器渲染引擎和 JavaScript 引擎是单线程的，并且二者共享同一个线程。JavaScript 在执行时会阻止 DOM 构建，因为 JavaScript 可能会修改 DOM 结构"},{"id":"694","title":"TS 中 any 和 unknow 的区别【热度: 412】","category":"TOP100互联网","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/694","page":"q/top100互联网-694.html","excerpt":"在 TypeScript 中，any和unknown都代表可以赋予任何类型的值，但它们在使用上有明显的不同。 any 类型 **最不安全的类型**：any类型是 TypeScript 类型系统的逃逸舱口，使用any可以让任何表达式绕过类型检查，转而采用 JavaScript 动态类型的行为。 **类型放弃**：当你把一"},{"id":"693","title":"介绍一下 TS 中的泛型【热度: 118】","category":"TOP100互联网","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/693","page":"q/top100互联网-693.html","excerpt":"**关键词**：TS 泛型 TypeScript 的泛型是一种工具，它能够使代码更加灵活，能够适配多种类型而非单一的类型。泛型可以创建可重用的组件，这些组件可以支持多种类型的数据，而不失去类型检查时的安全性。 泛型的基本概念 在 TypeScript 中, 泛型使用一个类型变量，常见的类型变量有 T,U,V 等。通过类"},{"id":"692","title":"在Babel里，stage0、stage1、stage2 和 stage3 分别代表什么含义？","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/692","page":"q/top100互联网-692.html","excerpt":"无意中看到别人一个面试问题， 个人感觉问这个问题的面试官， 不是蠢就是坏。 没有任何面试价值， 无法考察候选人水平。 仅仅作为科普类型参考 - 热度为 0 Babel 是一个流行的 JavaScript 编译器，它允许开发者使用新的语言特性，然后将它们编译成可以在当前和低版本的浏览器或环境中运行的代码。 在 Babel"},{"id":"691","title":"Webpack 项目中通过 script 标签引入资源，在项目中如何处理?【热度: 100】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/691","page":"q/top100互联网-691.html","excerpt":"也是作者无意中看到的一个有意思的问题。 虽然有意思， 但是没有任何价值， 如果说在项目中遇到过的， 而且处理过的同学， 肯定知道怎么回答。 但是压根没有碰到过得， 就算是你工作十年的老油条也是干望着。 所有没有任何面试价值。 故此， 可以当做科普来看看就行。 在使用 Webpack 打包的项目中，通常资源（如 Java"},{"id":"690","title":"ES6 中的 Map 对象该如何遍历【热度: 411】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/690","page":"q/top100互联网-690.html","excerpt":"Map 遍历 在 JavaScript 中，Map对象当然可以被遍历。Map 对象持有键值对，任何值(对象或者原始值) 都可以作为一个键或一个值。你可以使用 Map 对象的几种方法遍历其中的键值对。 以下是几种遍历 Map 对象的方法： **使用 forEach() 方法**： Map 对象有一个 forEach 方法"},{"id":"689","title":"ES6 中的 Set 对象该如何遍历【热度: 410】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/689","page":"q/top100互联网-689.html","excerpt":"Set 遍历 在 JavaScript 中，Set 对象表示值的集合，在这个集合中每个值只出现一次。Set 对象是可迭代的，因此你可以使用多种方法来遍历它： **for...of 循环**: 可以使用 for...of 循环来遍历 Set。 **forEach 方法**: Set 对象有一个 forEach 方法，就像"},{"id":"688","title":"JS 严格模式为什么会禁用 with 语句？【热度: 210】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/688","page":"q/top100互联网-688.html","excerpt":"作者备注： 实话实说， 这个问题真的很冷门。 如果有面试官问到这个问题了，感觉就是坏。 但是作为一个知识点儿， 还是有一丢丢意思。 所以顺手就记录下来了。 在 JavaScript 中，严格模式禁用了 with 语句，主要是出于以下三个原因： 性能问题：使用 with 语句会为 JavaScript 解释器带来优化难题"},{"id":"682","title":"CSS 属性值计算 - calc【热度: 320】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/682","page":"q/top100互联网-682.html","excerpt":"是的，CSS 支持计算值，这可以通过 calc() 函数实现。calc() 允许你进行数学运算，计算 CSS 属性值。这个功能非常有力，因为它可以混合使用不同的单位，并且可以用在几乎任何需要数值的地方。 以下是 calc() 函数的一些应用示例： **基本运算**：可以执行加 (+)、减 (-)、乘 (*) 和除 (/"},{"id":"681","title":"CSS 中的 display 属性有哪些值？【热度: 593】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/681","page":"q/top100互联网-681.html","excerpt":"CSS 中的display属性是一个非常重要的属性，它用于设置一个元素的显示类型。这个属性决定了元素是如何显示以及与其他元素如何交互。以下是一些常见的display属性值及其含义： none：元素不会被显示。 block：元素显示为块级元素，此类元素会新起一行。 inline：元素不会新起一行，其宽度只占据它的内容宽度"},{"id":"680","title":"HTTP是一个无状态的协议，那么Web应用要怎么保持用户的登录态呢？【热度: 1,092】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/680","page":"q/top100互联网-680.html","excerpt":"**关键词**：登录状态问题 涉及到的几个知识点: cookie，session，token(json web token,jwt)的区别 node 中 jwt 的应用 直接参考文档即可： https://juejin.cn/post/7356788983483842587"},{"id":"672","title":"JS 执行 100 万个任务， 如何保证浏览器不卡顿？【热度: 806】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/672","page":"q/top100互联网-672.html","excerpt":"**关键词**：大批量执行任务不卡顿 **Web Workers** 要确保浏览器在执行100万个任务时不会卡顿，你可以考虑使用Web Workers来将这些任务从主线程中分离出来。Web Workers允许在后台线程中运行脚本，从而避免阻塞主线程，保持页面的响应性。 以下是一个使用Web Workers的简单示例： "},{"id":"671","title":"grpc 和 protobuf 是什么关系？【热度: 320】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/671","page":"q/top100互联网-671.html","excerpt":"gRPC（gRPC Remote Procedure Call）和 Protocol Buffers（protobuf）有密切的关系，可以理解为它们之间是一种上下游的关系： **Protocol Buffers（protobuf）：** 这是一种由 Google 设计的数据序列化格式，用于结构化数据的序列化和反序列化。"},{"id":"669","title":"常见网络协议有哪些【热度: 724】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/669","page":"q/top100互联网-669.html","excerpt":"**关键词**：网络协议 | 协议 | 层次 | 说明 | | ------------- | ------- | ----------------------------------------------------- | | HTTP/HTTPS | 应用层 | 用于在 Web 浏览器和 Web 服务器之间传输超"},{"id":"668","title":"权限管理模型相关概念【热度: 670】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/668","page":"q/top100互联网-668.html","excerpt":"**关键词**：权限管理模型 常见的权限管理模型 **DAC (Discretionary Access Control):** 用户对资源有自主权，资源的所有者可以自由地授予或撤销其他用户的访问权限。 **MAC (Mandatory Access Control):** 系统管理员定义了一组强制性的规则，控制用户对"},{"id":"665","title":"TypeScript 内置的类型方法和工具类型【热度: 492】","category":"TOP100互联网","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/665","page":"q/top100互联网-665.html","excerpt":"**关键词**：ts 内置类型方法、ts 内置工具类型 TypeScript 提供了许多内置的类型方法和工具类型，用于处理和操作类型。以下是其中一些常用的内置类型方法： 分类 **Utility Types（工具类型）**： **Partial\\<T>**: 将类型 T 的所有属性变为可选。 **Required\\<T"},{"id":"664","title":"递归和尾递归是什么概念?【热度: 649】","category":"TOP100互联网","labels":["JavaScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/664","page":"q/top100互联网-664.html","excerpt":"**关键词**：递归和尾递归 递归和尾递归都是指在函数内部调用自身的方式，但它们有一些关键的区别。 **概念** 递归是一种函数调用自身的方式。在递归中，函数会不断地调用自身，直到满足某个终止条件才停止递归。递归通常使用在解决可以通过重复拆分为更小的子问题来解决的问题上。但是，递归可能会导致函数调用的层级过深，消耗大量"},{"id":"663","title":"如何禁止别人调试自己的前端页面代码?【热度: 347】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/663","page":"q/top100互联网-663.html","excerpt":"**关键词**：禁止别人调试自己的前端代码 **无限 debugger** 前端页面防止调试的方法主要是通过不断 debugger 来疯狂输出断点，因为 debugger 在控制台被打开的时候就会执行 由于程序被 debugger 阻止，所以无法进行断点调试，所以网页的请求也是看不到的 基础代码如下： **无限 deb"},{"id":"661","title":"web 系统里面， 如何对图片进行优化？【热度: 789】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/661","page":"q/top100互联网-661.html","excerpt":"**关键词**：图片优化 图片作为网页和移动应用中不可或缺的元素之一，对于用户体验和网站性能都有着重要的影响。 加载速度是用户体验的关键因素之一，而大尺寸的图片会增加网页加载时间，导致用户等待时间过长，从而影响用户的满意度和留存率。通过优化图片，我们可以显著减少页面加载时间，提供更快速流畅的使用体验。 图片优化是提升用"},{"id":"660","title":"请求 Header 的 Content-Type 常见的有哪几种?【热度: 617】","category":"TOP100互联网","labels":["网络","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/660","page":"q/top100互联网-660.html","excerpt":"**关键词**：请求 header Content-Type、header Content-Type 参数类型 **常见的请求Content-Type有以下几种**： application/x-www-form-urlencoded：用于URL编码的表单数据，数据以键值对的形式发送。 multipart/form-d"},{"id":"659","title":"OAuth2.0 是什么登录方式【热度: 210】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/659","page":"q/top100互联网-659.html","excerpt":"**关键词**：OAuth2.0 登录实现、OAuth2.0 鉴权 OAuth2.0并不是一种特定的登录方式，而是一种授权框架，用于授权第三方应用访问用户的资源。它被广泛应用于身份验证和授权的场景中。 OAuth2.0通过引入授权服务器、资源服务器和客户端等角色，实现了用户授权和资源访问的分离。具体流程如下： 用户向客"},{"id":"658","title":"单点登录是如何实现的？【热度: 647】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/658","page":"q/top100互联网-658.html","excerpt":"**关键词**：单点登录实现、单点登录流程 单点登录 单点登录：Single Sign On，简称SSO。用户只要登录一次，就可以访问所有相关信任应用的资源。企业里面用的会比较多，有很多内网平台，但是只要在一个系统登录就可以。 实现方案 单一域名：可以把 cookie 种在根域名下实现单点登录 多域名：常用 CAS来解"},{"id":"656","title":"常见的登录鉴权方式有哪些？【热度: 557】","category":"TOP100互联网","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/656","page":"q/top100互联网-656.html","excerpt":"**关键词**：登录鉴权方式 前端登录鉴权的方式主要有以下几种： 基于Session Cookie的鉴权： cookie: 用户在登录成功后，服务器会生成一个包含用户信息的Cookie，并返回给前端。前端在后续的请求中会自动携带这个Cookie，在服务器端进行验证和识别用户身份。 Session: 用户登录成功后，服务"},{"id":"655","title":"[webpack] webpack-dev-server 为何不适用于线上环境？【热度: 88】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/655","page":"q/top100互联网-655.html","excerpt":"**关键词**：webpack-dev-server 作用 webpack-dev-server并不适用于线上环境的原因有以下几点： 性能问题：webpack-dev-server是一个开发服务器，它将编译后的文件保存在内存中，并提供给浏览器访问。这种方式在开发阶段可以提供快速的编译和热模块替换，但在线上环境中，内存中"},{"id":"651","title":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？【热度: 129】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/651","page":"q/top100互联网-651.html","excerpt":"**关键词**：esbuild 和 rollup 区别 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们在 Vite 中担负着不同的角色和任务。 esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代"},{"id":"650","title":"vite 编译器有啥特点？【热度: 237】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/650","page":"q/top100互联网-650.html","excerpt":"**关键词**：vite 编译器特点 Vite 是一个基于现代浏览器原生 ES 模块导入功能的开发工具和构建系统。与传统的打包工具相比，Vite 具有以下几个特点： 快速冷启动：Vite 采用了一种新的开发服务器，利用浏览器原生的 ES 模块导入功能，无需提前构建和打包，可以实现快速的冷启动，并在浏览器中按需编译和加载"},{"id":"649","title":"vite 编译器的组成部分【热度: 335】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/649","page":"q/top100互联网-649.html","excerpt":"**关键词**：vite 编译器组成部分 Vite 编译器的主要组成部分包括： esbuild：一个快速的 JavaScript 打包器，用于在开发阶段进行实时编译。esbuild 提供了快速的冷启动和热模块替换功能，能够极大地加快开发环境的构建速度。 Rollup：一个强大的 JavaScript 模块打包器，在生产"},{"id":"648","title":"vite 涉及到了哪些底层原理？【热度: 510】","category":"TOP100互联网","labels":["工程化","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/648","page":"q/top100互联网-648.html","excerpt":"**关键词**：vite 原理 Vite 涉及到以下几个底层原理： ES 模块：Vite 使用了 ES 模块来管理和加载模块。ES 模块是 JavaScript 的标准模块系统，相比于传统的 CommonJS 或 AMD，ES 模块具有更好的静态分析能力和更高的性能。Vite 通过使用浏览器原生的 ES 模块加载器，可"},{"id":"646","title":"css加载会造成阻塞吗【热度: 373】","category":"TOP100互联网","labels":["CSS","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/646","page":"q/top100互联网-646.html","excerpt":"**关键词**：css 加载阻塞渲染 css加载会造成阻塞吗？ js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？ 为了完成本次测试，先来科普一下，如何利用chrome来设置下载速度 打开chrome控制台(按下F12),可以看到下图，重点在我画红圈的地方 点击我画红圈的地方(No thr"},{"id":"1135","title":"TypeScript 中，ReturnType 的作用和用法","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/1135","page":"q/typescript-1135.html","excerpt":"**关键词**：ts RetrunType 在 TypeScript 中，ReturnType 是一个**内置的工具类型**，用于**提取函数的返回值类型**。它可以自动推断并返回函数的返回值类型，无需手动手动编写重复的类型定义，是处理函数类型时非常实用的工具。 **作用** 从给定的函数类型中**提取其返回值的类型*"},{"id":"1134","title":"对比一下 ts 和 jsdoc【热度: 126】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/1134","page":"q/typescript-1134.html","excerpt":"**关键词**：ts 对比 jsdoc TypeScript（TS）和 JSDoc 都是用于增强 JavaScript 代码类型安全性的工具，但它们的实现方式和适用场景有显著差异。以下是两者的对比分析及优劣总结： TypeScript 与 JSDoc 对比表 | **维度** | **TypeScript（TS）** "},{"id":"1133","title":"ts 有哪些常用的关键词【热度: 178】","category":"TypeScript","labels":["TypeScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1133","page":"q/typescript-1133.html","excerpt":"**关键词**：ts 关键词 作者备注 这个问题主要是对 ts 类型熟悉程度的考察， 比直接问 number、string 等基础类型有意义。 TypeScript 在 JavaScript 基础上扩展了许多用于类型定义和类型控制的关键字，这些关键字是构建 TypeScript 类型系统的核心。以下是常用的关键词分类及"},{"id":"1132","title":"ts 里面 infer 是什么关键词， 怎么用【热度: 975】","category":"TypeScript","labels":["TypeScript","美团"],"url":"https://github.com/pro-collection/interview-question/issues/1132","page":"q/typescript-1132.html","excerpt":"**关键词**：ts infer 在 TypeScript 中，infer 是一个用于**类型推断**的关键字，通常与条件类型（Conditional types）配合使用，用于**从泛型类型中提取或推断出某个具体类型**。它的核心作用是“让 TypeScript 自动推导出我们需要的类型”，而无需需手动指定。 基本语"},{"id":"874","title":"如何开启 ts 类型强校验，ts 类型错误 webpack 直接编译失败【热度: 232】","category":"TypeScript","labels":["TypeScript","小米"],"url":"https://github.com/pro-collection/interview-question/issues/874","page":"q/typescript-874.html","excerpt":"**关键词**：ts 类型强校验 要开启 TypeScript 的类型强校验，并使得 Webpack 在遇到类型错误时编译失败，可以通过以下步骤实现： 1. 开启 TS 严格模式 首先，在tsconfig.json中启用严格模式。这是通过设置\"strict\": true来实现的，这个选项会启用一系列严格的类型检查，帮助"},{"id":"873","title":"tsconfig.json 中有哪些重用的配置项【热度: 289】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/873","page":"q/typescript-873.html","excerpt":"**关键词**：TS 配置项 tsconfig.json是 TypeScript 项目的配置文件，它指定了用于编译该项目的根文件及编译器选项。以下是一些重要的配置项和它们的作用： compilerOptions 这部分包含了一系列用来告诉 TypeScript 编译器如何编译代码的标志。 **target**: 设置编"},{"id":"872","title":"JS 项目逐步迁移到 TS 项目，该如何做【热度: 870】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/872","page":"q/typescript-872.html","excerpt":"**关键词**：TS 项目迁移 在 JavaScript 项目迁移到 TypeScript 的过程中确实会出现大量 JS 和 TS 文件共存的情况。要配置项目以使它们兼容并顺利运行，你需要进行以下设置： 1. 初始化 TypeScript 配置 首先，创建tsconfig.json文件来配置 TypeScript 编译"},{"id":"871","title":"TypeScript 中 any、never、unknown、null & undefined 和 void 有什么区别【热度: 334】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/871","page":"q/typescript-871.html","excerpt":"**关键词**：TS 类型 在 TypeScript 中，any、never、unknown、null & undefined 以及 void 都是类型系统的一部分，各自具有不同的用途和含义，下面是它们的主要区别： any **含义**：any 类型表示任何 JavaScript 值都可以赋值给它。使用 any 类型，"},{"id":"845","title":"介绍一下 TypeScript 类型兼容——逆变、协变、双向协变和不变 这四个概念【热度: 30】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/845","page":"q/typescript-845.html","excerpt":"**关键词**：TS 类型兼容 TypeScript 中的类型系统允许类型之间存在不同的兼容性关系，这在处理复杂的类型结构时非常重要，尤其是涉及到函数类型和类结构的相互作用。以下是对逆变、协变、双向协变和不变这四个概念的解释： 协变（Covariance） **定义**：如果 A 类型是 B 类型的子类型，则由 A 构"},{"id":"729","title":"tsconfig 配置中 types 和 typeRoots 作用是什么， 有什么区别？【热度: 378】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/729","page":"q/typescript-729.html","excerpt":"**关键词**：ts 类型配置 作者备注 这个问题很冷门， 没有价值， 当做科普即可 在 TypeScript 的 tsconfig.json 配置文件中，types 和 typeRoots 是两个与类型声明相关的选项，它们用于控制 TypeScript 编译器如何处理类型声明文件。这两个选项的主要区别在于它们控制的范"},{"id":"728","title":"ts 项目中，如何使用 node_modules 里面定义的全局类型包到自己项目 src 下面使用？【热度: 377】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/728","page":"q/typescript-728.html","excerpt":"**关键词**：ts 类型配置 **关键点在 types 属性配置** 在 TypeScript 项目中导入 node_modules 中定义的全局包，并在你的 src 目录下使用它，通常遵循以下步骤： 安装包： 使用包管理器如 npm 或 yarn 来安装你需要的全局包。 类型声明： 确保该全局包具有类型声明。如果该"},{"id":"699","title":"你在开发过程中， 使用过哪些 TS 的特性或者能力？【热度: 670】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/699","page":"q/typescript-699.html","excerpt":"**关键词**：TS 特性和能力 这个为何被作者列为了高阶范围的问题 原因如下：大多数纯写业务的同学， 可能就用到了 interface 和 type 最多加上 enum 和 泛型； TS 很多牛掰的特性， 是伴随做复杂的工具库， 或者处理复杂业务场景来的。 这里直接上干货： **Utility Types（工具类型）"},{"id":"698","title":"开发过程中为什么会选择使用 ts , 相比于 JS 开发， 有哪些优点？【热度: 318】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/698","page":"q/typescript-698.html","excerpt":"**关键词**：TS 开发优势 使用 TypeScript（简称 TS）而不是纯 JavaScript（JS）进行开发，是因为 TypeScript 提供了一些特性和优势，这些可以帮助开发者提高代码质量、可维护性以及开发效率。以下是使用 TypeScript 的一些主要优点： **静态类型检查**： TypeScrip"},{"id":"694","title":"TS 中 any 和 unknow 的区别【热度: 412】","category":"TypeScript","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/694","page":"q/typescript-694.html","excerpt":"在 TypeScript 中，any和unknown都代表可以赋予任何类型的值，但它们在使用上有明显的不同。 any 类型 **最不安全的类型**：any类型是 TypeScript 类型系统的逃逸舱口，使用any可以让任何表达式绕过类型检查，转而采用 JavaScript 动态类型的行为。 **类型放弃**：当你把一"},{"id":"693","title":"介绍一下 TS 中的泛型【热度: 118】","category":"TypeScript","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/693","page":"q/typescript-693.html","excerpt":"**关键词**：TS 泛型 TypeScript 的泛型是一种工具，它能够使代码更加灵活，能够适配多种类型而非单一的类型。泛型可以创建可重用的组件，这些组件可以支持多种类型的数据，而不失去类型检查时的安全性。 泛型的基本概念 在 TypeScript 中, 泛型使用一个类型变量，常见的类型变量有 T,U,V 等。通过类"},{"id":"683","title":"void 和 never 区别【热度: 410】","category":"TypeScript","labels":["TypeScript","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/683","page":"q/typescript-683.html","excerpt":"**关键词**：typescript void、typescript never、void 和 never 区别 在 TypeScript 中，void和never类型都代表没有值，但用途和含义却有所不同。以下是它们之间的主要区别： **void**： void类型用于标记函数没有任何返回值。这意呑着函数可能执行了一些"},{"id":"665","title":"TypeScript 内置的类型方法和工具类型【热度: 492】","category":"TypeScript","labels":["TypeScript","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/665","page":"q/typescript-665.html","excerpt":"**关键词**：ts 内置类型方法、ts 内置工具类型 TypeScript 提供了许多内置的类型方法和工具类型，用于处理和操作类型。以下是其中一些常用的内置类型方法： 分类 **Utility Types（工具类型）**： **Partial\\<T>**: 将类型 T 的所有属性变为可选。 **Required\\<T"},{"id":"512","title":"in 运算符作用是什么【热度: 844】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/512","page":"q/typescript-512.html","excerpt":"**关键词**：in 运算符、in 运算符作用、in 运算符应用 在 TypeScript 中，in 是一个运算符，用于检查对象是否具有指定的属性或者类实例是否实现了指定的接口。 对于对象类型，in 运算符可以用来检查对象是否具有某个属性。语法为 property in object，其中 property 是一个字符"},{"id":"511","title":"is 作用是什么【热度: 458】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/511","page":"q/typescript-511.html","excerpt":"**关键词**：is 谓词语法、is 语法作用 在 TypeScript 中，is 是一种类型谓词（type predicate）语法。它用于在运行时对一个值的类型进行检查，并返回一个布尔值。 is 通常与条件类型和类型保护（type guards）一起使用。条件类型可以基于类型谓词 is 的结果来进行类型细化，从而在"},{"id":"510","title":"infer 关键字是什么【热度: 100】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/510","page":"q/typescript-510.html","excerpt":"**关键词**：infer 关键字、infer 关键字作用 在 TypeScript 中，infer 是一个用于条件类型中的关键字。它的作用是从待推断的类型中提取特定的类型，并将其赋值给一个类型变量。这个类型变量可以在条件类型的 true 分支中使用。 通过使用 infer 关键字，我们可以实现一些高级的类型操作，比如"},{"id":"509","title":"extends 条件类型定义【热度: 297】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/509","page":"q/typescript-509.html","excerpt":"**关键词**：extends 类型继承、extends 条件类型定义 在 TypeScript 中，extends 关键字不仅仅用于类之间的继承关系，还可以用于条件类型的定义。 条件类型是一种在类型系统中根据条件进行推断的方式。通过使用 extends 关键字，可以根据给定的条件选择不同的类型。 以下是一个使用 ex"},{"id":"508","title":"联合类型是什么？【热度: 1,180】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/508","page":"q/typescript-508.html","excerpt":"**关键词**：联合类型、联合类型应用 在 TypeScript 中，联合类型是指将多个类型组合到一起形成的新类型。联合类型使用 | 符号来表示，表示允许变量具有其中任意一个类型的值。 例如，可以声明一个变量为 string | number 类型，表示该变量可以是字符串类型或者数值类型。这样可以增加变量的灵活性，可以"},{"id":"507","title":"unknown 是什么类型，详细讲一下【热度: 801】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/507","page":"q/typescript-507.html","excerpt":"**关键词**：unknown类型、unknown类型应用 unknown指的是**不可预先定义的类型**，在很多场景下，它可以替代any的功能同时保留静态检查的能力。 这个时候unknown的作用就跟any高度类似了，你可以把它转化成任何类型，不同的地方是，在静态编译的时候，unknown不能调用任何方法，而any可"},{"id":"506","title":"never 是什么类型，详细讲一下【热度: 667】","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/506","page":"q/typescript-506.html","excerpt":"**关键词**：never类型、never类型应用 **never 是其他任意类型的子类型的类型被称为底部类型(bottom type)。** 在 TypeScript 中，never 类型便为空类型和底部类型。never 类型的变量无法被赋值，与其他类型求交集为自身，求并集不参与运算。 应用一: 联合类型中的过滤 *"},{"id":"276","title":"const 和 readonly 的区别","category":"TypeScript","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/276","page":"q/typescript-276.html","excerpt":"TypeScript 中不可变量的实现方法有两种： 使用 ES6 的 const 关键字声明的值类型 被 readonly 修饰的属性 2、TypeScript 中 readonly： TypeScript 中的只读修饰符，可以声明更加严谨的可读属性。通常在 interface 、 Class 、 type 以及 ar"},{"id":"275","title":"枚举和常量枚举的区别","category":"TypeScript","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/275","page":"q/typescript-275.html","excerpt":"枚举和常量枚举（const枚举）：使用枚举可以清晰地表达意图或创建一组有区别的用例 区别： 枚举会被编译时会编译成一个对象，可以被当作对象使用 const 枚举会在 typescript 编译期间被删除，const 枚举成员在使用的地方会被内联进来，避免额外的性能开销 由此可见，使用 常量枚举 会有更好的性能。 定义的"},{"id":"273","title":"ts 中 type 和 interface的区别","category":"TypeScript","labels":["TypeScript","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/273","page":"q/typescript-273.html","excerpt":"相同点 都可以描述一个对象或者函数 interface ts 都允许拓展（extends） interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 差异点 **type** type"},{"id":"185","title":"TypeScript is 这个关键字是做什么呢？","category":"TypeScript","labels":["TypeScript"],"url":"https://github.com/pro-collection/interview-question/issues/185","page":"q/typescript-185.html","excerpt":"is 是 TypeScript 中的一个关键字，用于创建类型保护。在 TypeScript 中，类型保护是一种用于确定变量是否符合某种类型的方法。当我们使用 is 关键字创建一个类型保护时，它会在运行时对变量进行判断，然后返回一个布尔值。 具体来说，我们可以通过定义一个返回值为布尔类型的函数，并在函数内部进行类型判断来"},{"id":"423","title":"能弄个markdown文档吗","category":"uncategorized","labels":["None"],"url":"https://github.com/pro-collection/interview-question/issues/423","page":"q/uncategorized-423.html","excerpt":"如题 Comments / Answers --- **yanlele** at 2023-06-08T16:14:03Z @gtrgeg 这个建议非常好， 其实有 markdown 文档的哈; 可以看这个目录： https://github.com/pro-collection/interview-question/"},{"id":"1136","title":"react 开发的应用里面， 如何给系统设置一个全局的崩溃的提示页面【热度: 725】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/1136","page":"q/web框架-1136.html","excerpt":"**关键词**：崩溃提示 在 React 应用中设置全局崩溃提示页面，核心是通过 **错误边界边界（Error Boundary）** 来捕获子组件树中的 JavaScript 错误，并显示备用 UI。以下是具体实现方案： 实现说明 **错误边界组件（ErrorBoundary）** 这是一个 React 类组件，利用"},{"id":"1095","title":"[React] Recoil 里面 selectorFamily 的作用是什么？和 selector 有啥区别【热度: 200】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1095","page":"q/web框架-1095.html","excerpt":"**关键词**：Recoil selector 和 selectorFamily 在 Recoil 中，selectorFamily 和 selector 都是用于创建派生状态的工具，但它们在使用场景和功能上存在一些差异，下面为你详细介绍它们的作用以及区别。 selector 的作用 selector 用于创建派生状态"},{"id":"1094","title":"[React] Recoil 里面 selector 支持哪些参数【热度: 239】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1094","page":"q/web框架-1094.html","excerpt":"**关键词**：Recoil selector 在 Recoil 中，selector 函数接受一个配置对象作为参数，这个配置对象有多个可选属性，下面详细介绍这些属性。 1. key **类型**：string **描述**：key 是一个必需的属性，用于唯一标识这个 selector。在 Recoil 的内部状态管理"},{"id":"1093","title":"[React] Recoil 里面 selector 该如何使用【热度: 239】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1093","page":"q/web框架-1093.html","excerpt":"**关键词**：Recoil selector 在 Recoil 中，selector 用于创建派生状态，它可以根据一个或多个原子（atom）状态计算出新的状态。selector 的值会自动进行记忆化，只有当依赖的状态发生变化时才会重新计算。下面详细介绍 selector 的使用方法。 1. 基本使用 创建一个简单的 "},{"id":"1092","title":"[React] 状态管理库 Recoil 与 Redux 有何区别【热度: 210】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1092","page":"q/web框架-1092.html","excerpt":"**关键词**：Recoil 与 Redux 区别 Recoil 和 Redux 都是用于管理 React 应用程序状态的库，但它们在设计理念、API、使用场景等方面存在一些明显的区别，下面为你详细介绍： 1. 设计理念 **Redux** 采用单向数据流和单一数据源的设计理念。整个应用的状态被存储在一个单一的 sto"},{"id":"1069","title":"[React] useCallback 是否支持异步函数【热度: 410】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1069","page":"q/web框架-1069.html","excerpt":"**useCallback的基本原理和同步特性** useCallback是一个 React Hook，主要用于优化组件的性能。它返回一个记忆化的回调函数，这个函数只有在依赖项数组中的元素发生变化时才会重新创建。 例如，在一个典型的同步场景下： 这里的doSomething是一个同步函数，useCallback会根据a"},{"id":"1068","title":"[React] useMemo 是否可以支持异步函数【热度: 410】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1068","page":"q/web框架-1068.html","excerpt":"useMemo本身不直接支持异步函数，但可以通过一些方式来结合异步操作使用。 **useMemo的基本原理和同步操作特性** useMemo是一个 React Hook，用于优化组件的性能。它会在组件渲染时，根据依赖项数组中的值是否发生变化来决定是否重新计算记忆化的值。 例如，在一个简单的同步场景中： 这里，expen"},{"id":"1052","title":"[React] 如何将一个层级非常深的子组件的某一个方法， 抛出给上层组件使用【热度: 465】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1052","page":"q/web框架-1052.html","excerpt":"**关键词**：调用子组件方法 在 React 中，可以通过以下几种方式将一个层级非常深的子组件的某一个方法抛出给上层组件使用： **一、使用回调函数传递** 在父组件中定义一个回调函数，并将其作为属性传递给子组件的父级组件，依次向下传递，直到目标子组件。 例如： 在深层子组件中，当特定条件触发时，调用这个通过层层传递"},{"id":"1001","title":"[Vue] vue3 对虚拟 dom 做了哪些优化【热度: 446】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1001","page":"q/web框架-1001.html","excerpt":"**关键词**：vue3 虚拟dom Vue 3 对虚拟 DOM 进行了多方面的优化，主要包括以下几点： **一、静态提升（Static Hoisting）** 原理与作用： 在 Vue 3 的编译阶段，会分析模板中的静态内容，将静态的节点提升到渲染函数之外。这意味着对于静态的元素和文本，不会在每次渲染时都重新创建虚拟"},{"id":"1000","title":"[Vue] vue3 还是使用的虚拟 dom 吗？【热度: 345】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/1000","page":"q/web框架-1000.html","excerpt":"**关键词**：vue3 虚拟dom Vue 3 仍然使用虚拟 DOM（Virtual DOM）。 **一、虚拟 DOM 在 Vue 3 中的重要性** 高效的 DOM 操作：虚拟 DOM 是一种在内存中表示真实 DOM 结构的树形数据结构。在 Vue 3 中，当数据发生变化时，首先会在虚拟 DOM 上进行比较和计算，"},{"id":"999","title":"现代框架如 React、Vue 相比原生开发有什么优势【热度: 897】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/999","page":"q/web框架-999.html","excerpt":"**关键词**：现代框架优势 现代框架如 React 和 Vue 相比原生开发具有以下优势： **一、提高开发效率** 组件化开发： React 和 Vue 都采用了组件化的开发模式。这使得开发者可以将用户界面拆分成独立的、可复用的组件。每个组件都有自己的逻辑和样式，易于维护和扩展。 例如，在一个电商网站中，可以将商品"},{"id":"998","title":"[Vue] nextTick 作用是什么， 原理是什么【热度: 177】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/998","page":"q/web框架-998.html","excerpt":"**关键词**：vue nextTick 作用、原理 在 Vue 中，nextTick主要有以下作用和工作原理： **一、作用** 确保 DOM 更新后执行操作： Vue 是异步更新 DOM 的。当你在代码中修改了数据，Vue 不会立即更新 DOM，而是将这些更新操作放入一个队列中，等待下一个“tick”（事件循环的一"},{"id":"997","title":"[Vue] vue3 如何监听数组变化【热度: 199】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/997","page":"q/web框架-997.html","excerpt":"**关键词**：vue3 监听数组变化 在 Vue 3 中，可以通过以下几种方式监听数组的变化： **一、使用watch函数监听数组引用变化** 直接监听数组变量： 可以使用watch函数来监听一个数组变量的变化。当数组被重新赋值时，watch会触发。 在这个例子中，当state.arr数组被重新赋值时，watch函数"},{"id":"988","title":"[React]在应用中如何排查性能问题【热度: 255】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/988","page":"q/web框架-988.html","excerpt":"**关键词**：React 性能排查 在 React 应用中，可以通过以下方法来排查性能问题： **一、使用 Chrome 开发者工具** **性能分析（Performance）**： 打开 Chrome 浏览器，进入开发者工具。选择“Performance”选项卡。 点击“Record”按钮开始录制页面的交互过程。进"},{"id":"983","title":"[React] 在 setState 时发生了什么【热度: 169】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/983","page":"q/web框架-983.html","excerpt":"**关键词**：React setState 过程 在 React 中，当调用setState时，会发生以下一系列事情： **一、触发状态更新** **调用 setState 方法**： 当在 React 组件中调用setState方法时，React 会将这个状态更新请求排队。这意味着 React 不会立即更新组件的状"},{"id":"982","title":"[React] 在 redux 中如何写一个记录状态变更的日志插件【热度: 52】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/982","page":"q/web框架-982.html","excerpt":"**关键词**：redux 插件 在 Redux 中，可以编写一个日志插件来记录状态的变更。以下是实现的步骤： 创建日志插件函数： 这个函数接收一个 Redux store 对象，返回一个中间件函数。这个中间件函数接收下一个中间件的调用函数next和当前的动作action。 将日志插件添加到 Redux store： "},{"id":"981","title":"[React] 如何实践数据不可变状态【热度: 114】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/981","page":"q/web框架-981.html","excerpt":"**关键词**：react 数据不可变 在 React 中，可以通过以下几种方式来实践数据不可变状态： **一、使用不可变数据结构库（如 Immutable.js）** **安装和导入 Immutable.js**： 首先，安装 Immutable.js 库：npm install immutable。 然后，在 Re"},{"id":"980","title":"[React] 对象数据状态不可变是什么概念【热度: 113】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/980","page":"q/web框架-980.html","excerpt":"**关键词**：react 数据不可变 在 React 中，“对象数据状态不可变”是一个重要的概念，它主要有以下几个方面的含义： **一、保证数据的稳定性和可预测性** **避免意外的副作用**： 当 React 组件的状态是可变的时，在复杂的应用中很容易出现意外的副作用。例如，如果多个组件共享一个可变的状态对象，一个"},{"id":"936","title":"[Vue] 对比一下 vuex 和 Pinia 两个状态库【热度: 300】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/936","page":"q/web框架-936.html","excerpt":"**关键词**：vue 状态库对比 Vuex 和 Pinia 都是用于 Vue 应用程序的状态管理库，它们有一些相似之处，但也存在一些差异。以下是它们的对比： **一、相似之处** **集中式状态管理**： 两者都提供了一种集中式的方式来管理应用程序的状态。这使得状态可以在不同的组件之间共享，并且可以更容易地跟踪和调试"},{"id":"935","title":"[Vue] 介绍一下 vue 工具链【热度: 53】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/935","page":"q/web框架-935.html","excerpt":"**关键词**：vue 工具链 作者备注 这个其实没有啥好说的， 官网上面都有。 直接看官网即可 https://cn.vuejs.org/guide/scaling-up/tooling 以下是 Vue 的相关工具链介绍： **一、项目脚手架** **Vue CLI**： 功能：Vue CLI 是一个官方的 Vue."},{"id":"934","title":"[Vue] 介绍一下 component 动态组件【热度: 184】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/934","page":"q/web框架-934.html","excerpt":"**关键词**：component 动态组件 在 Vue 中，动态组件是一种强大的特性，可以根据不同的条件在运行时动态地切换组件的显示。 **一、基本概念** 动态组件使用特殊的<component>标签结合is属性来实现。is属性可以接受一个字符串或变量，用于指定要渲染的组件名称或组件选项对象。Vue 会根据is属性"},{"id":"933","title":"[Vue] 详细介绍一下 teleport 内置组件【热度: 100】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/933","page":"q/web框架-933.html","excerpt":"**关键词**：teleport 内置组件 在 Vue 中，<teleport>是一个内置组件，它提供了一种将组件的模板内容渲染到指定 DOM 节点位置的方式，而不是在组件自身的位置渲染。 **一、作用与优势** 灵活布局：允许你将特定的组件内容放置在页面的任何位置，而不受组件层次结构的限制。这对于创建模态框、通知、工"},{"id":"932","title":"[Vue] 有哪些内置组件【热度: 355】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/932","page":"q/web框架-932.html","excerpt":"**关键词**：vue 内置组件 在 Vue 中，有一些内置组件，主要包括以下几个： **一、<component>动态组件** 作用：用于根据条件动态地渲染不同的组件。 使用方法： **二、<transition>过渡组件** 作用：为元素或组件的插入、更新和移除添加过渡效果。 使用方法： **三、<teleport"},{"id":"931","title":"[Vue] 实现一个简单的 i18n (国际化 (Internationalization) 的缩写) 插件【热度: 166】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/931","page":"q/web框架-931.html","excerpt":"**关键词**：vue i18n 插件实现 作者备注 这个是一个简单的官方案例， 如果阅读过官方文档， 就没有任何难点。 所以暂定为「中级」 实现下面的这样的一个插件 <h1>{{ $translate('greetings.hello') }}</h1> 以下是一个简单的 Vue 3 的国际化插件实现： 创建一个名为"},{"id":"930","title":"[Vue] 插件是什么概念，有什么作用，该怎么用【热度: 550】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/930","page":"q/web框架-930.html","excerpt":"**关键词**：vue 插件 在 Vue 中，插件是一种用于增强 Vue 功能的工具。 **一、概念** Vue 插件是一个包含install方法的对象，或者是一个函数，这个函数接收 Vue 的构造函数作为参数。插件可以为 Vue 添加全局的功能，如全局组件、全局指令、全局过滤器、全局混入（mixin）等，也可以扩展 "},{"id":"929","title":"[Vue] vue 如何配置全局使用的定义或者常量【热度: 337】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/929","page":"q/web框架-929.html","excerpt":"**关键词**：vue 全局配置 在 Vue 中，可以通过以下几种方式配置全局使用的定义或常量： **一、使用 Vue 原型（不推荐在 Vue 3 中使用）** 在 Vue 2 中，可以通过在main.js文件中向 Vue 的原型上添加属性来实现全局定义或常量的访问。但在 Vue 3 中不推荐这种方式，因为它可能会导致"},{"id":"928","title":"[Vue] 如何自定义指令【热度: 159】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/928","page":"q/web框架-928.html","excerpt":"**关键词**：vue 自定义指令 在 Vue 中，可以通过以下步骤来自定义指令： **一、全局自定义指令** 使用Vue.directive()方法定义全局指令： 在模板中使用自定义指令： **二、局部自定义指令** 在组件中定义局部指令： 在组件的模板中使用局部自定义指令： **三、指令定义对象的参数说明** el"},{"id":"927","title":"[Vue] 组合式函数 和 vue2 mixins 对比， 有何优劣【热度: 311】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/927","page":"q/web框架-927.html","excerpt":"**关键词**：组合式函数 对比 mixins 在 Vue 3 中，组合式函数（Composables）与 Vue 2 中的混入（Mixins）相比，有以下优劣： **一、组合式函数的优势** 更好的可读性和可维护性： 组合式函数通常是一个独立的函数，其逻辑更加清晰，容易理解和调试。每个组合式函数专注于特定的功能，使得"},{"id":"926","title":"[Vue] 如何提升复用逻辑【热度: 671】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/926","page":"q/web框架-926.html","excerpt":"**关键词**：vue3 复用逻辑 在 Vue 3 中，可以通过以下几种方式提升复用逻辑： **一、组合式函数（Composables）** 定义与使用： 组合式函数是一个封装了可复用逻辑的函数，可以接收参数并返回响应式数据和方法。例如： 在组件中使用组合式函数： 优势： 可维护性高：将可复用的逻辑封装在独立的函数中，"},{"id":"925","title":"[Vue] 介绍一下 Provide【热度: 633】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/925","page":"q/web框架-925.html","excerpt":"**关键词**：vue3 Provide Vue 3 中的 provide 和 inject 功能提供了一种方法，允许祖先组件将数据“提供”给它的所有后代组件，无论后代组件位于组件树的何处，而不必通过所有的组件层层传递属性（props）。这对于深层嵌套的组件或跨多个组件共享状态特别有用。 基本用法 在祖先组件中提供数据"},{"id":"924","title":"[Vue] 介绍一下动态插槽名","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/924","page":"q/web框架-924.html","excerpt":"**关键词**：vue3 动态插槽名 在 Vue 3 中，动态插槽名允许在运行时根据特定的条件动态地确定插槽的名称，从而为组件的渲染提供了更大的灵活性。 **一、基本概念** 通常情况下，插槽名在组件定义时是固定的。但在某些场景中，可能需要根据不同的情况动态地选择要渲染的插槽。Vue 3 引入了动态插槽名的特性，使得可"},{"id":"923","title":"[Vue] 介绍一下条件插槽【热度: 100】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/923","page":"q/web框架-923.html","excerpt":"**关键词**：vue3 条件插槽 可以查看官网: https://cn.vuejs.org/guide/components/slots#conditional-slots 在 Vue 中，条件插槽可以通过结合使用 $slots 属性与 v-if 来实现动态地根据特定条件渲染不同的内容到插槽中。 **一、基本概念**"},{"id":"922","title":"[Vue] 介绍一下 defineEmits【热度: 346】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/922","page":"q/web框架-922.html","excerpt":"**关键词**：介绍一下 defineEmits 在 Vue 3 中，defineEmits是一个用于定义组件触发的自定义事件的函数。 **一、作用与目的** 在 Vue 3 的组合式 API 中，使用defineEmits可以明确地声明组件向外触发的事件类型，这有助于提高代码的可读性和可维护性。通过定义触发的事件，其"},{"id":"921","title":"[Vue] 都是支持响应式， defineModel 和 reactive 有何不同【热度: 344】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/921","page":"q/web框架-921.html","excerpt":"**关键词**：defineModel 和 reactive 异同 在 Vue 3 中，defineModel和reactive虽然都与响应式相关，但它们有以下不同之处： **一、功能目的** **reactive**： 主要用于创建响应式对象。它接收一个普通的 JavaScript 对象，并将其转换为响应式对象，使得"},{"id":"920","title":"[Vue] 介绍一下 defineModel【热度: 433】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/920","page":"q/web框架-920.html","excerpt":"**关键词**：vue3 双向绑定 defineModel 在 Vue 3 中，defineModel是一个用于简化双向绑定的函数，通常与组合式函数（composition function）一起使用。 **一、主要作用** **自动解包响应式对象**： 当在组合式函数中使用响应式对象时，使用defineModel可以"},{"id":"919","title":"[Vue] 子组件是否能使用 未定义的 props 【热度: 266】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/919","page":"q/web框架-919.html","excerpt":"**关键词**：组件定义 props 在 Vue 中，子组件默认情况下不能使用未在 props 选项中明确定义的属性。Vue 的组件系统旨在明确组件之间的接口，其中 props 作为组件公开的属性，必须被明确声明。这样做的目的是为了增强代码的可读性和可维护性，确保组件之间的通信清晰和有序。 但是，有几种方式可以绕过这个"},{"id":"918","title":"[Vue] 子组件定义接受的 props 方式有哪些【热度: 465】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/918","page":"q/web框架-918.html","excerpt":"**关键词**：组件定义 props 在 Vue 中，子组件可以通过 props 接收来自父组件的数据。props 是组件的可配置项之一，它允许外部环境传递数据给组件。有几种不同的方式来定义组件的 props，这些方式提供了不同级别的验证和默认值设置。以下是 Vue 中定义 props 的不同方式及其特点： 1. **"},{"id":"917","title":"[Vue] vue 全局注册组件很方便，为何不都是用全局注册【热度: 592】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/917","page":"q/web框架-917.html","excerpt":"Vue 的全局注册组件确实提供了便利，特别是在组件需要跨多个视图或组件重复使用时。但是，如果全部或大量使用全局注册，也会带来一些缺点或问题。下面列举了几个不推荐全面使用全局注册组件的原因： 1. **应用启动性能** 全局注册的组件会在应用启动时全部加载和注册，这对于小至中等规模的应用可能不是问题。但对于大型或超大型的"},{"id":"916","title":"[Vue] vue3 里面 `<script setup>` 作用是啥【热度: 210】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/916","page":"q/web框架-916.html","excerpt":"**关键词**：<script setup> 作用 在 Vue 3 中，<script setup> 是一种新的组件编写方式，旨在使组件的编写更为简洁明了。它是 Composition API 的一个语法糖，提供了一种更为简洁和易用的方式来定义组件。使用 <script setup> 可以带来几个主要好处： 1. 更简"},{"id":"915","title":"[Vue] useTemplateRef 作用是啥， 哪些情况下要要使用这个 api【热度: 405】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/915","page":"q/web框架-915.html","excerpt":"**关键词**：useTemplateRef api 作者备注 这个 api 应该是作者录入问题的前几天才发布的，作者没有使用过， 不好做过多评价， 建议直接看 juejin 的文档 链接如下：https://juejin.cn/post/7410259203175088138"},{"id":"914","title":"[Vue] 多个 slot 插槽场景，该如何申明与使用【热度: 380】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/914","page":"q/web框架-914.html","excerpt":"**关键词**：多 slot 场景 Vue 支持多个插槽（slot），使得组件的内容分发更加灵活。在 Vue 3 中，你可以通过具名插槽来实现这一点，这允许你定义多个插槽，并在父组件中指定对应的内容填充到子组件的不同部位。 定义具名插槽 在子组件中，你可以使用 <slot> 元素来定义一个或多个插槽，并通过 name "},{"id":"913","title":"[Vue] 侦听器在什么情况下是需要清理副作用的【热度: 148】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/913","page":"q/web框架-913.html","excerpt":"**关键词**：侦听器副作用 在 Vue 3 中，清理副作用主要指的是在一个响应式侦听器（例如：watch 或 watchEffect）中，当侦听的响应式状态（或侦听的回调函数）重新执行之前或组件销毁时，移除或停止之前创建的资源，以避免内存泄漏、性能问题或意外的行为。下面列举了一些需要清理副作用的典型情况： 1. **"},{"id":"912","title":"[Vue] watch 和 watchEffect 场景上有何区别， 该如何选择【热度: 174】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/912","page":"q/web框架-912.html","excerpt":"**关键词**：侦听器选择 watch 和 watchEffect 在 Vue 3 中都是强大的响应式特性，用于侦听响应式状态的变化并执行一些副作用（如调用函数）。虽然它们很相似，但在使用场景和行为上有一些关键的区别，了解这些区别可以帮助你选择最合适的工具来实现你的需求。 watch **精确性**：watch 允许你"},{"id":"911","title":"[Vue] 介绍一下 3.x 侦听器 watchEffect【热度: 323】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/911","page":"q/web框架-911.html","excerpt":"**关键词**：侦听器 watchEffect Vue 3 引入了 Composition API，其中包括一个强大的函数 watchEffect，用于侦听响应式状态的变化，并当响应式状态变化时自动执行。 基本用法 watchEffect 接收一个函数作为参数，Vue 将会自动跟踪这个函数内部使用的所有响应式状态（响应"},{"id":"910","title":"[Vue] 介绍一下 3.x 侦听器 watch【热度: 671】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/910","page":"q/web框架-910.html","excerpt":"**关键词**：侦听器 watch Vue 3 提供了一个灵活的响应式系统，其中 watch 函数是实现细粒度数据观察和响应的重要工具。watch 能够侦听 Vue 应用中的响应式数据的变化，并在数据变化时执行相应的回调函数。这个功能在 Vue 2 中以 watch 选项的形式存在，而在 Vue 3 的组合式 API "},{"id":"909","title":"[Vue] 生命周期【热度: 848】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/909","page":"q/web框架-909.html","excerpt":"**关键词**：生命周期 最基础生命周期直接可以看下面这个图， 如果只能回答下面这个图里面的生命周期， 那么该问题只能是「中等」级别； 之所以是 「高等」级别的问题， 因为还有很多别的生命周期， 大家不一定知道， 但是也很重要； Vue3 新增的生命周期 onErrorCaptured() onRenderTracke"},{"id":"908","title":"[Vue] 输入绑定修饰符 .lazy 作用是啥【热度: 95】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/908","page":"q/web框架-908.html","excerpt":"**关键词**：输入绑定修饰符 在 Vue 中，.lazy 是一个输入绑定修饰符，用于 v-model 指令。它的主要作用是改变数据同步的时机：默认情况下，使用 v-model 绑定的输入字段会在每次 input 事件触发时同步数据（即用户输入时实时同步），而通过添加 .lazy 修饰符后，数据同步会改为在 chang"},{"id":"907","title":"[Vue] 触发事件修饰符 .exact 的作用是啥【热度: 454】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/907","page":"q/web框架-907.html","excerpt":"**关键词**：事件修饰符、.exact 作用 .exact 修饰符在 Vue 事件处理中起着非常特定的作用。它允许控制触发事件处理器的确切方式，确保只有在指定的系统修饰键（如 ctrl、alt、shift、meta）组合完全匹配时，事件处理函数才会被触发。这意味着，如果你绑定了 .exact 修饰符到一个事件上，只有"},{"id":"906","title":"[Vue] 提供了哪些默认事件修饰符【热度: 366】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/906","page":"q/web框架-906.html","excerpt":"**关键词**：事件修饰符 在 Vue 中，事件修饰符是一些由点 (.) 开头的特殊后缀，用于指示 Vue 对 DOM 事件进行某种特殊处理。Vue 提供了一系列的默认事件修饰符来帮助开发者更方便地处理一些常见的 DOM 事件行为。 下面是 Vue 3 中提供的一些默认事件修饰符： | 事件修饰符 | 描述 | | -"},{"id":"905","title":"[Vue] computed 和 普通函数有何区别【热度: 332】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/905","page":"q/web框架-905.html","excerpt":"**关键词**：计算属性 computed 作用 作者总结 其实没有啥好说的， 就一个核心：缓存！computed 是支持缓存的， 避免了不必要的重复计算， 有较高性能表现 下面是一个表格，对比了 Vue 3 中的 computed 计算属性和普通函数方法的主要差异： | 特性 | 计算属性 (computed) | "},{"id":"904","title":"[Vue] reactive() 的局限性有哪些【热度: 410】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/904","page":"q/web框架-904.html","excerpt":"**关键词**：响应式 api 作者备注 前三条是官网自己总结的限制， 属于核心限制 后面提交是作者自行补充 1. 基本数据类型不是响应式的 reactive 只能将对象或数组转换为响应式对象。对于基本数据类型（如字符串、数字、布尔值等），reactive 无法将其转换为响应式的。如果需要使基本类型数据响应式，应使用 "},{"id":"903","title":"[Vue] vue 中 reactive() 返回的为何是一个原始对象的 Proxy，有和好处【热度: 416】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/903","page":"q/web框架-903.html","excerpt":"**关键词**：响应式 api 在 Vue 3 中，reactive 函数通过返回原始对象的 Proxy 来实现响应式系统具有几个好处： 1. 智能依赖跟踪 Proxy 允许 Vue 精确地控制对象属性的读取和修改。这意味着 Vue 可以智能地追踪哪些组件依赖于哪些数据，只有当相关数据发生改变时，依赖那些数据的组件才会"},{"id":"902","title":"[Vue] 深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 Map 等， 在响应式使用方面， ref 和 reactive 有何区别吗【热度: 415】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/902","page":"q/web框架-902.html","excerpt":"**关键词**：响应式 api 在 Vue 3 的响应式系统中，处理深层嵌套的数据时，ref 和 reactive 在行为上有一些细微但重要的区别，特别是当涉及到对象、数组以及 JavaScript 内置的数据结构（如 Map 和 Set）时。这些区别主要体现在如何使嵌套的数据成为响应式的，以及如何维护这些响应性。 处"},{"id":"901","title":"[Vue] 响应式里面 ref 和 reactive 有啥区别【热度: 414】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/901","page":"q/web框架-901.html","excerpt":"**关键词**：响应式 api 在 Vue 3 中，ref 和 reactive 是创建响应式数据的两种不同方法，它们都是 Vue 的响应式系统的一部分，但在使用方式和适用场景上有一些区别。下面是 ref 和 reactive 的主要区别： ref **用法**：ref 用于创建一个响应式的引用类型数据。当你需要使基本"},{"id":"900","title":"[Vue] 解释一下 @submit.prevent=\"onSubmit\" 这个指令【热度: 590】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/900","page":"q/web框架-900.html","excerpt":"**关键词**：指令的含义 直接上图： 在 Vue 中，@submit.prevent=\"onSubmit\" 是一个指令修饰符的示例，它结合了事件侦听和事件修饰符的概念来提供一种声明式的方式处理表单提交事件，并自动阻止其默认行为。 这个指令可以分为几个部分来解释： @submit @ 是一个简写符号，用于标识事件侦听器"},{"id":"899","title":"[Vue] 如何处理异步加载组件【热度: 254】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/899","page":"q/web框架-899.html","excerpt":"**关键词**：异步加载组件 在 Vue 应用中，异步组件是指那些在声明时不会立即加载，而是在需要的时候才加载的组件。使用异步组件能够帮助你提高应用的加载速度和性能，特别是在处理大型应用和路由懒加载时。Vue 提供了几种处理异步加载组件的方法。 Vue 3 中处理异步组件的方法 使用 defineAsyncCompon"},{"id":"898","title":"[Vue] 3.x 中 app.config 有哪些应用配置？【热度: 200】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/898","page":"q/web框架-898.html","excerpt":"**关键词**：app.config 配置 确实，在 Vue 3 中，app.config 提供了一系列的应用级别的配置选项，用于自定义或调整 Vue 应用的行为。你提到的这些配置项都是 app.config 的一部分，下面是关于它们的详细介绍： app.config.errorHandler **作用**：为未捕获的"},{"id":"897","title":"[Vue] 选项式 API 和组合式 API，两者有何区别，该如何取舍【热度: 322】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/897","page":"q/web框架-897.html","excerpt":"**关键词**：选项式 API 和组合式 API 区别 选项式 API (Options API) 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 组合式 API (Com"},{"id":"896","title":"[Vue] 为何会被称为渐进式框架， 哪儿体现了渐进式【热度: 390】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/896","page":"q/web框架-896.html","excerpt":"**关键词**：如何体现渐进式 作者备注 这个概念直接在官网起步就可以看到 https://cn.vuejs.org/guide/introduction.html 所以作为基础知识即可， 定义为 「简单」级别 Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同"},{"id":"862","title":"[React] 性能调优中，如何确定哪个数据变化引起的组件渲染【热度: 500】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/862","page":"q/web框架-862.html","excerpt":"**关键词**：react 渲染性能调优 帮助开发者排查是哪个属性改变导致了组件的 rerender。 直接接受 ahooks 里面的一个方法： $1 源码实现："},{"id":"843","title":"[vue] scope 是怎么做的样式隔离的【热度: 126】","category":"web框架","labels":["web框架","京东"],"url":"https://github.com/pro-collection/interview-question/issues/843","page":"q/web框架-843.html","excerpt":"**关键词**：vue 样式个例 Vue 中的样式隔离是通过 Vue 单文件组件（Single File Components，简称 SFC）的 <style> 标签中的 scoped 属性实现的。当你在一个 Vue 组件的 <style> 标签上添加 scoped 属性时，Vue 会自动将该样式限定在当前组件的范围内"},{"id":"835","title":"[React] 类组件中，为什么修改状态要使用 setState 而不是用 this.state.xxx = xxx【热度: 414】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/835","page":"q/web框架-835.html","excerpt":"**关键词**：react state 问题 在 React 类组件中，状态（state）是组件的局部状态，你可以通过调用 setState 方法来异步更新组件的状态。有几个重要原因解释了为什么在 React 类组件中应该使用 setState 而不是直接修改 this.state： 1. **保证状态的不可变性（Im"},{"id":"828","title":"[vue] 第一次页面加载会触发哪几个钩子【热度: 112】","category":"web框架","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/828","page":"q/web框架-828.html","excerpt":"**关键词**：vue 钩子出发 在 Vue.js 中，页面首次加载时，会按照以下顺序触发一系列的生命周期钩子： **beforeCreate**: 实例刚在内存中被创建时调用，此时还未初始化响应式数据和事件。 **created**: 实例创建完成后被调用，此时已完成数据观测（即数据响应式）、属性和方法的运算，$el"},{"id":"819","title":"[React] 为什么要自定义合成事件【热度: 132】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/819","page":"q/web框架-819.html","excerpt":"**关键词**：React 合成事件 React 选择自定义合成事件系统主要是为了提供一个统一的事件处理接口，解决浏览器原生事件的兼容性问题，并优化性能。以下是自定义合成事件系统的几个关键原因： **跨浏览器一致性**： 不同的浏览器对事件的实现存在差异，这可能导致在不同浏览器上运行的代码行为不一致。React 的合成"},{"id":"818","title":"[React] useState 的原理是什么，背后怎么执行的【热度: 446】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/818","page":"q/web框架-818.html","excerpt":"**关键词**：useState 的原理 useState 是 React 库中的一个 Hook，它允许你在函数组件中添加 React 状态。使用 useState，你可以给组件添加内部状态，并且能够通过调用这个 Hook 来更新状态，从而触发组件的重新渲染。 原理简述 useState 的工作原理基于 React 的"},{"id":"817","title":"[React] 类组件里面 setState 做了哪些事儿【热度: 200】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/817","page":"q/web框架-817.html","excerpt":"**关键词**：setState 做了哪些事儿 在 React 的类组件中，setState 方法主要做了以下几件事情： 触发组件的重新渲染：当调用 setState 时，React 会标记该组件为“脏”状态，在下一个渲染周期中重新渲染组件。 合并状态更新：setState 接受一个对象或函数作为参数。如果是对象，它会"},{"id":"813","title":"[React] useRef 是如何实现的【热度: 299】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/813","page":"q/web框架-813.html","excerpt":"**关键词**：useRef 实现 该问题也是非常复杂， 需要深入源码， 可以看下面文章解析： https://juejin.cn/post/7341757372188065792 以下是题库作者对上面文档的一些提炼总结 什么是数据共享层 hooks 如何确定 fiber 对应的 hook 上下文？ hook 是如何存"},{"id":"812","title":"[React] scheduler 调度机制原理【热度: 660】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/812","page":"q/web框架-812.html","excerpt":"**关键词**：scheduler 调度机制原理 细节过于复杂， 可以参考一下文档： https://juejin.cn/post/7331135154209308687 后续是题库作者对上述文档的一些重点信息总结： scheduler 概念 时间片与优先级 概念 优先级切分 任务队列 scheduleCallback"},{"id":"807","title":"[React] hooks 调用是可以写在 if 语句里面吗【热度: 337】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/807","page":"q/web框架-807.html","excerpt":"**关键词**：hooks 调用问题 **hooks 写在 if 语句里面， 也是可以执行的， 但是会带来很多不可预期的异常** 在 React 中，Hooks 的调用不应该直接写在 if 语句里面。 Hooks 必须在函数组件的顶层（不在循环、条件判断或嵌套函数中）按顺序调用。这是因为 React 需要在每次渲染时以"},{"id":"804","title":"[React] 生态有哪些【热度: 442】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/804","page":"q/web框架-804.html","excerpt":"**关键词**：React 生态 直接抄作业即可，参考文档如下 https://juejin.cn/post/7297908859175780364"},{"id":"779","title":"[React] 循环渲染中 为什么推荐不用 index 做 key【热度: 320】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/779","page":"q/web框架-779.html","excerpt":"**关键词**：React 循环渲染问题 在 React 的循环渲染中，不推荐使用数组的index（索引）作为元素的key，主要基于以下几点理由： **列表项顺序的变化**：如果列表项的顺序会发生变化（如排序、增加、删除操作），使用index作为key可能会导致性能问题和组件状态的错误。这是因为 React 依赖key"},{"id":"778","title":"[React] 如何避免使用 context 的时候， 引起整个挂载节点树的重新渲染【热度: 420】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/778","page":"q/web框架-778.html","excerpt":"**关键词**：React Context 渲染问题 要避免在 React 开发中使用 context 时引起整个挂载节点树的重新渲染，可以采取以下方法： React Context 数据分割：把提供 context value 的部分提取到单独的组件中，并且仅在该组件中修改 context value。这样，当 co"},{"id":"775","title":"[React] 如何针对 react hooks 写单测【热度: 170】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/775","page":"q/web框架-775.html","excerpt":"**关键词**：hooks 单测 如果你想对一个独立的 React Hook 函数进行单元测试，不涉及对它在组件中使用的测试，那么你可以使用由react-hooks-testing-library提供的工具来完成。这个库允许你在一个隔离的环境中渲染和测试 hook 函数，而不必担心组件的其他部分。 首先，你需要安装@t"},{"id":"774","title":"[React] useEffect 依赖为空数组与 componentDidMount 区别【热度: 366】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/774","page":"q/web框架-774.html","excerpt":"**关键词**：useEffect 与 componentDidMount 区别 useEffect 是 React 函数组件的生命周期钩子，它是替代类组件中 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法的统一方式。 当你给 use"},{"id":"753","title":"[React] React 19 有哪些新特性？【热度: 879】","category":"web框架","labels":["web框架","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/753","page":"q/web框架-753.html","excerpt":"**关键词**：React 19 新特性 更多详细信息可以看下面这个文章： https://juejin.cn/post/7362057701792923684 作者总结上文的重点信息内容 React 19 的新功能 新型 hook：useActionState React DOM：<form> Action Reac"},{"id":"748","title":"[React] useEffect 钩子的工作原理是什么【热度: 459】","category":"web框架","labels":["web框架","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/748","page":"q/web框架-748.html","excerpt":"**关键词**：React useEffect useEffect 钩子的工作原理涉及到 React 的渲染流程和副作用的调度机制。以下是其工作原理的详细说明： **调度副作用**：当你在组件内部调用 useEffect 时，你实际上是将一个副作用函数及其依赖项数组排队等待执行。这个函数并不会立即执行。 **提交阶段（"},{"id":"747","title":"[React] 介绍一下 useReducer【热度: 547】","category":"web框架","labels":["web框架","滴滴"],"url":"https://github.com/pro-collection/interview-question/issues/747","page":"q/web框架-747.html","excerpt":"**关键词**：React useReducer useReducer是 React Hooks 的一个部分，它为状态管理提供了一个更加灵活的方法。useReducer特别适合处理包含多个子值的复杂状态逻辑，或者当下一个状态依赖于之前的状态时。与useState相比，useReducer更适合于复杂的状态逻辑，它使组件"},{"id":"746","title":"[React] 是如何处理组件更新和渲染的？【热度: 862】","category":"web框架","labels":["web框架","快手"],"url":"https://github.com/pro-collection/interview-question/issues/746","page":"q/web框架-746.html","excerpt":"**关键词**：React 组件更新、React 组件渲染 React 组件的更新和渲染遵循一个相对严格的生命周期，这个生命周期在 React 16 版本之后，也就是从引入 Fiber 架构开始，稍微有所变化。React 通过一系列的生命周期方法以及新引入的 Hooks API，对组件的更新进行管理，主要流程如下： 类"},{"id":"741","title":"[React] forwardsRef 作用是啥， 有哪些使用场景？【热度: 336】","category":"web框架","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/741","page":"q/web框架-741.html","excerpt":"**关键词**：forwardsRef 作用、forwardsRef 使用场景 在 React 中，forwardRef 是一个用来传递 ref 引用给子组件的技术。通常情况下，refs 是不会透传给子组件的，因为 refs 并不是像 props 那样的属性。forwardRef 提供了一种机制，可以将 ref 自动地"},{"id":"732","title":"[React] react 和 react-dom 是什么关系？【热度: 197】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/732","page":"q/web框架-732.html","excerpt":"**关键词**：react 和 react-dom 关系 react 和 react-dom 是两个与 React 生态系统密切相关的 npm 包，它们在使用 React 构建用户界面时扮演不同的角色： react react 包含了构建 React 组件所必需的核心功能，例如创建组件类（如 React.Compone"},{"id":"731","title":"[React] Portals 作用是什么， 有哪些使用场景？【热度: 216】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/731","page":"q/web框架-731.html","excerpt":"**关键词**：React Portals API React Portals 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的方式。通常，组件的渲染输出会被插入到其在组件树中的父组件下，但是 Portals 提供了一种穿透组件层次结构直接渲染到任意 DOM 节点的方法。 React Portals 的作用："},{"id":"726","title":"[React] 介绍一下 HOC【热度: 789】","category":"web框架","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/726","page":"q/web框架-726.html","excerpt":"**关键词**：React HOC React 中的 HOC（高阶组件，Higher-Order Components）是一种基于 React 的组合特性而形成的设计模式，用于重用组件逻辑。一个高阶组件是一个函数，它接受一个组件并返回一个新组件。 HOC 允许你为组件添加额外的功能而无需更改组件自身的实现。这种模式可以"},{"id":"719","title":"[Vue] Vue2 中双向绑定是通过 Object.defineProperty() 实现的， 那么它是如何监控数组的？【热度: 447】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/719","page":"q/web框架-719.html","excerpt":"**关键词**：Vue2 中双向绑、Vue2 中双向绑监控数组 在 Vue 2 中，双向数据绑定的核心是 Object.defineProperty()，它允许 Vue 对每个属性进行 getter 和 setter 的拦截，从而实现响应式系统。对于普通的响应式属性来说，这一切都很简单，因为属性的 getter 和 s"},{"id":"717","title":"[React] 为何要自己实现调度器， 而不是直接使用 requestIdleCallback ？【热度: 236】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/717","page":"q/web框架-717.html","excerpt":"**关键词**：react 调度器 Scheduler、requestIdleCallback 使用场景 React 在性能优化方面的一个关键组件是调度器（Scheduler），它负责在渲染的过程中合理安排工作，以减少用户的等待时间以及避免单个任务占用过多的主线程时间，从而提高渲染性能。React 在 18.0 版本后"},{"id":"711","title":"[React] react-router 和 原生路由区别【热度: 434】","category":"web框架","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/711","page":"q/web框架-711.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 React Router 和浏览器原生 history API 在路由管理上主要有以下几个区别： **抽象级别**: **React Router** 提供了更高层次的抽象，如 <Router>、<Route>、和 <Link> 等组件，这些都是专门为"},{"id":"710","title":"[React] 在 react 项目开发过程中， 是否可以不用 react-router， 使用浏览器原生 history 路由来组织页面路由？【热度: 632】","category":"web框架","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/710","page":"q/web框架-710.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 作者备注 此问题实际上是在问：原生 路由 history api 和 react-router 的差距是啥， 或者说 react-router 做了啥 在 React 项目中，你完全可以不使用 react-router 而是使用浏览器原生的 histo"},{"id":"701","title":"[React] 为什么 react 组件， 都必须要申明一个 `import React from 'react';`【热度: 115】","category":"web框架","labels":["web框架","工程化","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/701","page":"q/web框架-701.html","excerpt":"**关键词**：babel 编译 react 首先要知道一个事情： **JSX 是无法直接运行在浏览器环境**。 原因 JSX 语法不能直接被浏览器解析和运行，因此需要插件 @babel/plugin-transform-react-jsx 来转换语法，使之能够在浏览器或任何 JavaScript 环境中执行。 所以 "},{"id":"627","title":"[React] 类组件的生命周期， 映射的 hooks 哪些 api ?【热度: 314】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/627","page":"q/web框架-627.html","excerpt":"**关键词**：生命周期映射 hooks 下面是 React 类组件的生命周期方法和对应的 Hooks API： constructor：useState 可以在函数组件中模拟类组件的 constructor。在函数组件内部使用 useState 声明状态变量，并设置初始值。 componentDidMount：use"},{"id":"619","title":"[React] 如何实现路由守卫【热度: 681】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/619","page":"q/web框架-619.html","excerpt":"**关键词**：路由守卫 在 React 中，虽然没有内置的路由守卫（Route Guards）功能，但可以使用第三方库来实现类似的功能。最常用的第三方路由库是 React Router。 React Router 提供了一些组件和钩子函数，可以用于在路由导航过程中进行拦截和控制。 <Route> 组件：可以在路由配置"},{"id":"618","title":"[Vue] 路由守卫【热度: 680】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/618","page":"q/web框架-618.html","excerpt":"**关键词**：路由守卫 路由守卫是 Vue Router 提供的一种机制，用于在路由导航过程中对路由进行拦截和控制。通过使用路由守卫，我们可以在路由导航前、导航后、导航中断等不同的阶段执行相应的逻辑。 Vue Router 提供了三种类型的路由守卫： 全局前置守卫（Global Before Guards）：在路由切"},{"id":"617","title":"[Vue] computed 和 watch 有啥区别?【热度: 876】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/617","page":"q/web框架-617.html","excerpt":"**关键词**：computed 和 watch 区别 在 Vue 中，computed 和 watch 是两种用于监听和响应数据变化的方式。 computed 是计算属性，它是基于响应式数据进行计算得到的一个新的派生属性。计算属性可以接收其他响应式数据作为依赖，并且只有当依赖数据发生变化时，计算属性才会重新计算。计算"},{"id":"616","title":"[Vue] ref、toRef 和 toRefs 有啥区别？【热度: 128】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/616","page":"q/web框架-616.html","excerpt":"**关键词**：ref、toRef、toRefs 区别 在 Vue 3 中，ref、toRef 和 toRefs 是 Vue Composition API 提供的函数，用于处理响应式数据。 ref(value: T): Ref<T>：创建一个响应式数据引用。接收一个初始值作为参数，并返回一个包含该值的响应式引用。Re"},{"id":"605","title":"[微前端] 路由加载流程是如何的？【热度: 971】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/605","page":"q/web框架-605.html","excerpt":"**关键词**：微前端路由加载 微前端是一种架构模式，旨在将大型前端应用程序拆分为更小、更容易维护的独立部分。微前端的路由原理可以通过以下步骤概括： 主应用加载：用户访问主应用时，主应用负责加载，并决定加载哪些微前端应用。 路由分发：主应用根据当前URL路径，将请求分发给相应的微前端应用。 微前端应用加载：被分发的微前"},{"id":"604","title":"[微前端] 设计原则有哪些？【热度: 1,060】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/604","page":"q/web框架-604.html","excerpt":"**关键词**：微前端设计原则 《微前端设计与实现》一书中作者卢卡·梅扎利拉提出的关于微前端的实践原则。一共有七条原则， 这些原则可以帮助团队更好地设计和实施微前端架构。 围绕业务领域建模：将前端应用程序按照业务领域进行划分，每个微前端子应用负责一个特定的业务领域。这样可以提高团队的独立性和聚焦性，降低开发和维护的复杂"},{"id":"591","title":"[React] useLayoutEffect 和 useEffect 有什么区别?【热度: 313】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/591","page":"q/web框架-591.html","excerpt":"**关键词**：useLayoutEffect 和 useEffect 区别 useLayoutEffect 和 useEffect 的主要区别在于它们执行的时机。 **useLayoutEffect**: useLayoutEffect 是在 DOM 更新完成但在浏览器绘制之前同步执行的钩子函数。它会在 DOM 更新"},{"id":"590","title":"[React] 如何避免不必要的渲染?【热度: 632】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/590","page":"q/web框架-590.html","excerpt":"**关键词**：react 渲染优化 在 React 中，有几种方法可以避免不必要的渲染，以提高性能和优化应用程序的渲染过程： 使用 PureComponent 或 shouldComponentUpdate 方法：继承 PureComponent 类或在自定义组件中实现 shouldComponentUpdate 方"},{"id":"587","title":"[React] 如何实现转场动画？","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/587","page":"q/web框架-587.html","excerpt":"这个问题非常复杂， 我这边用白话文解释一下原理， 若有不对的地方， 请大家更正： 如果没有专场动画， 那么在路由切换的一瞬间， 加载下一个路由页面的组件， 注销上一个路由页面的组件； 但是如果加上专场动画， 比如专场动画时间为 500ms， 那么， 在咋合格 500ms 过程中， 首先要加载下一个路由页面的组件， 然后"},{"id":"586","title":"[React] react router 主要包有哪些，主要 api 有哪些？","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/586","page":"q/web框架-586.html","excerpt":"React Router是React官方提供的用于构建单页应用的路由库，主要包括以下几个主要包和API： 主要包： react-router-dom：用于Web应用的路由库。 react-router-native：用于原生应用（如React Native）的路由库。 react-router-config：用于配置静"},{"id":"585","title":"[React] 是如何进行渲染的？【热度: 623】","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/585","page":"q/web框架-585.html","excerpt":"**关键词**：jsx渲染、react渲染过程 在 React 中，JSX 最终被转换为真实的 DOM 经历了以下步骤： 1. 解析 JSX：在编译阶段，React 会使用 Babel 等工具将 JSX 转换为 JavaScript 对象。 在编译阶段，React 使用 Babel 等工具将 JSX 转换为 JavaS"},{"id":"584","title":"[React] 从 React 层面上， 能做的性能优化有哪些？【热度: 1,005】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/584","page":"q/web框架-584.html","excerpt":"**关键词**：React性能优化 从 React 层面上，可以进行以下性能优化： 使用 memoization（记忆化）：通过使用 React.memo() 或 useMemo() 来避免不必要的重新渲染。这对于纯函数组件和大型组件特别有用。 使用 shouldComponentUpdate 或 PureCompon"},{"id":"583","title":"[React] 高阶组件理解多少？【热度: 655】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/583","page":"q/web框架-583.html","excerpt":"**关键词**：什么是React高阶组件、React高阶组件满足的条件、React高阶组件使用场景 **什么是高阶组件** React高阶组件（Higher-Order Component，HOC）是一种用于复用组件逻辑的设计模式。它本质上是一个函数，接受一个组件作为参数，并返回一个新的增强过的组件。 通过使用高阶组件"},{"id":"582","title":"[React] Class Components 和 Function Components 有区别？【热度: 229】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/582","page":"q/web框架-582.html","excerpt":"**关键词**：Class Components 和 Function Components、Class Components 和 Function Components 区别、Class Components 和 Function Components 差异 **概要对比** Class组件是使用ES6的类语法定义的"},{"id":"581","title":"[React] 构建组件的方式有哪些【热度: 482】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/581","page":"q/web框架-581.html","excerpt":"**关键词**：React构建组件方式 Class Components（类组件）：使用ES6的类语法来定义组件。类组件继承自React.Component，并通过render方法返回需要渲染的React元素。 Function Components（函数组件）：使用函数来定义组件，函数接收props作为参数，并返回需"},{"id":"580","title":"[React] 如何实现vue 中 keep-alive 的功能？【热度: 255】","category":"web框架","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/580","page":"q/web框架-580.html","excerpt":"**关键词**：keep-alive组件缓存、keep-alive实现、keep-alive原理 **keep-alive 原理** 可以参考这个文章： https://github.com/pro-collection/interview-question/issues/119 **实现** 当使用函数式组件时，可以"},{"id":"579","title":"[Vue] 中为何不要把 v-if 和 v-for 同时用在同一个元素上， 原理是什么？【热度: 546】","category":"web框架","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/579","page":"q/web框架-579.html","excerpt":"**关键词**：v-if和v-for性能 确实，将v-if和v-for同时用在同一个元素上可能会导致性能问题。**原因在于v-for具有比v-if更高的优先级，它会在每次渲染的时候都会运行**。这意味着，即使在某些情况下v-if的条件为false，v-for仍然会对数据进行遍历和渲染。 这样会导致一些不必要的性能消耗，"},{"id":"576","title":"[Vue] 为什么 data 属性是一个函数而不是一个对象？【热度: 448】","category":"web框架","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/576","page":"q/web框架-576.html","excerpt":"**关键词**：vue data 函数 **实例和组件定义data的区别** vue 实例的时候定义data属性既可以是一个对象，也可以是一个函数 组件中定义data属性，只能是一个函数 如果为组件data直接定义为一个对象 则会得到警告信息 警告说明：返回的data应该是一个函数在每一个组件实例中 **组件data定"},{"id":"571","title":"[Vue] 动态给 data 添加一个新的属性时会发生什么【热度: 164】","category":"web框架","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/571","page":"q/web框架-571.html","excerpt":"**关键词**：vue更改data属性 **直接添加属性的问题** 我们从一个例子开始 定义一个p标签，通过v-for指令进行遍历 然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行 实例化一个vue实例，定义data属性和methods方法 点击按钮，发现结果不及预期，数据虽然"},{"id":"525","title":"[Vue] 异常处理机制有哪些【热度: 435】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/525","page":"q/web框架-525.html","excerpt":"**关键词**：vue错误捕获、vue错误边界、vue异常处理、vue errorHandler Vue的错误处理机制主要包括以下几个方面： Error Capturing（错误捕获）：Vue提供了全局错误处理的钩子函数errorCaptured，可以在组件层级中捕获子组件产生的错误。通过在父组件中使用errorCap"},{"id":"524","title":"[Vue] vue3 的 diff 算法是什么，简单介绍一下【热度: 693】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/524","page":"q/web框架-524.html","excerpt":"**关键词**：vue3 diff 算法、逐层比较和双端比较 Vue3的diff算法是一种用于比较虚拟DOM树之间差异的算法。它用于确定需要更新的部分，以便最小化对实际DOM的操作，从而提高性能。 Vue3的diff算法采用了一种称为\"逐层比较\"的策略，即从根节点开始逐层比较虚拟DOM树的节点。具体的比较过程如下： 对"},{"id":"514","title":"[Vue] 组件之间的通信方式有哪些？【热度: 1,109】","category":"web框架","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/514","page":"q/web框架-514.html","excerpt":"**关键词**：vue组件通信、vue通信、Vuex组件通信、$refs组件通信 在Vue中 组件之间的通信总结 在Vue中，组件之间的通信可以通过以下几种方式实现： Props/Attributes：父组件通过向子组件传递属性（props），子组件通过props接收父组件传递的数据。这是一种单向数据流的方式。 Eve"},{"id":"505","title":"[React] 如何给 children 添加额外的属性【热度: 527】","category":"web框架","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/505","page":"q/web框架-505.html","excerpt":"**关键词**：cloneElement、children 添加额外属性 在 React 中，可以使用 React.cloneElement() 方法来给 children 添加额外的属性。 React.cloneElement(element, props, ...children) 其中，element 是需要克隆"},{"id":"504","title":"[React] hooks 和 memorizedState 是什么关系?【热度: 836】","category":"web框架","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/504","page":"q/web框架-504.html","excerpt":"**关键词**：memorizedState、添加和管理状态 **hooks 和 memorizedState 之间的关系** 在React中，Hooks是一种特殊的函数，用于在函数组件中添加和管理状态以及其他React特性。而memorizedState是React内部用于存储和管理Hooks状态的数据结构。 当你在"},{"id":"489","title":"[Vue] 你做过哪些性能优化【热度: 969】","category":"web框架","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/489","page":"q/web框架-489.html","excerpt":"**关键词**：vue 项目优化、vue 开发优化 1、v-if和v-show 频繁切换时使用v-show，利用其缓存特性 首屏渲染时使用v-if，如果为false则不进行渲染 2、v-for的key 列表变化时，循环时使用唯一不变的key，借助其本地复用策略 列表只进行一次渲染时，key可以采用循环的index 3、"},{"id":"488","title":"[Vue] Vue2.0 和 Vue3.0 有什么区别","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/488","page":"q/web框架-488.html","excerpt":"主要从以下方面做对比 响应式系统的重新配置，使用proxy替换Object.defineProperty typescript支持 新增组合API，更好的逻辑重用和代码组织 v-if和v-for的优先级 静态元素提升 虚拟节点静态标记 生命周期变化 打包体积优化 ssr渲染性能提升 支持多个根节点 参考文档: http"},{"id":"480","title":"讲一下Webpack设计理念（过于硬核， 直接上文档了）","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/480","page":"q/web框架-480.html","excerpt":"参考文档： https://juejin.cn/post/7170852747749621791"},{"id":"477","title":"[React] ref 有哪些使用场景，请举例【热度: 668】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/477","page":"q/web框架-477.html","excerpt":"**关键词**：ref 使用场景、ref 获取dom、ref 获取子组件属性和方法 React的ref用于获取组件或DOM元素的引用。它有以下几个常见的使用场景： 访问子组件的方法或属性：通过ref可以获取子组件的实例，并调用其方法或访问其属性。 获取DOM元素：通过ref可以获取组件渲染后的DOM元素，并进行操作。 "},{"id":"476","title":"[React] 函数组件和 class 组件有什么区别？【热度: 1,029】","category":"web框架","labels":["web框架","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/476","page":"q/web框架-476.html","excerpt":"**关键词**：React函数组件对比类组件、React函数组件对比类组件性能、React函数组件对比类组件状态管理、React函数组件与类组件 函数组件和类组件是React中两种定义组件的方式，它们有以下区别： 语法：函数组件是使用函数声明的方式定义组件，而类组件是使用ES6的class语法定义组件。 写法和简洁性："},{"id":"475","title":"[React] 合成事件和原生事件触发的先后顺序如何？【热度: 1,445】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/475","page":"q/web框架-475.html","excerpt":"**关键词**：React合成事件、原生事件、事件执行先后顺序 在React中，合成事件和原生事件的触发顺序是先合成事件，然后是原生事件。 React使用了一种称为\"合成事件\"的机制来处理事件。当你在组件中使用事件属性（例如onClick）时，React会在底层创建合成事件，并将其附加到相应的DOM元素上。合成事件是R"},{"id":"466","title":"[react] constructor 和 getInitialState 的区别?【热度: 785】","category":"web框架","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/466","page":"q/web框架-466.html","excerpt":"**关键词**：react constructor 作用、react getInitialState 作用、初始化 state 在 React 中，constructor 是一个类的构造函数，用于初始化类的成员变量和方法，这个函数不仅会在组件实例化时调用，还会在后续的组件更新时调用。而 getInitialState "},{"id":"465","title":"[react] 如何合理使用 useContext【热度: 1,326】","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/465","page":"q/web框架-465.html","excerpt":"**关键词**：合理使用 context 的层级、避免滥用 context、避免context引起重复渲染、优化context重复渲染 如何合理使用 useContext useContext 是 React 中提供的一种跨组件传递数据的方式，可以让我们在不同层级的组件之间共享数据，避免了繁琐的 props 传递过程。"},{"id":"464","title":"[react] 数组用useState做状态管理的时候，使用push，pop，splice等直接更改数组对象，会引起页面渲染吗？【热度: 488】","category":"web框架","labels":["web框架","快手"],"url":"https://github.com/pro-collection/interview-question/issues/464","page":"q/web框架-464.html","excerpt":"**关键词**：useState状态管理、push 直接更改数组对象、pop 直接更改数组对象、splice 直接更改数组对象 在React中，使用useState时使用push，pop，splice等直接更改数组对象是不推荐的做法，因为这种直接更改数组的方式会改变原始状态，React不会检测到这种状态变化，从而无法正"},{"id":"463","title":"[vue] vue2.x 响应式原理是什么【热度: 669】","category":"web框架","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/463","page":"q/web框架-463.html","excerpt":"**关键词**：vue响应式、Observe、Compile、Watcher Vue.js 的响应式原理主要是通过数据劫持（Object.defineProperty()）实现。当我们在Vue实例中定义了一个 data 属性时，Vue 会对这个属性进行劫持，即在getter和setter时做一些操作。 具体实现流程如下"},{"id":"396","title":"[vue] vue3 相比较于 vue2 在编译阶段有哪些改进","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/396","page":"q/web框架-396.html","excerpt":"Vue 3 在编译阶段相对于 Vue 2 进行了一些重要的改进，主要包括以下几个方面： 静态模板提升（Static Template Hoisting）：Vue 3 引入了静态模板提升技术，通过对模板进行分析和优化，将模板编译为更简洁、更高效的渲染函数。这种优化可以减少不必要的运行时开销，并提高组件的渲染性能。 Fra"},{"id":"395","title":"[vue] vue3 性能提升主要是体现在哪些方面【热度: 324】","category":"web框架","labels":["web框架","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/395","page":"q/web框架-395.html","excerpt":"**关键词**：vue3 性能提升、vue3 编译优化、vue3 初始化优化、vue3 Tree-shaking支持、vue3 虚拟DOM优化 Vue 3.0在性能方面进行了多项改进和优化，主要体现在以下几个方面： 响应式系统优化：Vue 3.0使用了基于Proxy的响应式系统，相比Vue 2.x中的Object.de"},{"id":"392","title":"[React] react-router 页面跳转时，是如何传递下一个页面参数的？","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/392","page":"q/web框架-392.html","excerpt":"路由数据 React Router 是一个用于管理前端路由的库，它与 React 应用程序集成在一起，提供了一种在单页面应用中处理路由的方式。React Router 并没有直接提供数据存储的功能，它主要负责路由的匹配和导航。 在 React Router 中，路由相关的数据主要存储在组件的 props 和组件的状态中"},{"id":"382","title":"[vue] render 函数了解吗？【热度: 244】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/382","page":"q/web框架-382.html","excerpt":"**关键词**：vue render 函数 render 函数 在Vue.js中，render是一个用于生成虚拟DOM（VNode）树的函数。它是Vue.js的渲染函数，负责将组件的模板转换为可渲染的VNode树。 render函数接收一个上下文对象作为参数，该对象包含了渲染过程中需要的数据和方法。在render函数中"},{"id":"381","title":"[vue] vue 是如何识别和解析指令【热度: 477】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/381","page":"q/web框架-381.html","excerpt":"**关键词**：vue 指令 vue 是如何识别和解析指令的， 详细解释一下 Vue.js在识别和解析指令时，使用了编译器（Compiler）来完成这个过程。下面是Vue.js识别和解析指令的详细步骤： 解析模板：首先，Vue.js会将模板代码转换为抽象语法树（AST）。这个过程由Vue.js的编译器完成。编译器会遍历"},{"id":"380","title":"[vue] vue 是怎么解析template的? template会变成什么?【热度: 175】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/380","page":"q/web框架-380.html","excerpt":"**关键词**：[vue] template 解析 Vue.js在解析和编译模板时，会经过以下过程： 解析模板：Vue.js使用自定义的HTML解析器将模板解析成抽象语法树（AST）。解析器会分析模板中的HTML标记、指令、表达式和事件等内容，并构建出一颗表示模板结构的AST。 静态优化：在生成AST的过程中，Vue."},{"id":"374","title":"Antd（Ant Design）的 Tooltip 组件是如何实现的？","category":"web框架","labels":["web框架","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/374","page":"q/web框架-374.html","excerpt":"Antd（Ant Design）的 Tooltip 组件是通过 CSS 和 JavaScript 结合实现的。 在 CSS 方面，Tooltip 组件使用了绝对定位和一些样式规则来定义 Tooltip 的外观。它通常包括一个触发元素和一个浮动在触发元素旁边的提示框。通过设置样式属性，如 position: absolu"},{"id":"370","title":"[React] createContext 和 useContext 有什么区别， 是做什么用的【热度: 367】","category":"web框架","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/370","page":"q/web框架-370.html","excerpt":"**关键词**：createContext useContext、useContext 使用、createContext 使用 createContext 和 useContext createContext和useContext是React中用于处理上下文（Context）的两个钩子函数，它们用于在组件之间共享数据。"},{"id":"349","title":"[React] memo 和 useMemo 有和区别？【热度: 654】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/349","page":"q/web框架-349.html","excerpt":"**关键词**：memo useMemo React.memo 和 useMemo 是在 React 中处理性能优化的两个工具，虽然它们名称相似，但是它们的作用和使用方法是不同的。 React.memo 是高阶组件，它可以用来优化函数组件的渲染性能。它会比较当前组件的 props 和 state 是否发生了变化，如果都"},{"id":"344","title":"[React] createPortal 了解多少？【热度: 597】","category":"web框架","labels":["web框架","网易"],"url":"https://github.com/pro-collection/interview-question/issues/344","page":"q/web框架-344.html","excerpt":"**关键词**：react createPortal createPortal 是 React 中一个用于将子元素渲染到指定 DOM 元素下的 API。 在 React 应用中，通常会通过组件树传递 props、状态等数据来渲染 UI，并由 React 自动管理 DOM 元素的创建、更新和销毁等操作。不过，有时我们需要"},{"id":"343","title":"[React] createElement 和 cloneElement 有什么区别【热度: 218】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/343","page":"q/web框架-343.html","excerpt":"**关键词**：createElement cloneElement createElement 和 cloneElement 有什么区别? React 中的 createElement 和 cloneElement 都可以用来创建元素，但它们用法有所不同。 createElement 用于在 React 中动态地创建"},{"id":"336","title":"[React] 事件绑定原理【热度: 1,097】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/336","page":"q/web框架-336.html","excerpt":"**关键词**：react事件绑定、react合成事件、react事件监听 绑定原理与过程 在 React 中，事件绑定不同于传统的直接在 HTML 元素添加事件监听器的方式。React 的事件绑定是建立在自定义组件上的，因此需要对 React 组件的生命周期进行理解。 React 事件绑定的原理可以概括为三个步骤： "},{"id":"327","title":"[React] fiber 是如何实现时间切片的？【热度: 587】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/327","page":"q/web框架-327.html","excerpt":"**关键词**：react16 架构、react Reconciler、fiber 时间切片、fiber 时间、react 协调器 基本原理 本质上来说就是将渲染任务拆分成多个小任务，以便提高应用程序的响应性和性能。React Fiber 实现时间切片主要依赖于两个核心功能：**任务分割和任务优先级**。 任务分割是指"},{"id":"326","title":"[React] diff 算法【热度: 538】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/326","page":"q/web框架-326.html","excerpt":"**关键词**：react16 架构、react Reconciler、react commit 阶段、react 协调器 在 react 中：一个DOM节点在某一时刻最多会有4个节点和他相关。 一个DOM节点在某一时刻最多会有4个节点和他相关。 JSX对象。即ClassComponent的render方法的返回结果，"},{"id":"325","title":"[React] commit 阶段的执行过程【热度: 534】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/325","page":"q/web框架-325.html","excerpt":"**关键词**：react16 架构、react Reconciler、react commit 阶段、react 协调器 commitRoot方法是commit阶段工作的起点。fiberRootNode会作为传参。 commitRoot(root); 如何走到 commit 阶段的， 可以参考这个文档：https:/"},{"id":"324","title":"[React] render 阶段的执行过程【热度: 1,793】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/324","page":"q/web框架-324.html","excerpt":"**关键词**：react16 架构、react Reconciler、react fiber、react 协调器 render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。 可以看到，他们唯一的区别是是否"},{"id":"323","title":"[React] Fiber的含义与数据结构【热度: 1,778】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/323","page":"q/web框架-323.html","excerpt":"**关键词**：react16 架构、react Reconciler、react fiber、react 协调器 Fiber的含义 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fi"},{"id":"322","title":"[React] fiber 架构 的工作原理？【热度: 1,774】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/322","page":"q/web框架-322.html","excerpt":"**关键词**：react16 架构、react Reconciler、react fiber、react 协调器 双缓存Fiber树 如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。 为了解决这个问题， 就有了图像处理中的**双缓存技术**。 双缓存是一种技术，用于在图像处"},{"id":"320","title":"[React] React Reconciler 为何要采用 fiber 架构？【热度: 1,794】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/320","page":"q/web框架-320.html","excerpt":"**关键词**：react16 架构、react Reconciler、react fiber、react 协调器 代数效应的实践 React中做的就是践行代数效应（Algebraic Effects）。 简单点儿来说就是： **用于将副作用从函数调用中分离。** 举例子： 比如我们要获取用户的姓名做展示： 代码如上，"},{"id":"319","title":"[React] React16 是什么样的架构特点？【热度: 2,403】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/319","page":"q/web框架-319.html","excerpt":"**关键词**：react16 架构、react Reconciler、react fiber、react 渲染器、react 协调器 React16架构可以分为三层： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Re"},{"id":"318","title":"[React] React15 架构存在什么样的问题？【热度: 1,613】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/318","page":"q/web框架-318.html","excerpt":"**关键词**：react15 架构、react 架构、react Reconciler、react 渲染器、react 协调器 React15 架构可以分为两层： Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Reconciler（协调器） 我们"},{"id":"317","title":"[React] react 是如何实现页面的快速响应？【热度: 696】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/317","page":"q/web框架-317.html","excerpt":"**关键词**：react 快速响应实现、react 可中断更新、react IO瓶颈、react CPU瓶颈 react 是如何实现快速响应的？ 我们日常使用App，浏览网页时，有两类场景会制约快速响应： 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。 发送网络请求后，由于需要等待数据返回才能进一步操作导"},{"id":"306","title":"[React] 如何监听路由变化？【热度: 679】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/306","page":"q/web框架-306.html","excerpt":"**依赖** react-router-dom v6 react v18 实现 监听的核心原理基于useEffect，和useLocation，通过useEffect监听当前location的变化，这样就实现的最基本的监听结构： 然后，我们可以在useEffect中记录和更新from、to的值，可以根据自己的需要选择f"},{"id":"305","title":"[React] 开发过程中有哪些性能优化手段？【热度: 1,511】","category":"web框架","labels":["web框架","小米"],"url":"https://github.com/pro-collection/interview-question/issues/305","page":"q/web框架-305.html","excerpt":"路由懒加载 两种方式可实现: 使用 React 中 Suspense,lazy 使用 react-loadable React 中 Suspense,lazy 应用的组件需要使用 lazy 的方式引入， 且使用 Suspense 包裹异步加载的组件 react-loadable 受控性组件颗粒化 ，独立请求服务渲染单元"},{"id":"304","title":"[React] ref 是如何拿到函数组件的实例【热度: 881】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/304","page":"q/web框架-304.html","excerpt":"使用forwordRef 将input单独封装成一个组件TextInput。 用TextInputWithFocusButton调用它 useImperativeHandle 有时候，我们可能**不想将整个子组件暴露给父组件**，而只是暴露出父组件需要的值或者方法，这样可以让代码更加明确。而useImperativeH"},{"id":"302","title":"[React] Hooks 有哪些？【热度: 2,594】","category":"web框架","labels":["web框架","美团"],"url":"https://github.com/pro-collection/interview-question/issues/302","page":"q/web框架-302.html","excerpt":"react 16.8 hooks useState useEffect useContext useReducer useMemo useCallback useRef useImperativeHandle useLayoutEffect useDebugValue React v18中的hooks useSyncE"},{"id":"301","title":"[React] 生命周期有哪些？【热度: 889】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/301","page":"q/web框架-301.html","excerpt":"主要生命周期分为两个版本， 分别是： v16.0前 和 v16.4 v16.0 前 总共分为**四大阶段**： {初始化| Intialization} {挂载| Mounting} {更新| Update} {卸载| Unmounting} Intialization(初始化） 在初始化阶段,会用到 construc"},{"id":"299","title":"[React] React 18 的新特性有哪些【热度: 989】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/299","page":"q/web框架-299.html","excerpt":"18 的新特性 新功能：自动批量处理 批量处理是指 React 将多个状态更新分组到一个重新渲染中，以获得更好的性能。如果没有自动批量处理，我们只对 React 事件处理程序中的更新进行批量处理。默认情况下，React 不会对 Promise、setTimeout、原生事件处理程序或任何其它事件中的更新进行批量处理。有"},{"id":"295","title":"[React] forwardRef 作用是什么？【热度: 2,628】","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/295","page":"q/web框架-295.html","excerpt":"forwardRef 是 React 提供的一个高阶函数，它可以让你在函数组件中访问子组件的 ref，并把该 ref 传递给子组件。 使用 forwardRef 的主要场景是，当你需要访问子组件的 DOM 节点或实例时，比如要操作子组件的滚动条、聚焦输入框等等。在这些场景下，需要用到 ref，而 ref 又不能直接在函"},{"id":"290","title":"[React] useState 是如何实现的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/290","page":"q/web框架-290.html","excerpt":"hooks 的实现原理 流程图如下：renderWithHooks 根据current来判断当前是首次渲染还是更新。 hooks加载时调用对应的mount函数，更新时调用对应的update函数。 hooks生成单向链表，通过next连接，最后一个next指向null。 state hooks会生成update循环链表，"},{"id":"286","title":"[React] 父组件调用子组件的方法","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/286","page":"q/web框架-286.html","excerpt":"在React中，我们经常在子组件中调用父组件的方法，一般用props回调即可。但是有时候也需要在父组件中调用子组件的方法，通过这种方法实现高内聚。有多种方法，请按需服用。 类组件中 React.createRef() 优点：通俗易懂，用ref指向。 缺点：使用了HOC的子组件不可用，无法指向真是子组件 比如一些常用的写"},{"id":"285","title":"[React] Hooks 实现原理是什么, 简单描述一下","category":"web框架","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/285","page":"q/web框架-285.html","excerpt":"在探索 useEffect 原理的时候，一直被一个问题困扰：useEffect 作用和用途是什么？当然，用于函数的副作用这句话谁都会讲。举个例子吧： 这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。**但这并不是必要的**。完全可以不使用useEffect，直接使用setTimeout，并且它的"},{"id":"277","title":"[Vue] watch 和 computed 的区别和理解","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/277","page":"q/web框架-277.html","excerpt":"**计算属性computed :** 支持缓存，只有依赖数据发生改变，才会重新进行计算，计算属性可用于快速计算视图（View）中显示的属性。这些计算将被缓存，并且只在需要时更新。computed是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed的值在getter执行后是"},{"id":"272","title":"[Vue] vue3 的响应式库是独立出来的，它单独使用的时候是什么效果","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/272","page":"q/web框架-272.html","excerpt":"vue3 的响应式库是独立出来的，它可以很方便的集成进 React， 作为 React 的状态管理库使用！ 使用示范 定义 store 消费使用 可以看出，store的定义只用到了@vue/reactivity，而rxv只是在组件中做了一层桥接，连通了Vue3和React，正如它名字的含义：React x Vue。 如"},{"id":"271","title":"[Vue] Vue3 的响应式原理?","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/271","page":"q/web框架-271.html","excerpt":"该话题涉及的相关内容 原理：Proxy、track、trigger 新增属性 遍历后新增 遍历后删除或者清空 获取 keys 删除对象属性 判断属性是否存在 性能 推荐阅读文档： https://juejin.cn/post/6844904122479542285 响应式仓库 Vue3 不同于 Vue2 也体现在源码结"},{"id":"269","title":"前端路由的实现原理","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/269","page":"q/web框架-269.html","excerpt":"在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。 前端路由的实现原理简单来说，就是在不跳转或者刷新页面的前提下，为SPA应用中的每个视图匹配一个特殊的U"},{"id":"268","title":"[Vue] 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/268","page":"q/web框架-268.html","excerpt":"Vue 并没有在源码中做代理 vue 并没有在源码中做代理， 至少是 2.x 是没有做事件代理的。但是理论上来说使用事件代理性能会更好一点。 阅读 vue 源码的过程中，并没有发现 vue 会自动做事件代理，但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会"},{"id":"261","title":"[Vue] 使用Proxy实现简易的vue双向数据绑定","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/261","page":"q/web框架-261.html","excerpt":"proxy 的基本使用 可以直接看这个链接： https://github.com/pro-collection/interview-question/issues/8 使用proxy实现数据劫持 关于vue中数据响应式的原理 对数据进行侦测 在vue2.X中，实现一个observe类，对于对象数据，通过Object."},{"id":"257","title":"[React] 为什么不能在循环、条件或嵌套函数中调用 Hooks？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/257","page":"q/web框架-257.html","excerpt":"如果在条件语句中使用hooks，React会抛出 error。 这与React Hooks的底层设计的数据结构相关，先抛出结论：**react用链表来严格保证hooks的顺序**。 一个典型的useState使用场景： 那么hooks在这两条语句分别作了什么？ 上图是 useState 首次渲染的路径，其中，跟我们问题"},{"id":"242","title":"[Redux] react-redux 是如何更新到 UI 的, 写一下这部分的核心源码","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/242","page":"q/web框架-242.html","excerpt":"react-redux 和 redux 的关系 Redux 和 React-Redux 是两个独立的库，但它们通常一起使用，因为 Redux 库本身并不针对 React，而是一个通用的状态管理库，而 React-Redux 则是一个用于将 Redux 集成到 React 应用程序中的库。 React-Redux 提供了"},{"id":"241","title":"[Redux] 简单实现一下核心源码","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/241","page":"q/web框架-241.html","excerpt":"实现 Redux 的源码主要包括以下几个步骤： 实现 createStore 函数，创建 store 对象，该函数接收一个 reducer 函数作为参数，返回一个对象。 在 createStore 函数内部，定义一个 state 变量来存储当前的状态值，定义一个 listeners 数组来存储所有的监听函数。 实现 g"},{"id":"240","title":"[Redux] 的存储过程","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/240","page":"q/web框架-240.html","excerpt":"Redux 的存储过程可以简单地分为以下几个步骤： Action Creator 函数被调用，生成一个 Action 对象； Action 对象被传递给 Store.dispatch() 方法； Redux Store 调用 Reducer 函数，将当前的 State 和 Action 作为参数传入； Reducer "},{"id":"217","title":"[Vue] 响应式原理中 Object.defineProperty 有什么缺陷","category":"web框架","labels":["web框架","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/217","page":"q/web框架-217.html","excerpt":"Vue 2 中使用Object.defineProperty来实现其响应式系统存在一些限制和问题： **深度检测**： Vue 2中对于对象的处理是递归的；对于每个属性，Vue会逐层使用Object.defineProperty将其转换成 getter/setter。这样，当你访问或修改嵌套较深的属性时（如a.b.c）"},{"id":"215","title":"[Vue] 双向绑定和单向数据流原则是否冲突？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/215","page":"q/web框架-215.html","excerpt":"Vue 的双向绑定和单向数据流原则不冲突，因为它们是针对不同的场景和目的而提出的。 Vue 的双向绑定是指，在模板中通过 v-model 指令可以实现表单元素和组件数据之间的双向绑定，当表单元素的值发生变化时，组件数据也会同步更新；反过来，当组件数据发生变化时，表单元素的值也会同步更新。这种双向绑定的机制可以减少手动编"},{"id":"209","title":"[Redux] 为什么 Redux 的 reducer 中不能做异步操作？","category":"web框架","labels":["web框架","百度"],"url":"https://github.com/pro-collection/interview-question/issues/209","page":"q/web框架-209.html","excerpt":"Redux 的 reducer 是纯函数，它的作用是接收一个旧的状态和一个操作，返回一个新的状态，是一个纯粹的状态转换函数，因此在 reducer 中不能执行异步操作，否则会破坏 reducer 的纯函数特性。如果在 reducer 中执行异步操作，会导致 reducer 不可预测和不可重现，因为异步操作的结果是不确定"},{"id":"179","title":"[React] useEffect的第二个参数，如何判断依赖是否发生变化？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/179","page":"q/web框架-179.html","excerpt":"useEffect的第二个参数是一个依赖数组，用于判断副作用函数的依赖是否发生变化。React使用JavaScript的Object.is方法来判断依赖项是否发生变化。在比较依赖项时，React首先检查依赖项的值是否相等。如果依赖项的值是引用类型，React会比较它们的引用地址，而不是比较它们的属性值。因此，在比较引用"},{"id":"178","title":"[React] useRef、ref、forwardsRef 的区别是什么?","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/178","page":"q/web框架-178.html","excerpt":"在 React 中，ref 是一种用于访问 DOM 元素或组件实例的方法，useRef 和 forwardRef 是 ref 的两个相关 Hook 和高阶组件。 ref：ref 是 React 中用于访问 DOM 元素或组件实例的方法。在函数组件中，可以使用 useRef Hook 来创建一个 ref 对象，然后将其传"},{"id":"173","title":"为什么小程序里拿不到dom相关的api","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/173","page":"q/web框架-173.html","excerpt":"小程序为了追求更高的性能和更好的安全性，采用了类Webview的渲染方案，并使用了自己的渲染引擎，与浏览器的渲染引擎不同。因此，小程序的API和浏览器的API并不完全相同。 在小程序中，开发者可以使用WXML语言构建页面，WXML是一种类似HTML的标记语言，但并不是真正的HTML。小程序中的组件是由开发者提前定义好的"},{"id":"171","title":"[Vue] 响应式数据流驱动页面 和 传统的事件绑定命令式驱动页面， 有何优劣？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/171","page":"q/web框架-171.html","excerpt":"Vue 响应式数据流驱动页面和传统的事件绑定命令式驱动页面是两种不同的前端开发方式，它们的优劣势主要体现在代码编写方式、页面效果、开发效率和维护难度上。 响应式数据流驱动页面：Vue 使用响应式的数据流来驱动页面的渲染和更新。Vue 的响应式系统会自动侦测数据的变化，并且重新渲染页面，开发者只需要专注于数据和页面的关系"},{"id":"169","title":"[koa] body-parser 中间件实现原理？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/169","page":"q/web框架-169.html","excerpt":"Koa 中间件 koa-bodyparser 的原理是将 HTTP 请求中的 request body 解析成 JavaScript 对象，并将其挂载到 ctx.request.body 属性上，方便后续的处理。 具体来说，koa-bodyparser 中间件会监听 HTTP 请求的 data 事件和 end 事件，然"},{"id":"168","title":"[koa] 在没有async await 的时候, koa是怎么实现的洋葱模型？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/168","page":"q/web框架-168.html","excerpt":"在没有 async/await 的时候，Koa 通过使用 ES6 的生成器函数来实现洋葱模型。具体来说，Koa 中间件函数是一个带有 next 参数的生成器函数，当中间件函数调用 next 方法时，它会挂起当前的执行，转而执行下一个中间件函数，直到执行完最后一个中间件函数，然后将执行权返回到前一个中间件函数，继续执行下"},{"id":"164","title":"[koa] 中间件的异常处理是怎么做的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/164","page":"q/web框架-164.html","excerpt":"在 Koa 中，中间件函数的异常处理可以通过两种方式来实现： 使用 try...catch 捕获异常：在中间件函数中使用 try...catch 语句来捕获异常，然后通过 ctx.throw() 方法抛出异常信息，例如： 在这个例子中，await next() 表示调用下一个中间件函数，如果这个函数抛出异常，就会被捕获"},{"id":"161","title":"如何实现洋葱模式？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/161","page":"q/web框架-161.html","excerpt":"**思路** 首先调用 use 方法收集中间件，调用 listen 方法执行中间件。 每一个中间件都有一个next参数（暂时不考虑ctx参数），next参数可以控制进入下一个中间件的时机。 **需要解决的问题** 最后一个中间件调用next如何处理 如何解决同一个中间件多次调用next **完整代码** 其中最精华的部"},{"id":"160","title":"什么是洋葱模型？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/160","page":"q/web框架-160.html","excerpt":"说到洋葱模型，就必须聊一聊中间件，中间件这个概念，我们并不陌生，比如平时我们用的 redux、express 、koa 这些库里，都离不开中间件。 那 koa 里面的中间件是什么样的呢？其本质上是一个函数，这个函数有着特定，单一的功能，koa将一个个中间件注册进来，通过**组合**实现强大的功能。 先看 demo ： "},{"id":"159","title":"[Vue] 父子组件通信方式有哪些？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/159","page":"q/web框架-159.html","excerpt":"Vue 父子组件通信 Prop（常用） $emit (组件封装用的较多) .sync语法糖 （较少） $attrs & $listeners (组件封装用的较多) provide & inject （高阶组件/组件库用的较多） slot-scope & v-slot （vue@2.6.0+）新增 scopedSlots"},{"id":"144","title":"[vue] 是怎么解析template的?","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/144","page":"q/web框架-144.html","excerpt":"整体流程图： 参考文档： $1 $1 $1"},{"id":"143","title":"[vue] 双向数据绑定原理?","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/143","page":"q/web框架-143.html","excerpt":"在目前的前端面试中，vue的双向数据绑定已经成为了一个非常容易考到的点，即使不能当场写出来，至少也要能说出原理。本篇文章中我将会仿照vue写一个双向数据绑定的实例，名字就叫myVue吧。结合注释，希望能让大家有所收获。 1、原理 Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过Object对象的define"},{"id":"135","title":"【React】绑定事件的原理是什么？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/135","page":"q/web框架-135.html","excerpt":"在 React 中，绑定事件的原理是基于合成事件（SyntheticEvent）的机制。合成事件是一种由 React 自己实现的事件系统，它是对原生 DOM 事件的封装和优化，提供了一种统一的事件处理机制，可以跨浏览器保持一致的行为。 当我们在 React 组件中使用 onClick 等事件处理函数时，实际上是在使用合"},{"id":"134","title":"【React】合成事件了解多少","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/134","page":"q/web框架-134.html","excerpt":"在 React 中，合成事件是一种封装了浏览器原生事件对象的高级事件机制。它是由 React 提供的一种用于处理事件的抽象层，可以让开发者更方便地处理和管理事件。 React 的合成事件机制提供了一些优秀的特性： 跨浏览器兼容性：React 的合成事件可以屏蔽浏览器的差异，保证在各种浏览器上运行一致。 性能优化：Rea"},{"id":"133","title":"react 18 版本中 setState 是同步还是异步的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/133","page":"q/web框架-133.html","excerpt":"在 React 18 中，setState 的行为仍然是异步的。React 团队并没有改变 setState 的默认行为，因为这会带来一些潜在的性能问题和不确定性。异步更新状态可以让 React 在适当的时候批量更新组件状态，从而避免过多的渲染和浏览器的性能问题。 但是，React 18 引入了一个新的特性：批量更新（"},{"id":"132","title":"React setState 是同步还是异步的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/132","page":"q/web框架-132.html","excerpt":"在 React 中，setState 方法有时是异步的，有时是同步的，具体取决于使用方式和环境。 当我们在 React 中调用 setState 方法时，React 会将新状态合并到组件的状态队列中，并在未来的某个时间更新组件的状态。这个更新过程是异步的，即不能保证在 setState 调用后立即更新状态，而是会将状态"},{"id":"131","title":"react lazy import 实现懒加载的原理是什么？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/131","page":"q/web框架-131.html","excerpt":"React 的 lazy 函数可以实现代码分割，即将代码按需加载，以达到优化页面加载速度的目的。它的原理是基于 JavaScript 的动态 import() 方法实现的。 当我们使用 lazy 函数加载一个组件时，React 会自动将该组件的代码单独打包成一个单独的 JavaScript 文件，并在需要时通过网络请求"},{"id":"130","title":"react 遍历渲染节点列表， 为什么要加 key ?","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/130","page":"q/web框架-130.html","excerpt":"在 React 中，当我们使用数组渲染节点列表时，通常需要给每个节点添加一个 key 属性，这是因为 React 需要通过 key 属性来判断是否需要更新某个节点，从而提高渲染性能。 具体来说，React 在进行更新时，会根据 key 属性来判断哪些节点需要更新，哪些节点需要删除，哪些节点需要新增。如果两个节点的 ke"},{"id":"128","title":"axios的拦截器原理及应用、简单手写核心逻辑？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/128","page":"q/web框架-128.html","excerpt":"axios 拦截器的使用 Axios 是一个基于 Promise 的 HTTP 客户端库，可以用于浏览器和 Node.js 环境中发送 HTTP 请求。Axios 提供了拦截器机制，可以在请求发送前和响应返回后对请求和响应进行拦截和处理，从而实现一些通用的功能，例如：添加请求头、添加认证信息、显示 loading 状态"},{"id":"124","title":"Vue 中 $nextTick 作用与原理是啥？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/124","page":"q/web框架-124.html","excerpt":"$nextTick 是 Vue.js 提供的一个实例方法，用于在 DOM 更新之后执行一些操作。具体来说，它会将回调函数推迟到下次 DOM 更新循环之后执行。 在 Vue 中，数据变化时，Vue 会异步执行视图更新。例如，当一个数据变化时，Vue 会将这个变化包装成一个更新任务，并将其推入更新队列。Vue 会在下一个事"},{"id":"119","title":"vue 的 keep-alive 的原理是啥？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/119","page":"q/web框架-119.html","excerpt":"<keep-alive> 是 Vue.js 提供的一个抽象组件，它可以使被包含的组件保留在内存中，而不是每次重新渲染的时候销毁并重建，从而提高了应用的性能。 具体来说，<keep-alive> 的实现原理如下： 当一个组件被包裹在 <keep-alive> 组件内时，它会被缓存起来，而不是被销毁。 如果这个组件被包裹的"},{"id":"114","title":"Vue3.0 实现数据双向绑定的方法是什么？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/114","page":"q/web框架-114.html","excerpt":"Vue3.0 通过使用 Composition API 中的 reactive 和 ref 函数来实现数据双向绑定。 reactive 函数 reactive 函数是 Vue3.0 中用来创建响应式对象的函数。将一个 JavaScript 对象传递给 reactive 函数，它会返回一个新的响应式对象。响应式对象是一个"},{"id":"113","title":"React Router 中 HashRouter 和 BrowserRouter 的区别和原理？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/113","page":"q/web框架-113.html","excerpt":"React Router 是一个流行的第三方库，它允许在 React 应用程序中实现路由功能。React Router 支持两种路由方式：HashRouter 和 BrowserRouter。 HashRouter HashRouter 使用 URL 中的 hash 部分（即 #）来实现路由。在 React 中，可以使"},{"id":"90","title":"redux-thunk 和 redux 是什么关系？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/90","page":"q/web框架-90.html","excerpt":"理解redux和redux的中间件redux-thunk 目录 $1 $1 $1 $1 $1 $1 $1 Action的认识 简单点说Action就是一个对象，一个必须带key为type的对象[value是自己定义的]，其他的key就根据用户自己喜好自己定义: 以下都是action的定义 Reducer的认识 别主观意"},{"id":"83","title":"react和vue的区别？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/83","page":"q/web框架-83.html","excerpt":"Vue与React的对比 文档转自：https://blog.csdn.net/CystalVon/article/details/78428036 Vue.js与React.js从某些反面来说很相似，通过两个框架的学习，有时候对一些用法会有一点思考，为加深学习的思索，特翻阅了两个文档，从以下各方面进行了对比，加深了对"},{"id":"80","title":"[Redux]: 看过 Redux 源码吗， 对 Redux 了解多少？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/80","page":"q/web框架-80.html","excerpt":"深入Redux架构 目录： $1 $1 $1 $1 $1 参考文章：$1 <div id=\"01\">1、关于redux</div> 1.1、什么情况需要用redux？ 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket Vie"},{"id":"79","title":"[vue]: 是如何实现 MVVM 的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/79","page":"q/web框架-79.html","excerpt":"引入：使用jquery和其他框架的区别 原生JS实现一个todo-list vue实现todo-list 两者之间的区别 数据和视图分离(开放封闭原则： 扩展开放，修改封闭) 数据驱动视图 对mvvm的理解 具体的理解自己再去整理 MVVM框架的三大要素： 响应式、模板引擎、渲染 响应式的实现 修改data属性之后，立"},{"id":"78","title":"[vue]: vue2.x 虚拟 dom 是怎么实现的？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/78","page":"q/web框架-78.html","excerpt":"virtual-dom 实现之一: snabbdom vue2.0就是使用的snabbdom 一个简单的使用实例： snabbdom 核心api snabbdom.init: The core exposes only one single function snabbdom.init. This init takes"},{"id":"75","title":"[vue]: 手写 vue 双向绑定？","category":"web框架","labels":["web框架"],"url":"https://github.com/pro-collection/interview-question/issues/75","page":"q/web框架-75.html","excerpt":"双向绑定核心知识点 如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示："},{"id":"1148","title":"Nginx 如何为不同前端资源配置缓存策略？如何强制刷新特定资源？【热度: 110】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1148","page":"q/web应用场景-1148.html","excerpt":"**关键词**：nginx 加载特定资源 Nginx 为不同前端资源配置缓存策略的核心是**根据资源特性（是否常变、是否带版本标识）差异化设置缓存规则**，同时通过特定机制实现特定资源的强制刷新。以下是详细方案： 一、按资源类型配置差异化缓存策略 前端资源可分为**静态资源**（JS、CSS、图片等）和**入口文件**"},{"id":"1147","title":"前端静态资源加载超时，Nginx 可通过哪些配置优化？【热度: 190】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1147","page":"q/web应用场景-1147.html","excerpt":"**关键词**：nginx 加载超时优化 前端静态资源（如 JS、CSS、图片、视频等）加载超时，通常与**网络传输效率**、**服务器响应速度**或**资源处理策略**相关。Nginx 可通过针对性配置优化传输效率、延长超时阈值、减少阻塞风险，从而解决超时问题。以下是具体优化方案： 一、延长关键超时时间（避免传输中断"},{"id":"1146","title":"Nginx 配置 HTTPS 需哪些核心项（协议、加密套件）？如何强制 HTTP 跳转 HTTPS？【热度: 182】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1146","page":"q/web应用场景-1146.html","excerpt":"**关键词**：nginx 配置 https Nginx 配置 HTTPS 需重点关注协议版本、加密套件、证书配置等核心项，同时需正确设置 HTTP 到 HTTPS 的强制跳转。以下是详细配置方案： 一、HTTPS 核心配置项（协议、加密套件等） HTTPS 配置的核心目标是**确保安全性**（禁用不安全协议和加密套件"},{"id":"1145","title":"微前端通过 Nginx 实现主 / 子应用路由分发，如何配置 location 和 try_files？需处理哪些资源路径问题？【热度: 120】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1145","page":"q/web应用场景-1145.html","excerpt":"微前端通过 Nginx 实现主/子应用路由分发时，核心是通过 location 匹配不同应用的路由路径，并结合 try_files 处理 SPA 路由刷新 404 问题。同时需解决子应用资源路径、主/子应用路由冲突等关键问题。以下是具体实现方案： 一、基础场景：主应用与子应用通过路径前缀区分 假设： 主应用路由：htt"},{"id":"1144","title":"如何通过 Nginx 配置前端静态资源的 “hash 资源永久缓存 + 非 hash 资源协商缓存”？【热度: 75】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1144","page":"q/web应用场景-1144.html","excerpt":"**关键词**：nginx 资源缓存 要实现前端前端静态资源的“hash 资源永久缓存 + 非 hash 资源协商缓存”，需结合 Nginx 的缓存头配置，针对不同类型资源设计差异化策略。核心思路是：**对带 hash 的指纹文件（如app.8f3b.js）设置长期强缓存，对无 hash 的文件（如index.html"},{"id":"1143","title":"Nginx 配置 gzip/brotli 压缩时需考虑哪些因素？为何不建议对所有前端资源开启压缩？【热度: 106】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1143","page":"q/web应用场景-1143.html","excerpt":"**关键词**：nginx 配置资源压缩 在 Nginx 中配置 gzip 或 brotli 压缩时，需综合考虑**压缩效率、服务器性能开销、客户端兼容性**等核心因素；而不建议对所有前端资源开启压缩，本质是避免“无效压缩”（压缩后体积无明显减小）和“反向损耗”（压缩耗时 > 传输耗时）。以下是具体分析： 一、配置 g"},{"id":"1142","title":"Nginx 如何按资源类型（如.js/.png）分发到不同服务器？配置策略是什么？【热度: 159】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1142","page":"q/web应用场景-1142.html","excerpt":"**关键词**：nginx 转发 Nginx 可以通过 location 指令匹配不同资源类型（如 .js、.png），并将请求分发到不同服务器，实现资源的分类部署和负载均衡。这种配置策略适合将静态资源（JS、图片）与动态资源（API）分离部署，提升整体服务性能。 一、核心配置策略：按文件后缀匹配并转发 通过 loca"},{"id":"1141","title":"Nginx 如何配置支持前端大资源的 Range 分片请求？核心参数是什么？【热度: 146】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1141","page":"q/web应用场景-1141.html","excerpt":"**关键词**：nginx 配置分片请求 Nginx 支持前端大资源（如视频、大型压缩包等）的 Range 分片请求，主要通过配置实现对 HTTP 范围请求的支持，允许客户端分段块下载资源，提升大文件传输效率。以下是具体配置方法和核心参数解析： 一、Range 分片请求的原理 HTTP 协议的 Range 请求头允许客"},{"id":"1140","title":"Nginx 如何通过 include 或 vhost 实现前端多环境隔离？同域名不同路径映射需解决哪些重写问题？【热度: 112】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1140","page":"q/web应用场景-1140.html","excerpt":"**关键词**：nginx 多环境隔离 Nginx 可以通过 include 指令或虚拟主机（vhost）实现前端多环境（如开发、测试、生产）的隔离部署，同时针对同域名不同路径的映射场景，需要处理路径重写和资源引用问题。以下是具体实现方案和注意事项： 一、通过 include 或 vhost 实现多环境隔离 多环境隔离"},{"id":"1139","title":"Nginx 中 proxy_pass 路径结尾加 / 与不加 /，对前端接口代理路径有何差异？举例说明。【热度: 106】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1139","page":"q/web应用场景-1139.html","excerpt":"**关键词**：nginx proxy_pass Nginx 中 proxy_pass 路径结尾是否加 / 会直接影响代理后的 URL 拼接规则，对前端接口请求路径的映射结果有显著差异。理解这一差异是配置接口代理的关键。 核心差异：路径拼接规则 假设： Nginx 配置的 location 匹配规则为 /api 后端服"},{"id":"1138","title":"Nginx 配置跨域（CORS）需设置哪些关键响应头？复杂跨域（带 cookie、自定义头）有何注意点【热度: 124】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1138","page":"q/web应用场景-1138.html","excerpt":"**关键词**：nginx 配置跨域 Nginx 配置跨域（CORS）的核心是通过设置特定响应头，允许不同域的前端资源请求当前服务器资源。以下是关键配置和复杂跨域场景的注意事项： 一、基础跨域配置：关键响应头 基础跨域（无 cookie、无自定义头）需配置以下核心响应头，允许指定域的请求访问资源： **各头字段作用**"},{"id":"1137","title":"SPA 的 history 路由模式在 Nginx 部署时刷新 404，如何配置解决【热度: 488】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1137","page":"q/web应用场景-1137.html","excerpt":"**关键词**：nginx 刷新 404 要解决 SPA（单页应用）History 路由模式在 Nginx 部署时刷新 404 的问题，核心是理解 **History 路由的原理缺陷** 与 **Nginx 的请求匹配逻辑**，再通过针对性配置让所有路由请求都指向 SPA 的入口文件（通常是 index.html）。以"},{"id":"1130","title":"less 与 css 有何区别【热度: 214】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1130","page":"q/web应用场景-1130.html","excerpt":"**关键词**：less 与 css Less 是 CSS 的预处理器，它在原生 CSS 的基础上扩展了诸多功能，解决了原生 CSS 开发中的痛点（如缺乏变量、复用机制、逻辑处理等）。以下是 Less 与 CSS 的核心区别： **1. 语法与功能** | **特性** | **CSS**（原生） | **Less**"},{"id":"1129","title":"less 与 scss 有何区别【热度: 61】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1129","page":"q/web应用场景-1129.html","excerpt":"**关键词**：less 与 scss Less 和 Sass（通常以 SCSS 语法使用）是最流行的两款 CSS 预处理器，都旨在解决原生 CSS 的局限性（如缺乏变量、嵌套、复用机制等），但在语法细节、功能设计和生态上存在诸多差异。以下从核心区别、使用场景等方面详细对比： **一、语法差异** 这是最直观的区别，直"},{"id":"1128","title":"less 有那些高级特性， 驱使你们项目工程去使用它【热度: 336】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1128","page":"q/web应用场景-1128.html","excerpt":"**关键词**：less 特性 Less 作为一款流行的 CSS 预处理器，核心价值在于通过**增强 CSS 的可编程性、复用性和可维护性**，简化样式开发流程。除了基础的变量、嵌套语法，它还提供了诸多“高级特性”，这些特性能应对复杂场景（如组件样式封装、主题切换、动态样式计算等）。以下是 Less 核心高级特性的详细"},{"id":"1127","title":"less 是否支持条件判定【热度: 112】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/1127","page":"q/web应用场景-1127.html","excerpt":"**关键词**：less 条件判定 是的，Less 完全支持条件判定，其核心通过 **when 关键字** 实现，同时可结合比较运算符、逻辑运算符构建复杂的条件逻辑，主要用于动态控制样式规则的生效与否（如根据变量值切换样式、适配不同场景）。 一、核心语法：when 条件判断 Less 的条件判定并非像 JavaScri"},{"id":"1125","title":"介绍一下 git diff【热度: 396】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1125","page":"q/web应用场景-1125.html","excerpt":"**关键词**：git diff 作者备注 这个比较冷门， 平常很多时候都用不上， 基本上可以当做科普了解 如果当面试官问到：代码有问题， 怎么排查是哪一个 commit 引入的， 可以参考以下的回答 git diff 是 Git 中用于**查看文件修改差异**的核心命令，能够展示不同版本、不同状态之间的代码变更，帮助"},{"id":"1124","title":"介绍一下 git stash【热度: 386】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1124","page":"q/web应用场景-1124.html","excerpt":"**关键词**：git stash git stash 是 Git 中一个非常实用的命令，用于**临时保存工作区和暂存区的修改**，让你可以在不提交当前变更的情况下，切换到其他分支或进行其他操作，之后还能恢复这些临时保存的变更。 核心作用 当你正在一个分支上开发，突然需要切换到其他分支（比如修复紧急 Bug），但当前工"},{"id":"1122","title":"将网页dom 元素转为图片， 有哪些办法【热度: 41】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1122","page":"q/web应用场景-1122.html","excerpt":"**关键词**：dom 转图片 在前端开发中，将 DOM 元素转换为图片有以下几种常见的方法： 1. 使用 HTML5 Canvas API (推荐) 这是最常用的方法，通过 Canvas 的drawImage或getContext方法绘制 DOM 内容，然后导出为图片。这种方法需要先将 DOM 内容转换为 Canva"},{"id":"1117","title":"decodeURI 和 decodeURIComponent 有何区别【热度: 230】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/1117","page":"q/web应用场景-1117.html","excerpt":"decodeURI() 和 decodeURIComponent() 是 JavaScript 中用于解码 URI（统一资源标识符）的两个方法，它们的核心区别在于解码范围和适用场景。 **1. 编码规则回顾** 在 URI 中，某些字符（如空格、特殊符号）需要被编码为 % 后跟两位十六进制数。例如： 空格被编码为 %2"},{"id":"1116","title":"scrollIntoView、scrollIntoViewIfNeeded、scrollTo 有何区别？【热度: 320】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1116","page":"q/web应用场景-1116.html","excerpt":"scrollIntoView()、scrollIntoViewIfNeeded() 和 scrollTo() 是 JavaScript 中用于滚动的三个方法，它们的功能和适用场景有所不同： **1. Element.scrollIntoView()** **所属对象**：DOM 元素（Element）。 **作用**："},{"id":"1115","title":"让元素滚动到可视区， 有那些办法【热度: 320】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1115","page":"q/web应用场景-1115.html","excerpt":"在前端开发中，使元素滚动到可视区域是常见需求。以下是几种实现方式，从简单到复杂逐步介绍： **1. Element.scrollIntoView()** 这是最简单的原生方法，支持平滑滚动和对齐方式： **优点**：简单易用，兼容性好（IE11+）。 **缺点**：无法精确控制滚动速度或添加自定义动画。 **2. Wi"},{"id":"1114","title":"前端倒计时有误差怎么解决【热度: 454】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/1114","page":"q/web应用场景-1114.html","excerpt":"前端倒计时出现误差是常见问题，主要由 JavaScript 的单线程特性、浏览器优化（如标签页切换时的节流）以及事件循环调度延迟引起。以下是几种解决方案： **1. 使用高精度时间戳（performance.now()）** Date.now() 依赖系统时间，可能被用户或系统修改；而 performance.now("},{"id":"1098","title":"自定义 eslint 插件， 要求常量为大写 snake 命名方式， 该怎么做【热度: 35】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1098","page":"q/web应用场景-1098.html","excerpt":"**关键词**：eslint 插件实现 1. 项目结构 假设你的项目根目录为 your-project，在项目中创建插件相关的目录结构： 2. 编写插件代码 规则组件（eslint-plugin-local/lib/rules/uppercase-snake-case.js） 插件入口文件（eslint-plugin-"},{"id":"1097","title":"eslint 是怎么做到用配置规则去检验代码异常【热度: 75】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1097","page":"q/web应用场景-1097.html","excerpt":"**关键词**：eslint 原理 ESLint 是一个用于识别和报告 JavaScript 代码中模式问题的工具，它通过配置规则来检验代码异常，下面详细介绍其工作原理和实现过程。 1. 规则配置 ESLint 允许用户通过配置文件来定义代码检查规则。常见的配置文件格式有 .eslintrc.js、.eslintrc."},{"id":"1096","title":"将已经 push 到远端的两个 commit 合并成一个 commit 应该怎么做【热度: 103】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1096","page":"q/web应用场景-1096.html","excerpt":"**关键词**：git rebase 合并 commit 当你已经将两个 commit 推送到远端仓库，现在想要将它们合并成一个 commit，可以按照以下步骤操作： 1. 克隆仓库到本地 如果你还没有在本地克隆该仓库，需要先将远程仓库克隆到本地： 2. 查看提交历史 使用 git log 命令查看提交历史，确认要合并"},{"id":"1083","title":"前端两个 dom 元素是可以拖拽的， 要实现两个 dom 之间的连接线，如何实现【热度: 55】","category":"web应用场景","labels":["web应用场景","代码实现/算法"],"url":"https://github.com/pro-collection/interview-question/issues/1083","page":"q/web应用场景-1083.html","excerpt":"**关键词**：拖拽元素连线实现 **基本思路和技术选择** **思路**：要实现两个可拖拽 DOM 元素之间的连接线，关键在于获取两个元素的位置信息，并根据这些位置动态地绘制连线。通常可以使用 HTML5 的 Canvas 或者 SVG 来实现连线的绘制。 **技术对比**： **Canvas**：它是一个通过 Ja"},{"id":"1081","title":"日常开发中使用到哪些常用的 Git 命令【热度: 193】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1081","page":"q/web应用场景-1081.html","excerpt":"**关键词**：git 常用命令 **关键词**：git 常用命令 在日常生活的开发工作中，以下是一些常用的 Git 命令： 配置相关 **git config**： **用途**：用于配置 Git 的各种参数，如用户姓名、邮箱等基本信息，这些信息会关联到每一次提交记录。 **示例**： git config --gl"},{"id":"1080","title":"代码里console.log比较多，该怎么办【热度: 340】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1080","page":"q/web应用场景-1080.html","excerpt":"**ESLint配置规则软性禁止**：通过配置.eslintrc.json文件，添加\"no-console\": \"warn\"规则，使代码中使用console的地方会划上黄色波浪线警示，能一定程度削减console.log数量，但无法真正阻止其使用。 **git commit编写规则限制提交**：找到项目中的.git/h"},{"id":"1067","title":"项目部署更新之后，如何提醒用户去刷新更新页面资源【热度: 340】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/1067","page":"q/web应用场景-1067.html","excerpt":"**使用版本号查询参数** **原理**：在 HTML 文件中，对于引用的静态资源（如 JavaScript 文件、CSS 文件），可以在 URL 后面添加一个版本号查询参数。每次更新项目后，更新这个版本号。这样，浏览器会将带有新的版本号的资源视为一个新的请求，从而强制刷新资源。 **示例**： 原始的 JavaScr"},{"id":"1055","title":"排查谁在修改对象【热度: 500】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1055","page":"q/web应用场景-1055.html","excerpt":"这是一个话题性值得问题： 例如：redux 申请了一份数据 store , 整个应用有特别多的地方在修改这个 store , 现在数据出现异常， 如何排查是哪儿场景修改的这份 store 导致的异常; 不仅仅是针对 redux ， 我们面临可能是全局对象等场景，对被多个调用方修改的现象。 这个没有一个标准答案， 可以咨"},{"id":"1051","title":"为何现在主流的图表库都是用的 canvas 方案， 而不是使用 svg， 是基于什么因素考量的呢【热度: 88】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1051","page":"q/web应用场景-1051.html","excerpt":"**关键词**：SVG 与 canvas 对比 作者备注 比较冷门的话题， 当做一个科普吧 SVG 和 Canvas 在利用 GPU 硬件加速方面存在以下区别： **一、SVG 的 GPU 加速特点** 有限的自动加速 SVG 图形通常由浏览器自动决定是否使用 GPU 加速。对于一些简单的 SVG 图形，浏览器可能不会"},{"id":"1050","title":"为何现在主流的图表库都是用的 canvas 方案， 而不是使用 svg， 是基于什么因素考量的呢【热度: 26】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1050","page":"q/web应用场景-1050.html","excerpt":"**关键词**：SVG 与 canvas 对比 作者备注 这个是一个开放性的话题， 没有啥好讲的， 主要是看看同学们对前言技术的敏感度吧 有兴趣的话，可以去搜索一下国外的文章，有比较多的对比文章 目前主流图表库选用 canvas 方案而非 svg 主要有以下一些因素考量： **一、性能方面** 渲染性能 在处理大量数据"},{"id":"1048","title":"统计前端请求耗时【热度: 609】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1048","page":"q/web应用场景-1048.html","excerpt":"**关键词**：请求耗时统计 在前端业务中，可以通过以下几种方法统计请求耗时： 初级手段 **一、使用fetch结合时间戳** 在发送请求前记录当前时间戳： const startTime = performance.now(); 使用fetch发送请求： fetch('your-api-url') 在请求的.then"},{"id":"1047","title":"Performance API 主要有哪些应用场景【热度: 431】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1047","page":"q/web应用场景-1047.html","excerpt":"**关键词**：Performance API 应用 Performance API 在前端开发中有很多应用场景，以下是一些主要的方面： **一、性能监测与优化** 测量页面加载时间： 通过performance.timing可以获取页面加载过程中的各个关键时间点，如navigationStart（导航开始时间）、do"},{"id":"1046","title":"弱网检测该如何做【热度: 597】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1046","page":"q/web应用场景-1046.html","excerpt":"**关键词**：网络状况检测 在 JavaScript 中，可以通过以下几种方式进行弱网检测： **一、监测网络连接状态** 使用navigator.onLine属性：这个属性可以判断浏览器是否处于在线状态。当网络连接中断时，navigator.onLine会变为false；当网络连接恢复时，它会变为true。 示例代"},{"id":"1045","title":"canvas 是如何处理复杂事件交互的呢【热度: 120】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/1045","page":"q/web应用场景-1045.html","excerpt":"**关键词**：canvas 事件交互 在 HTML5 的canvas中处理复杂事件交互可以通过以下方法实现： **一、基本原理** 由于canvas只是一个像素绘制区域，本身并不像常规 HTML 元素那样具有内置的事件处理机制。所以需要通过以下方式来处理事件交互： 监听整个文档或包含canvas的容器元素的事件。 根"},{"id":"1038","title":"浏览器中点击 a 标签保存为文件如何做【热度: 84】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1038","page":"q/web应用场景-1038.html","excerpt":"**关键词**：a 标签保存文件 在浏览器中，通常情况下无法直接通过点击一个<a>标签将其指向的内容保存为文件。但是可以通过一些特定的方法来实现类似的功能： **一、使用服务器端响应** 服务器端生成文件：如果要让用户下载一个文件，可以在服务器端生成该文件，并设置适当的响应头，让浏览器将响应内容视为一个文件进行下载。 "},{"id":"1034","title":"Javascript 数组中有那些方法可以改变自身，那些不可以【热度: 307】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1034","page":"q/web应用场景-1034.html","excerpt":"**关键词**：数组改变自身 在 JavaScript 中，数组的方法可以分为两类：改变自身的方法和不改变自身的方法。 **一、改变自身的方法** push()：在数组末尾添加一个或多个元素，并返回新的数组长度。 pop()：删除数组的最后一个元素，并返回这个元素。 shift()：删除数组的第一个元素，并返回这个元素"},{"id":"1033","title":"如何保证项目质量【热度: 784】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1033","page":"q/web应用场景-1033.html","excerpt":"**关键词**：项目质量保证 作者备注 这个话题是一个开放性话题， 只要合理， 怎么都没有错。 以下是 GPT 作答， 仅供参考 要保证项目质量，可以从以下几个方面入手： **一、需求分析与规划** 明确需求： 与项目相关方（如客户、产品经理、团队成员等）进行充分沟通，确保对项目的目标、功能需求、性能需求、用户体验要求"},{"id":"1031","title":"HTML 中有哪些语义化标签【热度: 32】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1031","page":"q/web应用场景-1031.html","excerpt":"**关键词**：html 语义化标签 在 HTML 中，语义化标签是具有明确含义的标签，它们可以更好地描述网页的结构和内容，提高代码的可读性、可维护性以及对搜索引擎的优化。以下是一些常见的语义化标签： **一、文档结构相关标签** <header>： 定义文档的页眉部分，通常包含网站的标志、导航栏、搜索框等。 例如： "},{"id":"1030","title":"flex 布局中 align-content 与 align-items 有何区别【热度: 106】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1030","page":"q/web应用场景-1030.html","excerpt":"**关键词**：flex 布局属性 在 Flex 布局中，align-content和align-items都是用于控制 Flex 容器内项目在交叉轴（垂直于主轴的方向）上的对齐方式，但它们有以下区别： **一、作用范围不同** align-items： 作用于 Flex 容器内的单行项目。 它决定了每个单独的项目在交"},{"id":"1028","title":"npm install 之后需要执行一些处理工作，应该如何处理【热度: 162】","category":"web应用场景","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/1028","page":"q/web应用场景-1028.html","excerpt":"**关键词**：html 标签元素 如果在执行npm install之后需要执行一些处理工作，可以通过以下几种方式来实现： **一、使用postinstall脚本** 在package.json文件中添加scripts字段，并在其中定义一个postinstall脚本： - 例如，如果需要在安装后运行一个构建脚本，可以设"},{"id":"1027","title":"html 里面哪些是块级元素， 哪些是行内元素【热度: 160】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1027","page":"q/web应用场景-1027.html","excerpt":"**关键词**：html 标签元素 在 HTML 中，元素可分为块级元素和行内元素。 **一、块级元素** 特点： 独占一行，在页面中垂直布局。 可以设置宽度、高度、外边距（margin）和内边距（padding）等属性。 即使不设置宽度，也会自动占据整行的宽度。 常见的块级元素有： <div>：通用的块级容器元素，可"},{"id":"1026","title":"package.json 里面，表示导出包内容的配置有哪些【热度: 260】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1026","page":"q/web应用场景-1026.html","excerpt":"在package.json文件中，与导出包内容相关的主要配置有以下几个： **一、main字段** 作用： 指定当你的包被引入时，模块系统应该加载的主要入口文件。 对于 CommonJS 和 ES6 模块系统，这个文件将作为默认的入口点。 示例： \"main\": \"dist/index.js\"表示当你的包被引入时，会加"},{"id":"1015","title":"package.json 依赖申明的方式有哪些， 他们有何却别【热度: 193】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1015","page":"q/web应用场景-1015.html","excerpt":"**关键词**：前端依赖申明方式 **一、dependencies（生产依赖）** **定义和用途**： dependencies用于声明项目在生产环境中运行所必需的依赖项。 这些依赖项是项目正常运行所不可或缺的，无论是在开发阶段还是在部署到生产环境后。 **示例**： 比如，如果你的项目使用了 Express.js "},{"id":"1013","title":"介绍一下 URLSearchParams API【热度: 10】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/1013","page":"q/web应用场景-1013.html","excerpt":"**关键词**：URLSearchParams API 介绍 URLSearchParams是 JavaScript 中的一个内置 API，用于处理 URL 的查询参数部分。它提供了一系列方法来方便地操作和获取 URL 中的查询参数。 **一、创建URLSearchParams对象** **从现有 URL**： 可以从"},{"id":"1012","title":"前端如何快速获取页面 url query 参数【热度: 888】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1012","page":"q/web应用场景-1012.html","excerpt":"**关键词**：获取 url 参数 在前端，可以通过以下几种方式快速获取页面 URL 的查询参数： **一、使用 URLSearchParams API** **基本用法**： URLSearchParams是一个内置的 JavaScript API，用于处理 URL 的查询参数。它提供了一种方便的方式来获取、设置和删"},{"id":"1011","title":"HTML 中的 input 标签有哪些 type【热度: 197】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1011","page":"q/web应用场景-1011.html","excerpt":"**关键词**：input 标签 type 属性 HTML 中的<input>标签有多种type属性值，以下是一些常见的类型： **一、文本输入类型** text： 用于输入单行文本。这是最常见的输入类型之一，用户可以在输入框中输入任何文本内容。 例如：<input type=\"text\">。 password： 用于"},{"id":"1010","title":"前端如何处理一个页面多主题色可供选择的场景【热度: 797】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1010","page":"q/web应用场景-1010.html","excerpt":"**关键词**：主题色切换 在前端处理一个页面有多个主题色可供选择的场景，可以通过以下几种方式实现： **一、使用 CSS 变量** **定义 CSS 变量**： 在 CSS 中，可以使用--来定义变量。例如，可以定义一些代表主题色的变量： 这里定义了两个变量--primary-color和--secondary-co"},{"id":"1005","title":"如何计算页面首屏时间【热度: 426】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1005","page":"q/web应用场景-1005.html","excerpt":"**关键词**：首屏时间 页面首屏时间是指从浏览器开始请求页面到页面的首屏内容完全显示的时间。以下是几种计算首屏时间的方法： **一、使用浏览器性能 API 和自定义事件** 具体步骤： 在页面的<head>标签中插入一段 JavaScript 代码，在页面加载时记录浏览器开始导航的时间戳，即performance.t"},{"id":"1004","title":"如何计算页面白屏时间【热度: 400】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1004","page":"q/web应用场景-1004.html","excerpt":"**关键词**：白屏时间 白屏时间是指从浏览器开始请求页面到页面开始显示内容的时间。可以通过以下方法计算白屏时间： **一、使用浏览器的性能 API** 现代浏览器提供了performance对象，可以用来获取页面加载过程中的各种时间戳。通过这些时间戳的差值可以计算出白屏时间。 具体步骤： 在页面的<head>标签中插"},{"id":"1003","title":"`DOMContentLoaded`事件和`load`事件有什么区别【热度: 210】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1003","page":"q/web应用场景-1003.html","excerpt":"**关键词**：DOMContentLoaded 和 onload 事件 DOMContentLoaded事件和load事件主要有以下区别： **一、触发时机** DOMContentLoaded事件： 触发时机是在文档的 DOM（文档对象模型）完全加载和解析完成后，不等待样式表、图片和子框架等外部资源的加载完成。这意"},{"id":"1002","title":"如果我期望，页面加载和解析完成之后出发事件， 我该怎么做【热度: 299】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/1002","page":"q/web应用场景-1002.html","excerpt":"**关键词**：DOMContentLoaded 和 onload 事件 如果期望在页面加载和解析完成之后触发事件，可以通过以下几种方式实现： **一、使用DOMContentLoaded事件** 传统方式： 使用addEventListener方法来监听DOMContentLoaded事件。当页面的 DOM 结构加载"},{"id":"996","title":"如何实现页面文本不可选中，不可复制【热度: 255】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/996","page":"q/web应用场景-996.html","excerpt":"**关键词**：禁止文本复制 可以通过 CSS 和 JavaScript 结合的方式实现页面文本不可选中和不可复制。 **一、使用 CSS** 可以通过设置 CSS 属性来禁止用户选中页面文本： 这将禁止在整个页面上进行文本选择。 **二、使用 JavaScript** 如果仅使用 CSS 不能满足需求，可以结合 Ja"},{"id":"990","title":"查找页面出现次数最多的 HTML 标签【热度: 379】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/990","page":"q/web应用场景-990.html","excerpt":"**关键词**：标签查找 作者备注 主要是考察 getElementsByTagName 选择器， 以及如何获取元素标签名：tagName 直接上代码"},{"id":"989","title":"有哪些前端性能分析工具【热度: 400】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/989","page":"q/web应用场景-989.html","excerpt":"**关键词**：前端性能分析 以下是一些常用的前端性能分析工具： **一、浏览器开发者工具** **Chrome DevTools**： 功能强大，提供了丰富的性能分析选项。 在“Performance”（性能）面板中，可以录制页面的交互过程，分析 CPU 使用率、内存占用、网络请求等，找出性能瓶颈。 “Network"},{"id":"976","title":"commonjs 模块化中 module.exports 与 exports 有什么区别， 该如何选择【热度: 194】","category":"web应用场景","labels":["工程化","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/976","page":"q/web应用场景-976.html","excerpt":"**关键词**：模块化 导出 在 CommonJS 模块化规范中，module.exports与exports有以下区别： **一、module.exports** **本质**： module.exports是一个对象，它代表当前模块要导出的内容。可以将任意类型的值（如函数、对象、字符串等）赋值给module.exp"},{"id":"975","title":"css 中属性选择器及类选择器的权重哪个高【热度: 642】","category":"web应用场景","labels":["CSS","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/975","page":"q/web应用场景-975.html","excerpt":"**关键词**：选择器权重 作者备注 这个是一个非常贼的问题， 可能很多都只是知道， 【类选择器、属性选择器和伪类选择器】 都为为一样的， 但是并不知道 【类选择器、属性选择器】之间还有优先级关系 在 CSS 中，类选择器的权重高于属性选择器。 **一、权重计算规则** CSS 的权重是一个用于确定当多个选择器应用于同"},{"id":"969","title":"http 缓存中 no-cache 与 no-store 的区别是什么【热度: 564】","category":"web应用场景","labels":["网络","web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/969","page":"q/web应用场景-969.html","excerpt":"**关键词**：http 缓存 在 HTTP 缓存中，no-cache和no-store是两种不同的缓存指令，它们的区别如下： **一、no-cache** **含义**： 当设置了no-cache指令时，这并不意味着不使用缓存。相反，它表示在使用缓存之前，必须先与服务器进行验证，以确定缓存的资源是否仍然有效。 这意味"},{"id":"968","title":"如何进行代码质量检测【热度: 497】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/968","page":"q/web应用场景-968.html","excerpt":"**关键词**：代码质量检查 作者备注 开发性质的话题， 没有统一答复， 也没有最好答复， 这边给几个思考的方向 进行代码质量检测可以从以下几个方面入手： **一、静态代码分析** 使用静态代码分析工具 例如 SonarQube、Checkstyle、PMD 等。这些工具可以检查代码中的潜在问题，如代码风格不符合规范、"},{"id":"967","title":"http 缓存 header 中的 Date 与 Last-Modified 有什么不同【热度: 276】","category":"web应用场景","labels":["网络","web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/967","page":"q/web应用场景-967.html","excerpt":"**关键词**：http 缓存 header 在 HTTP 响应头中，Date和Last-Modified有以下不同： **一、含义不同** Date：表示消息产生的时间。服务器用这个时间来标记响应报文的生成时间，它反映了服务器生成响应的时刻。例如，“Mon, 07 Oct 2024 12:34:56 GMT”，这个时"},{"id":"966","title":"http 向 https 做重定向应该使用哪个状态码【热度: 336】","category":"web应用场景","labels":["网络","web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/966","page":"q/web应用场景-966.html","excerpt":"**关键词**：重定向 从 HTTP 向 HTTPS 做重定向，既可以使用 301 永久重定向状态码，也可以使用 302 临时重定向状态码。以下是对这两种状态码的具体介绍及使用场景分析： **301 永久重定向**： **含义**：表示请求的资源已被永久地移动到了新的 URL，搜索引擎等客户端会更新其索引，将旧的 UR"},{"id":"965","title":"http header content-type 为 application/octet-stream，则代表什么意思【热度: 136】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/965","page":"q/web应用场景-965.html","excerpt":"**关键词**：header content-type 在 HTTP 响应头中，如果Content-Type为application/octet-stream，代表以下含义： **一、数据类型含义** **通用二进制流**： application/octet-stream表示这是一个通用的二进制流数据。它没有特定的格"},{"id":"964","title":"http 静态文件缓存 Last-Modified 是根据什么生成的【热度: 85】","category":"web应用场景","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/964","page":"q/web应用场景-964.html","excerpt":"**关键词**：静态文件缓存 作者备注 冷门， 当做只是了解即可 在 HTTP 服务中，静态文件的Last-Modified（最后修改时间）通常是根据以下几个因素生成的： **一、文件系统的修改时间** **来源**： 服务器在提供静态文件时，通常会读取文件所在文件系统中的最后修改时间作为Last-Modified的值"},{"id":"963","title":"站点是如何保持登录状态【热度: 210】","category":"web应用场景","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/963","page":"q/web应用场景-963.html","excerpt":"**关键词**：http 保持登录态 虽然 HTTP 是无状态协议，但可以通过以下几种方式来保持登录状态： **一、Cookie** 工作原理： 当用户成功登录后，服务器在响应中设置一个 Cookie，通常包含用户的身份标识、会话信息等。 客户端（浏览器）会存储这个 Cookie，并在后续的请求中自动将其发送给服务器。"},{"id":"962","title":"http ETag 值改变了，是否意味着文件内容一定已经更改【热度: 138】","category":"web应用场景","labels":["网络","web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/962","page":"q/web应用场景-962.html","excerpt":"**关键词**：ETag 值 如果 HTTP 响应头中的 ETag 值改变了，通常意味着资源（文件或其他内容）很可能发生了变化，但并不绝对意味着文件内容一定已经更改。 **一、可能导致 ETag 变化但文件内容未更改的情况** 生成方式的变化： 如果服务器更改了生成 ETag 的方式，即使文件内容没有变化，ETag 也"},{"id":"961","title":"http 响应头中的 ETag 值是如何生成的【热度: 37】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/961","page":"q/web应用场景-961.html","excerpt":"**关键词**：ETag 值 作者备注 没有啥价值， 当做科普吧 HTTP 响应头中的 ETag（Entity Tag）是服务器生成的用于标识资源的一个字符串。ETag 的生成方式通常有以下几种： **一、基于资源内容生成** 哈希算法： 服务器可以计算资源内容的哈希值，例如使用 MD5、SHA-1 等哈希算法。将资源"},{"id":"960","title":"浏览器中如何实现剪切板复制内容的功能【热度: 95】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/960","page":"q/web应用场景-960.html","excerpt":"**关键词**：document.execCommand('copy')、navigator.clipboard API 在浏览器中，可以通过以下几种方式实现剪切板复制内容的功能： **一、使用document.execCommand('copy')** **基本用法**： 在 JavaScript 中，可以使用doc"},{"id":"959","title":"分片上传文件，如何校验文件完整性【热度: 220】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/959","page":"q/web应用场景-959.html","excerpt":"分片上传是一种将大文件分割成多个小片段进行上传的方法，在分片上传过程中校验文件完整性非常重要，可以确保上传的文件在服务器端能够正确地组合成完整的文件。以下是一些校验文件完整性的思路： **一、使用哈希算法** **计算文件哈希值**： 在客户端上传文件之前，先对整个文件计算哈希值。常用的哈希算法有 MD5、SHA-1、"},{"id":"958","title":"try...catch 是否能捕获异步异常【热度: 701】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/958","page":"q/web应用场景-958.html","excerpt":"**关键词**：异常处理 题目是：以下代码有错吗？如果有错，应该如何改正？ **解答** 才知道 try...catch 不能异步捕获代码错误。在 JavaScript 中，setTimeout 是一个异步函数，它的回调函数会在指定的延时后被放入事件队列，等待当前执行栈清空后才执行。因此，当 setTimeout 的回"},{"id":"955","title":"单元测试、E2E 测试有和区别？【热度: 258】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/955","page":"q/web应用场景-955.html","excerpt":"**关键词**：前端测试 单元测试（Unit Testing）和端到端测试（End-to-End Testing，E2E Testing）有以下主要区别： **一、测试范围** 单元测试： 聚焦于软件系统的最小可测试单元，通常是函数、方法或类。 只测试单个功能单元的行为，隔离其他部分的影响。 例如，测试一个特定的数学函"},{"id":"954","title":"前端应用有哪些代码测试手段【热度: 385】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/954","page":"q/web应用场景-954.html","excerpt":"**关键词**：测试手段 在前端应用中，有以下几种主要的代码测试手段： **一、单元测试** 定义： 针对应用程序中的最小可测试单元（如函数、方法或类）进行的测试。 目的是确保每个独立的单元在各种输入情况下都能正确执行其预期的功能。 常用工具： Jest：一个功能强大且流行的 JavaScript 测试框架，提供了丰富"},{"id":"952","title":"mobx 和 redux 有什么区别【热度: 277】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/952","page":"q/web应用场景-952.html","excerpt":"**关键词**：mobx 和 redux 区别 作者备注 这里知识一个间比较， 没有深入去对比 api 等， 如果需要深入对比请自行查看下面的文档 参考文档：https://juejin.cn/post/6924572729886638088 MobX 和 Redux 都是流行的 JavaScript 状态管理库，广泛"},{"id":"951","title":"在 forEach 中和 for 循环 中调用异步函数的区别【热度: 371】","category":"web应用场景","labels":["JavaScript","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/951","page":"q/web应用场景-951.html","excerpt":"**关键词**：循环中的异步 在 JavaScript 中，处理异步函数时，for 循环和 forEach 方法之间的行为有显著差异，尤其是当你试图在循环体中使用 async/await 时。理解这些差异对于编写正确且高效的异步代码是很重要的。 使用 forEach 调用异步函数 Array.prototype.for"},{"id":"950","title":"axios 如何取消请求【热度: 218】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/950","page":"q/web应用场景-950.html","excerpt":"**关键词**：axios 取消请求 作者备注 新版本已经废弃使用 cancelToken ，改为使用 signal 可以参考官网：https://axios-http.com/docs/cancellation 取消请求 timeout在 axios 调用中设置属性**可处理响应**相关的超时。 在某些情况下（例如网"},{"id":"949","title":"axios 如何注销拦截器【热度: 140】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/949","page":"q/web应用场景-949.html","excerpt":"**关键词**：axios 拦截器 作者备注 这个问题稍微有点儿偏冷门， 需要阅读过 axios 官网才能正确作答， 考察的是同学自驱型学习能力 在 Axios 中，可以使用以下方法注销拦截器： **一、为拦截器分配一个引用** 创建拦截器时保存引用： 当创建一个 Axios 请求或响应拦截器时，可以将其分配给一个变量"},{"id":"948","title":"给 axios 做一个通用拦截器，实现功能为状态码非 200 的时候，统一拦截错误， 提示一个 toast, 该如何实现【热度: 339】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/948","page":"q/web应用场景-948.html","excerpt":"**关键词**：axios 拦截器 作者备注 拦截器是 axios 的最核心功能之一， 该问题只是考察 axios 的核心功能的基本使用 以下是使用 Axios 的拦截器来实现当状态码非 200 时统一拦截错误并提示 toast 的方法： 假设你使用了一个名为 toast 的函数来显示 toast 消息，这个函数可以根"},{"id":"947","title":"想设置 axios 全局通用配置， 有哪些方法【热度: 298】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/947","page":"q/web应用场景-947.html","excerpt":"**关键词**：axios 配置 在 Axios 中，可以通过以下几种方法设置全局通用配置： **一、使用axios.defaults** 直接设置属性： 可以直接在axios.defaults上设置各种配置属性，如baseURL、timeout、headers等。这些设置将应用于所有后续的 Axios 请求。 设置t"},{"id":"946","title":"解释下 axios withCredentials 配置【热度: 197】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/946","page":"q/web应用场景-946.html","excerpt":"**关键词**：axios 配置 作者备注 这个问题太冷门了， 如果不是细看过顾问囊的人， 是不会知道有这个配置项的。 可以当做科普即可， 面试中问到的可能性也非常的低。 在 Axios 中，withCredentials是一个配置选项，用于处理跨源请求时是否携带用户凭证（cookies、HTTP 认证信息等）。 **"},{"id":"945","title":"axios 支持哪些常用的配置【热度: 196】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/945","page":"q/web应用场景-945.html","excerpt":"**关键词**：axios 配置 作者备注 这个其实直接看官网即可 https://axios-http.com/docs/req_config 以下是翻译的全配置"},{"id":"942","title":"axios 有哪些特性【热度: 147】","category":"web应用场景","labels":["网络","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/942","page":"q/web应用场景-942.html","excerpt":"**关键词**：axios 特性 作者备注 以下特性信息都是直接来自于官网 https://axios-http.com/docs/intro 但是可能很多同学并不会去好好看官网， 所以这个问题， 只是考察同学们的学习主动性 从浏览器发出 XMLHttpRequests 从 node.js 发出 http 请求 支持 "},{"id":"941","title":"动画性能如何检测【热度: 262】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/941","page":"q/web应用场景-941.html","excerpt":"**关键词**：动画性能 作者备注， 这个问题其实没有啥太大的价值， 可以当做科普看看即可 **一、使用浏览器开发者工具** Chrome 开发者工具： 打开 Chrome 浏览器，进入要检测动画性能的页面。 按下 F12 打开开发者工具，切换到“Performance”（性能）选项卡。 点击“Record”（录制）按"},{"id":"939","title":"手写实现 lodash.flattenDeep 将array递归为一维数组【热度: 345】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/939","page":"q/web应用场景-939.html","excerpt":"**关键词**：lodash.flattenDeep 实现 以下是用 JavaScript 手写实现类似于 lodash.flattenDeep 的函数来将数组递归展平为一维数组： 你可以使用以下方式测试这个函数："},{"id":"938","title":"localStorage 是同步还是异步【热度: 210】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/938","page":"q/web应用场景-938.html","excerpt":"在大多数现代浏览器中，localStorage的操作是同步的。 当你使用localStorage.setItem()来存储数据或者localStorage.getItem()来获取数据时，这些操作会立即执行并且不会返回一个 Promise 或者使用回调函数来处理异步操作。 例如： 在上面的代码中，设置和获取localS"},{"id":"937","title":"如何限制 input 框只能输入正整数【热度: 230】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/937","page":"q/web应用场景-937.html","excerpt":"在前端，可以通过以下几种方式来限制 <input> 框只能输入正整数： **一、使用 HTML5 的输入类型和属性** 使用 type=\"number\" 属性： <input type=\"number\"> 设置输入框的类型为数字。然而，这并不能完全确保只输入正整数，因为用户仍然可以输入小数。 添加 step=\"1\" 和"},{"id":"890","title":"npm run start 的过程是啥，为何能执行对应的命令【热度: 170】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/890","page":"q/web应用场景-890.html","excerpt":"**关键词**：npm run start 过程 当你在项目的根目录下执行 npm run start 命令时，实际上触发了一个由 Node.js 包管理器（npm）管理的一系列流程。理解这一过程，可以帮助你更好地掌握项目的构建和开发流程。以下是 npm run start 执行过程的概述： 1. npm run st"},{"id":"885","title":"如何做静态资源预加载【热度: 696】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/885","page":"q/web应用场景-885.html","excerpt":"**关键词**：资源预加载 预加载 预加载是指在用户需要数据或资源之前，提前加载这些数据或资源的过程。 这个过程可以提高应用程序或网站的响应速度和用户体验 预加载的优点 **提升加载速度**：通过提前加载资源，用户在访问页面时可以更快地看到完整内容。 **提高用户体验**：减少页面加载时的延迟，使用户感到更流畅。 **"},{"id":"883","title":"在开发过程中，想做 git 代码暂存，该如何做【热度: 342】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/883","page":"q/web应用场景-883.html","excerpt":"**关键词**：git stash 使用 作者备注 这个问题的指向性非常明显， 就是在问 git stash 的使用 在 Git 中，如果你想要暂存当前的工作进度，可以使用git stash命令。这个命令会将你的工作目录中的修改（已追踪文件的修改和暂存的改动）保存到一个未完成工作的栈中，同时将你的工作目录恢复到上次提交"},{"id":"882","title":"websocket 断联之后如何重连，且保证断链期间数据不丢失【热度: 200】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/882","page":"q/web应用场景-882.html","excerpt":"**关键词**：websocket 断联数据不丢失 实现 WebSocket 的自动重连并保证断连期间数据不丢失，通常需要在客户端实现一些机制来管理连接状态、定时重试以及缓存未成功发送的消息。以下是一个简单的步骤和策略指南： 1. 监听连接状态 首先，你需要监听 WebSocket 连接的各种事件，以便知道何时发生了断"},{"id":"880","title":"需要详细记录多个操作链路的性能耗时，进行结构化场景分析，该如何做【热度: 378】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/880","page":"q/web应用场景-880.html","excerpt":"**关键词**：操作链路耗时分析 作者笔记 该问题， 主要是考察两个问题， 怎么定操作节点指标， 怎么去捕获每个阶段时间的耗时 操作节点指标 首先对一个操作链路切片：比如一个操作流程， 分拆为第一步， 第二步， 第三步....... 然后对每一步一个事件点。 然后统计每一个时间点之间的时间差， 就可以得出用户早操作每一"},{"id":"876","title":"eslint 如何设置只校验本次 MR 变更的文件内容【热度: 200】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/876","page":"q/web应用场景-876.html","excerpt":"**关键词**：eslint 和 git 结合校验 要让 ESLint 只校验在 Merge Request (MR)、Pull Request (PR)或代码提交中变更的文件，可以采用几种方法。下面是几个可能的方案： 1. 命令行 Git 和 ESLint 组合使用 通过组合git命令和eslint命令来实现。首先，"},{"id":"867","title":"要实时统计用户浏览器窗口大小，该如何做【热度: 210】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/867","page":"q/web应用场景-867.html","excerpt":"**关键词**：resize 事件应用 要实时统计用户浏览器窗口大小，可以利用 JavaScript 中的 resize 事件。当浏览器窗口尺寸变化时，此事件会被触发。通过侦听此事件，可以实时获取并处理浏览器窗口的宽度和高度。 基础示例 下面是一个简单的示例，展示如何使用 resize 事件来获取并打印当前浏览器窗口的"},{"id":"866","title":"ResizeObserver 作用是什么【热度: 416】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/866","page":"q/web应用场景-866.html","excerpt":"**关键词**：ResizeObserver api ResizeObserver 的作用是监测元素的尺寸变化。这是一种强大的 Web API，允许开发者在元素的尺寸发生改变时（无论是因为元素内容的变化、窗口大小的调整还是其他原因导致的尺寸改变），执行一些操作或布局更新。在过去，开发者通常需要依赖定时器或者窗口的 re"},{"id":"865","title":"如何防止前端页面重复请求【热度: 451】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/865","page":"q/web应用场景-865.html","excerpt":"**关键词**：重复请求问题 防止前端页面的重复请求是提升用户体验和减轻服务器压力的重要策略之一。下面是一些实用的方法来减少或防止重复请求： 1. 使用锁或标志位 设置一个锁（flag）或状态标志位来控制请求的发送。在首次点击或请求发起时设置该标志位，直到请求完成后再清除该标志，以阻止在请求未完成前再次发起相同的请求。"},{"id":"864","title":"统计全站每一个静态资源加载耗时， 该如何做【热度: 564】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/864","page":"q/web应用场景-864.html","excerpt":"**关键词**：统计资源加载耗时、PerformanceObserver PerformanceResourceTiming api 使用 要统计全站每一个静态资源（如图片、JS 脚本、CSS 样式表等）的加载耗时，你可以借助浏览器的 Performance API，特别是利用 PerformanceResourceT"},{"id":"863","title":"如何实现鼠标拖拽【热度: 212】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/863","page":"q/web应用场景-863.html","excerpt":"**关键词**：拖拽 api、mousedown、mousemove和mouseup事件 实现鼠标拖拽功能通常涉及到监听和处理鼠标事件，比如：mousedown、mousemove和mouseup事件。下面是一个基本的步骤指南以及一个简易的示例代码（使用 HTML 和 JavaScript），展示了如何实现一个元素的鼠"},{"id":"861","title":"长文本溢出，展开/收起如何实现【热度: 895】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/861","page":"q/web应用场景-861.html","excerpt":"**关键词**：长文本溢出 长文本溢出展开/收起功能通常需要使用一些 JavaScript 来动态控制文本的显示状态，及 CSS 来处理文本的默认显示样式。以下是一个基本实现示例，展示了如何结合 HTML、CSS 和 JavaScript 来实现这个功能。 HTML 结构 我们定义一个容器来显示文本，并添加一个用于触发"},{"id":"860","title":"如何统计用户 pv 访问的发起请求数量（所有域名的）【热度: 469】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/860","page":"q/web应用场景-860.html","excerpt":"统计用户 PV（页面访问量）期间发起的请求数量（涵盖所有域名）可以通过几种方法实现，包括使用浏览器的 Performance API、监听网络请求、或者通过服务端日志分析。每种方法有其优点和适用场景。下面是一些方法的简要说明和示例： 方法 1: 使用 Performance API Performance API 提供"},{"id":"859","title":"在页面关闭时执行方法，该如何做【热度: 334】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/859","page":"q/web应用场景-859.html","excerpt":"**关键词**：beforeunload 和 unload 事件 在页面关闭时执行特定的方法，你可以使用 window 对象的 beforeunload 和 unload 事件。不过，这两个事件有一些微妙的区别和适用场景。 使用 beforeunload 事件 beforeunload 事件在窗口、文档或其资源即将卸载"},{"id":"858","title":"大文件切片上传的时候，确定切片数量的时候，有那些考量因素【热度: 366】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/858","page":"q/web应用场景-858.html","excerpt":"**关键词**：文件切片上传 大文件切片上传时，切片数量取决于几个关键因素：文件总大小、每个切片的大小（即切片大小），以及任何特定于应用或服务的限制。计算切片数量的过程包括确定合理的切片大小，然后根据文件总大小来计算需要多少个这样大小的切片。以下是一些步骤和考虑因素，可以帮助你确定切片数量： 1. 确定切片大小 **切"},{"id":"856","title":"如果在网络带宽一定的情况下， 切片上传感觉和整体上传， 消费的时间应该是差不多的。 这种说法正确吗【热度: 363】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/856","page":"q/web应用场景-856.html","excerpt":"**关键词**：切换上传合理性 这种说法在某些情况下是正确的，但实际上，切片上传相较于整体上传，在多种情况下可能更加高效，即使网络带宽固定。切片上传的优势并不仅仅在于可能节约的时间，还包括以下几点： 1. **提高上传的可靠性** 切片上传允许在遇到网络中断或其他传输错误时只重新上传失败的那一部分，而不是重新上传整个文"},{"id":"855","title":"如何判断页签是否为活跃状态【热度: 153】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/855","page":"q/web应用场景-855.html","excerpt":"**关键词**：页签活跃状态 判断页面页签（Tab）是否为活跃状态，可以通过监听 visibilitychange 事件来实现。这个事件是由 document 对象触发的，可以用来判断页面是否对用户可见。当用户切换到其他标签页、最小化浏览器窗口、或是锁屏时，页面就会变为不可见状态。如果页面对用户可见，那么页面就处于活跃"},{"id":"854","title":"如何组织工程项目【热度: 517】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/854","page":"q/web应用场景-854.html","excerpt":"**关键词**：组织工程项目 该话题是开放性话题，难度系数可高可低，请自己探索答案吧。"},{"id":"853","title":"移动端如何实现下拉滚动加载（顶部加载）【热度: 740】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/853","page":"q/web应用场景-853.html","excerpt":"**关键词**：移动端下拉加载 有现成的文档可以直接参考， 讲得非常的全面 文章链接： https://juejin.cn/post/7340836136208859174 一下是作者对于改文章的总结 原理 如图所示，蓝色框代表视口，绿色框代表容器，橙色框代表加载动画。最开始时，加载动画处于视口外；开始下拉之后，容器向"},{"id":"852","title":"PerformanceObserver 如何测量页面性能【热度: 190】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/852","page":"q/web应用场景-852.html","excerpt":"**关键词**：PerformanceObserver api 使用 PerformanceObserver API 是一个强大的浏览器接口，允许开发者订阅性能相关的事件，实时收集和分析用户当前浏览器会话中的性能数据。这个 API 是 Web 性能监测工具箱的一部分，与 window.performance 对象紧密协"},{"id":"851","title":"如何统计页面的 long task(长任务)【热度: 140】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/851","page":"q/web应用场景-851.html","excerpt":"**关键词**：统计 long task 统计网页中的 LongTask 是性能监控的一部分，特别是在测量和优化页面的响应能力方面非常有用。LongTask API 提供了一种监测浏览器主线程被长时间任务阻塞的能力，这些任务通常会影响用户体验，如使滚动卡顿或延迟输入响应。下面是一些基本步骤，帮助你开始监控 LongTa"},{"id":"850","title":"如何判断用户设备【热度: 551】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/850","page":"q/web应用场景-850.html","excerpt":"**关键词**：判断设备 在 Web 前端开发中，判断用户设备类型（如手机、平板、桌面电脑）主要依赖于用户代理字符串（User-Agent）和/或视口（Viewport）的尺寸。以下是一些常用方法： 使用用户代理字符串（User-Agent） 用户代理字符串包含了浏览器类型、版本、操作系统等信息，可以通过分析这些信息来"},{"id":"849","title":"介绍一下 navigator.sendBeacon 方法【热度: 66】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/849","page":"q/web应用场景-849.html","excerpt":"**关键词**：sendBeacon 发送请求 navigator.sendBeacon() 方法使得网页可以异步地将数据发送到服务器，与页面的卸载过程同时进行，这一点非常重要，因为它允许在不影响用户体验的情况下，安全地结束会话或者发送统计数据。这方法主要用于追踪和诊断信息，特别是在需要确保数据被成功发送到服务器的场景"},{"id":"847","title":"退出浏览器之间， 发送积压的埋点数据请求， 该如何做【热度: 134】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/847","page":"q/web应用场景-847.html","excerpt":"**关键词**：退出浏览器发送积压请求数据 退出浏览器时发送积压的埋点数据请求是 web 开发中的一个常见需求，尤其是在需要确保用户活动数据尽可能准确地被记录的场景下。实现这一需求的关键在于捕获用户关闭浏览器或离开页面的时刻，并在这一时刻尽可能快速地发送所有积压的数据。由于浏览器对于即将关闭时发出的请求处理方式不同，这"},{"id":"846","title":"滚动跟随导航（电梯导航）该如何实现【热度: 498】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/846","page":"q/web应用场景-846.html","excerpt":"**关键词**：电梯导航、混动导航 作者备注， 这个问题实际上是介于中等难度和 高难度之间的问题， 主要看怎么回答 文本回答涉及到了 IntersectionObserver + scrollIntoView 实现， 可以归为 「高」里面 具体 api 本文不再介绍， 可以直接翻看 MDN 即可 思路很简单， 利用 s"},{"id":"833","title":"[git] 将多次提交压缩成一次提交【热度: 412】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/833","page":"q/web应用场景-833.html","excerpt":"**关键词**：多次提交压缩成一次提交 将多次提交压缩成一次提交在 Git 中被称为“squash”。这通常在你完成一段工作后，想要将这段时间内的多个提交整理为一个更干净、更整洁的提交记录时使用。Git 提供了几种方法来实现提交的压缩，最常用的是通过 git rebase 命令配合交互模式（interactive mo"},{"id":"822","title":"【git] 当项目报错，你想定位是哪个 commit 引入的错误的时候，该怎么做【热度: 650】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/822","page":"q/web应用场景-822.html","excerpt":"**关键词**：二分法查找错误 commit 确实，当你不确定哪个提交(commit)引入了错误时，Git 提供了一个非常强大的工具 git bisect 来帮助你通过二分法快速定位出问题的提交。这个命令通过逐步缩小导致问题的提交范围，最终帮助你找出导致错误的具体提交。使用方法如下： 如何使用 git bisect *"},{"id":"821","title":"【git] 如何移除一个指定的 commit【热度: 762】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/821","page":"q/web应用场景-821.html","excerpt":"**关键词**：commit 移除 移除某一个指定的 commit 通常意味着要在版本控制系统如 Git 中更改历史记录，这通常涉及到一些操作风险，尤其是当这个 commit 已经被推送到远程仓库且被其他人使用。下面是几种常见的移除指定 commit 的方法，但在进行这些操作前，请确保备份你的代码，以防不测： 使用 g"},{"id":"811","title":"日志监控：如何还原用户操作流程【热度: 450】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/811","page":"q/web应用场景-811.html","excerpt":"**关键词**：日志监控 - 还原现场、日志监控 - 前端录制用户行为技术方案 需求 一种手段来获取用户某一时段连续的操作行为，也就是录制用户行为，包括整个会话中的每一个点击、滑动、输入等行为，同时支持回放录制的操作行为，完整且真实地重现用户行为以帮助我们回溯或分析某些使用场景。 实现方式 **方案对比** | 对比内"},{"id":"808","title":"日志监控问题：可有办法将请求的调用源码地址包括代码行数也上报上去？【热度: 814】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/808","page":"q/web应用场景-808.html","excerpt":"**关键词**：日志监控问题 在使用了代码混淆（例如 Webpack 的 mina-hash、chunkhash 或 contenthash）的前端代码中，即使执行了混淆，依然可以通过以下方法在日志监控时提供足够的上下文信息，主要包括被请求的源代码地址以及代码行数： 源码映射(Source Maps) **生成 Sou"},{"id":"806","title":"如何减少项目里面 if-else【热度: 310】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/806","page":"q/web应用场景-806.html","excerpt":"**关键词**：减少 if-else 当项目中存在大量的 if-else 语句时，可以考虑以下几种优化方法： 策略模式 创建一组策略对象，每个对象对应一种条件和处理逻辑。根据不同的条件选择相应的策略对象来执行操作。 表驱动法 建立一个数据结构（如对象或数组），将条件与对应的处理函数或值关联起来，通过查找表来获取相应的处"},{"id":"803","title":"如何实现预览 PDF 文件【热度: 173】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/803","page":"q/web应用场景-803.html","excerpt":"**关键词**：预览 PDF 文件 在前端实现 PDF 文件预览功能，主要有以下几种常用方法： 1. 使用浏览器内置的 PDF 查看器 浏览器像 Chrome 和 Firefox 等内置了 PDF 查看器，可以直接在浏览器中打开和预览 PDF 文件。实现方式非常简单，只需将 PDF 文件的 URL 设置为<a>标签的h"},{"id":"802","title":"如何在划词选择的文本上添加右键菜单（划词：鼠标滑动选择一组字符， 对组字符进行操作）【热度: 100】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/802","page":"q/web应用场景-802.html","excerpt":"**关键词**：DOM getSelection 方法 应用场景 主要考察 dom 方法， getSelection 属于很冷门知识， 只会在做过富文本的同学面试过程中可能会问得到。 要在划词选择的文本上添加右键菜单，可以按照以下步骤进行操作： 监听鼠标右键事件 在文档或富文本区域上添加 contextmenu 事件的"},{"id":"801","title":"富文本里面， 是如何做到划词的（鼠标滑动选择一组字符， 对组字符进行操作）？【热度: 100】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/801","page":"q/web应用场景-801.html","excerpt":"**关键词**：DOM getSelection 方法 主要考察 dom 方法， getSelection 属于很冷门知识， 只会在做过富文本的同学面试过程中可能会问得到。 在富文本环境中实现划词（鼠标滑动选择一组字符并对其进行操作）通常涉及以下几个关键步骤和技术： 事件监听 监听鼠标按下、鼠标移动和鼠标松开这三个主要"},{"id":"800","title":"如何做好前端监控方案【热度: 672】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/800","page":"q/web应用场景-800.html","excerpt":"**关键词**：前端监控 作者推荐可以直接参考下面这个文章就好了， 写的挺不错的。 https://juejin.cn/post/7285608128040206391 作者在这里， 对上面的文章进行一下简单的总结 **全文总结：** Web 前端监控的方案，包括前端监控的意义、内容、形式、总体方案设计、监控指标、前端"},{"id":"799","title":"如何标准化处理线上用户反馈的问题【热度: 631】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/799","page":"q/web应用场景-799.html","excerpt":"**关键词**：处理线上用户反馈 作者之所以要将这个问题定义为 【master】级别， 是因为这个问题， 说简单又简单， 说难又是有不小难度的。 作者认为：在一个团队里面， 能够快速解决用户的线上反馈问题， 这个是 中级、高级开发的能力要求。 但是，**在一个团队里面， 提供一个完整的线上问题反馈的解决方案， 是一个资"},{"id":"795","title":"axios 是否可以取消请求【热度: 532】","category":"web应用场景","labels":["网络","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/795","page":"q/web应用场景-795.html","excerpt":"**关键词**：取消请求 Axios 可以取消请求。官方文档指出有两种方法可以取消请求，分别是cancelToken和AbortController，示例代码如下： 使用cancelToken的方法一： 使用 cancelToken的方法二： 使用AbortController： 通过文档描述和示例代码，可以总结出以下"},{"id":"794","title":"前端如何实现折叠面板效果？【热度: 113】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/794","page":"q/web应用场景-794.html","excerpt":"**关键词**：transition 过度动画 以下是在您给出的折叠面板示例基础上添加动画效果的版本： **HTML 结构**（与您之前给出的相同） **CSS 样式** **JavaScript 功能** 这样，当点击折叠面板的标题时，内容会以平滑的动画效果展开或收起。您可以根据实际需求调整动画的时长和内容展开的最大"},{"id":"793","title":"dom 里面， 如何判定 a 元素是否是 b 元素的子元素【热度: 400】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/793","page":"q/web应用场景-793.html","excerpt":"**关键词**：dom.contains 方法 在 DOM（文档对象模型）中，要判断元素 a 是否是元素 b 的子元素，您可以使用以下的 JavaScript 代码： 可以这样使用上述函数："},{"id":"788","title":"请求失败会弹出一个 toast , 如何保证批量请求失败， 只弹出一个 toast【热度: 420】","category":"web应用场景","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/788","page":"q/web应用场景-788.html","excerpt":"**关键词**：单例 toast 要确保批量请求失败时只弹出一个 toast，可以通过以下几种方式实现： 设置全局标志位：定义一个全局变量（如 isToastShown）来表示是否已经弹出过 toast。在请求失败的处理逻辑中，首先检查该标志位。如果尚未弹出 toast，则进行弹出操作，并设置标志位为 true；如果标"},{"id":"786","title":"一般是怎么做代码重构的【热度: 191】","category":"web应用场景","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/786","page":"q/web应用场景-786.html","excerpt":"**关键词**：代码重构 在前端项目中进行代码重构，一般可以遵循以下步骤： 明确重构目标 确定需要解决的问题，例如提高代码的可读性、可维护性、性能，或者去除重复代码等。 代码分析 对现有代码进行全面的审查和理解，包括代码结构、逻辑流程、函数和模块之间的关系等。 可以使用工具如 ESLint 检查代码风格和潜在问题，使用"},{"id":"785","title":"如何清理源码里面没有被应用的代码， 主要是 JS、TS、CSS 代码【热度: 329】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/785","page":"q/web应用场景-785.html","excerpt":"**关键词**：代码清理 清理源码中未被应用的 JavaScript (JS)、TypeScript (TS) 和 CSS 代码的关键在于合理利用工具和策略，来识别和移除这些废弃的代码。下面是一份指南，帮助你高效完成这一任务： 对于 JavaScript 和 TypeScript 1. 使用 ESLint **初始化 "},{"id":"784","title":"前端应用 如何做国际化？【热度: 199】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/784","page":"q/web应用场景-784.html","excerpt":"**关键词**：国际化 前端应用实现国际化（i18n）主要是为了支持多语言环境，提高用户体验。这里有几种常用的方案： **使用国际化库**：这是最常用的方法之一，可以通过引用第三方库来管理不同语言环境的资源文件。比如： **React**：可以使用react-intl或react-i18next。 **Vue**：可以"},{"id":"773","title":"技术选型上有一些什么标准【热度: 622】","category":"web应用场景","labels":["web应用场景","PDD"],"url":"https://github.com/pro-collection/interview-question/issues/773","page":"q/web应用场景-773.html","excerpt":"**关键词**：技术选型 作者推荐一下五个标准，适用于编程语言、框架、大小工具库 等方向 可控性 稳定性 适用性 易用性 唯一性 当然，以下是对你提出的五个前端技术选型原则的详细描述： **可控性**： **定义**：选择的技术应该使团队能够对产品的开发过程有充分的控制，包括代码质量、部署流程、性能优化和错误处理等方面"},{"id":"759","title":"前端如何做 页面主题色切换【热度: 538】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/759","page":"q/web应用场景-759.html","excerpt":"**关键词**：主题色切换 页面主题色切换通常涉及到修改网页中的颜色方案，以提供不同的视觉体验，例如从明亮模式切换到暗黑模式。实现这一功能，可以通过配合使用 CSS、JavaScript 和本地存储来进行。以下是实施页面主题色切换的几种方法： 使用 CSS 自定义属性 定义一套主题变量： 应用自定义属性到 CSS 规则"},{"id":"757","title":"如何统计长任务时间、长任务执行次数【热度: 489】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/757","page":"q/web应用场景-757.html","excerpt":"**关键词**：长任务统计 在 JavaScript 中，可以使用 Performance API 中的 PerformanceObserver 来监视和统计长任务（Long Task）。长任务是指那些执行时间超过 50 毫秒的任务，这些任务可能会阻塞主线程，影响页面的交互性和流畅性。 使用 PerformanceOb"},{"id":"743","title":"用 JS 写一个 cookies 解析函数， 输出结果为一个对象【热度: 137】","category":"web应用场景","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/743","page":"q/web应用场景-743.html","excerpt":"**关键词**：解析 cookies 当然可以，以下是一个简单的 JavaScript 函数，用于解析当前页面的 cookie 并将它们存储到一个对象中： 这个函数首先会以分号 ; 分割 document.cookie 字符串来得到各个 cookie 键值对，然后移除键值对前后的任何空格。接着寻找每个键值对中的等号 ="},{"id":"735","title":"git pull 和 git fetch 有啥区别？【热度: 355】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/735","page":"q/web应用场景-735.html","excerpt":"**关键词**：git pull 和 git fetch git pull 和 git fetch 是 Git 版本控制系统中的两个基本命令，它们都用于从远程仓库更新本地仓库的信息，但执行的具体操作不同。 git fetch git fetch 下载远程仓库最新的内容到你的本地仓库，但它并不自动合并或修改你当前的工作。"},{"id":"734","title":"站点如何防止爬虫？【热度: 554】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/734","page":"q/web应用场景-734.html","excerpt":"**关键词**：反爬虫 站点防止爬虫通常涉及一系列技术和策略的组合。以下是一些常用的方法： 1. 修改 robots.txt 在站点的根目录下创建或修改 robots.txt 文件，用来告知遵守该协议的爬虫应该爬取哪些页面，哪些不应该爬取。例如： 然而，需要注意的是遵守 robots.txt 不是强制性的，恶意爬虫可以"},{"id":"722","title":"documentFragment api 是什么， 有哪些使用场景？【热度: 115】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/722","page":"q/web应用场景-722.html","excerpt":"**关键词**：documentFragment 概念、documentFragment 使用场景 DocumentFragment 是 Web API 中的一部分，它是 DOM （文档对象模型）的一个非常轻量级的节点，代表一组 DOM 节点的集合。它不是一个真实存在于 DOM 中的实体，因此被认为是“没有名字”的节点"},{"id":"718","title":"介绍一下 requestIdleCallback api【热度: 290】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/718","page":"q/web应用场景-718.html","excerpt":"**关键词**：requestIdleCallback api、requestIdleCallback 使用场景 requestIdleCallback 是一个 Web API，它允许开发者请求浏览器在主线程空闲时执行一些低优先级的后台任务，这对于执行如分析、整理状态和数据等不紧急的任务是理想的。这种方法可以提高用户的"},{"id":"714","title":"不同标签页或窗口间的 【主动推送消息机制】 的方式有哪些？（不借助服务端）【热度: 401】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/714","page":"q/web应用场景-714.html","excerpt":"**关键词**：不同页签信息主动推送 在不借助服务器端的帮助下，实现不同标签页或窗口间的主动推送消息机制，可以使用以下客户端技术： 作者备注： 这里要注意一下， 这里讨论的不是跨页签通信，而是**跨页签主动推送信息** 。如果仅仅是跨页签通信， 那么浏览器的本地存储都可以都可以使用了。 所以排除了本地存储类 API 的"},{"id":"712","title":"html的行内元素和块级元素的区别【热度: 796】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/712","page":"q/web应用场景-712.html","excerpt":"**关键词**：行内元素、块级元素 HTML 中的行内元素（Inline elements）和块级元素（Block-level elements）在布局行为、外观以及如何参与文档流方面有所不同。以下是它们的主要区别： | 特性 | 块级元素(Block-level elements) | 行内元素(Inline ele"},{"id":"711","title":"[React] react-router 和 原生路由区别【热度: 434】","category":"web应用场景","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/711","page":"q/web应用场景-711.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 React Router 和浏览器原生 history API 在路由管理上主要有以下几个区别： **抽象级别**: **React Router** 提供了更高层次的抽象，如 <Router>、<Route>、和 <Link> 等组件，这些都是专门为"},{"id":"710","title":"[React] 在 react 项目开发过程中， 是否可以不用 react-router， 使用浏览器原生 history 路由来组织页面路由？【热度: 632】","category":"web应用场景","labels":["web框架","web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/710","page":"q/web应用场景-710.html","excerpt":"**关键词**：react router 路由、浏览器原生路由能力 作者备注 此问题实际上是在问：原生 路由 history api 和 react-router 的差距是啥， 或者说 react-router 做了啥 在 React 项目中，你完全可以不使用 react-router 而是使用浏览器原生的 histo"},{"id":"708","title":"介绍一下 scrollIntoView api【热度: 286】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/708","page":"q/web应用场景-708.html","excerpt":"**关键词**：scrollIntoView api scrollIntoView 是一个 Web API，允许网页开发者控制元素如何被滚动到浏览器的可视区域。这个方法可以对任何 Element 使用，以改变窗口的滚动位置，以便最终元素位于屏幕可见范围内。它对于某些需要用户立即看到的表单错误、警告，或者在执行完某些操作"},{"id":"707","title":"在表单校验场景中， 如何实现页面视口滚动到报错的位置【热度: 248】","category":"web应用场景","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/707","page":"q/web应用场景-707.html","excerpt":"**关键词**：滚动到页面视口 基本原理 页面是用户与程序进行交互的界面，在对应表单校验场景中，通常会因为有填写错误需要用户进行修改。为了提高用户体验，可以将页面滚动至对应表单报错的位置，使得用户立即可见错误并进行修改。这通常可以通过 JavaScript 编程实现。 要注意的是，实现滚动至错误表单，一般需要几个步骤："},{"id":"706","title":"交叉观察器 API IntersectionObserver 详解【热度: 665】","category":"web应用场景","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/706","page":"q/web应用场景-706.html","excerpt":"**关键词**：交叉观察器 API、IntersectionObserver 详解 IntersectionObserver API 是现代浏览器提供的一个强大的 API，用于性能友好地跟踪元素是否进入、离开或穿过另一个元素（通常是视口）的边界。这个 API 特别适用于执行懒加载、实现无限滚动、检测广告展示等功能，因为"},{"id":"705","title":"滚动混动加载原理是什么， 用 JS 代码简单实现一个虚拟滚动加加载。【热度: 354】","category":"web应用场景","labels":["web应用场景","小红书"],"url":"https://github.com/pro-collection/interview-question/issues/705","page":"q/web应用场景-705.html","excerpt":"**关键词**：虚拟滚动、虚拟加载 原理 虚拟滚动（Virtual Scrolling）是一种性能优化的手段，通常用于处理长列表的显示问题。在传统的滚动加载中，当面对成千上万项的长列表时，直接在 DOM 中创建并展示所有项会导致严重的性能问题，因为浏览器需要渲染所有的列表项。而虚拟滚动的核心原理是仅渲染用户可视范围内的"},{"id":"704","title":"如何一次性渲染十万条数据还能保证页面不卡顿【热度: 426】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/704","page":"q/web应用场景-704.html","excerpt":"原理其实就是 通过 requestAnimationFrame 实现分块儿加载。 requestAnimationFrame + fragment（时间分片） 既然定时器的执行时间和浏览器的刷新率不一致，那么我就可以用requestAnimationFrame来解决 requestAnimationFrame也是个定时"},{"id":"686","title":"应用上线后， 怎么通知用户刷新当前页面？【热度: 466】","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/686","page":"q/web应用场景-686.html","excerpt":"**关键词**：静态资源更新、页面版本更新、服务端推送 **关键词**：静态资源更新、页面版本更新 这个话题非常的有意思，问题的答案是比较开发的，这里仅代表作者本人的个人经验来做回答。 当然也可以自行去搜集掘金上的大佬们的博文。 首先第一个问题 **用户在没有页面刷新的情况下， 如何去感知前端静态资源已经发生了更新？*"},{"id":"684","title":"Eslint 代码检查的过程是啥？【热度: 111】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/684","page":"q/web应用场景-684.html","excerpt":"**关键词**：eslint 代码检测、eslint 代码检测 执行过程 ESLint 是一个插件化的静态代码分析工具，用于识别 JavaScript 代码中的问题。它在代码质量和编码风格方面有助于保持一致性。代码检查的过程通常如下： **配置**： 首先需要为 ESLint 提供一套规则，这些规则可以在.eslint"},{"id":"679","title":"如何检测网页空闲状态(一定时间内无操作)【热度: 329】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/679","page":"q/web应用场景-679.html","excerpt":"如何判断页面是否空闲 首先，我们要知道什么是空闲？用户一定时间内，没有对网页进行任何操作，则当前网页为空闲状态。 用户操作网页，无非就是通过鼠标、键盘两个输入设备(暂不考虑手柄等设备)。因而我们可以监听相应的输入事件，来判断网页是否空闲(用户是否有操作网页)。 监听鼠标移动事件mousemove； 监听键盘按下事件mo"},{"id":"677","title":"JS 放在 head 里和放在 body 里有什么区别？【热度: 420】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/677","page":"q/web应用场景-677.html","excerpt":"将 JavaScript 代码放在 <head> 标签内部和放在 <body> 标签内部有一些区别： **加载顺序**：放在 <head> 里会在页面加载之前执行 JavaScript 代码，而放在 <body> 里会在页面加载后执行。 **页面渲染**：如果 JavaScript 代码影响了页面的布局或样式，放在 <"},{"id":"672","title":"JS 执行 100 万个任务， 如何保证浏览器不卡顿？【热度: 806】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/672","page":"q/web应用场景-672.html","excerpt":"**关键词**：大批量执行任务不卡顿 **Web Workers** 要确保浏览器在执行100万个任务时不会卡顿，你可以考虑使用Web Workers来将这些任务从主线程中分离出来。Web Workers允许在后台线程中运行脚本，从而避免阻塞主线程，保持页面的响应性。 以下是一个使用Web Workers的简单示例： "},{"id":"668","title":"权限管理模型相关概念【热度: 670】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/668","page":"q/web应用场景-668.html","excerpt":"**关键词**：权限管理模型 常见的权限管理模型 **DAC (Discretionary Access Control):** 用户对资源有自主权，资源的所有者可以自由地授予或撤销其他用户的访问权限。 **MAC (Mandatory Access Control):** 系统管理员定义了一组强制性的规则，控制用户对"},{"id":"666","title":"git 仓库迁移应该怎么操作【热度: 160】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/666","page":"q/web应用场景-666.html","excerpt":"**关键词**：git 仓库迁移 如果你想迁移仓库并保留原始仓库的所有提交历史、分支和标签，你可以使用以下步骤： 方法一：使用 git clone 和 git push **在仓库 B 中创建新的仓库。** **在本地克隆仓库 A：** 使用 --mirror 选项克隆仓库会保留所有分支、标签和提交历史。 **修改远程"},{"id":"663","title":"如何禁止别人调试自己的前端页面代码?【热度: 347】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/663","page":"q/web应用场景-663.html","excerpt":"**关键词**：禁止别人调试自己的前端代码 **无限 debugger** 前端页面防止调试的方法主要是通过不断 debugger 来疯狂输出断点，因为 debugger 在控制台被打开的时候就会执行 由于程序被 debugger 阻止，所以无法进行断点调试，所以网页的请求也是看不到的 基础代码如下： **无限 deb"},{"id":"659","title":"OAuth2.0 是什么登录方式【热度: 210】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/659","page":"q/web应用场景-659.html","excerpt":"**关键词**：OAuth2.0 登录实现、OAuth2.0 鉴权 OAuth2.0并不是一种特定的登录方式，而是一种授权框架，用于授权第三方应用访问用户的资源。它被广泛应用于身份验证和授权的场景中。 OAuth2.0通过引入授权服务器、资源服务器和客户端等角色，实现了用户授权和资源访问的分离。具体流程如下： 用户向客"},{"id":"658","title":"单点登录是如何实现的？【热度: 647】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/658","page":"q/web应用场景-658.html","excerpt":"**关键词**：单点登录实现、单点登录流程 单点登录 单点登录：Single Sign On，简称SSO。用户只要登录一次，就可以访问所有相关信任应用的资源。企业里面用的会比较多，有很多内网平台，但是只要在一个系统登录就可以。 实现方案 单一域名：可以把 cookie 种在根域名下实现单点登录 多域名：常用 CAS来解"},{"id":"656","title":"常见的登录鉴权方式有哪些？【热度: 557】","category":"web应用场景","labels":["web应用场景","TOP100互联网"],"url":"https://github.com/pro-collection/interview-question/issues/656","page":"q/web应用场景-656.html","excerpt":"**关键词**：登录鉴权方式 前端登录鉴权的方式主要有以下几种： 基于Session Cookie的鉴权： cookie: 用户在登录成功后，服务器会生成一个包含用户信息的Cookie，并返回给前端。前端在后续的请求中会自动携带这个Cookie，在服务器端进行验证和识别用户身份。 Session: 用户登录成功后，服务"},{"id":"640","title":"后端一次性返回树形结构数据，数据量非常大, 前端该如何处理？【热度: 171】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/640","page":"q/web应用场景-640.html","excerpt":"**关键词**：大数据处理 当后端一次性返回的树形结构数据量非常大，导致前端一次性计算和渲染会栈溢出的情况时，可以考虑以下几种处理方式： 分批处理：将大量的树形数据分为多个批次进行处理和渲染。前端可以通过递归或循环的方式，每次处理一部分数据，并在渲染完成后再处理下一部分数据。这样可以避免一次性处理大量数据造成栈溢出的问"},{"id":"639","title":"你认为组件封装的一些基本准则是什么？【热度: 625】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/639","page":"q/web应用场景-639.html","excerpt":"**关键词**：组件封装原则 组件封装的一些基本准则包括： 单一职责原则：一个组件应该具有单一的功能，并且只负责完成该功能，避免组件过于庞大和复杂。 高内聚低耦合：组件内部的各个部分之间应该紧密相关，组件与其他组件之间应该尽量解耦，减少对外部的依赖。 易用性：组件应该易于使用，提供清晰的接口和文档，使用户能够方便地使用"},{"id":"635","title":"前端日志埋点 SDK 设计思路【热度: 755】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/635","page":"q/web应用场景-635.html","excerpt":"**关键词**：前端埋点监控、埋点 SDK 设计 前端日志埋点 SDK 设计思路 既然涉及到了日志和埋点，分析一下需求是啥： 自动化上报 页面 PV、UV。 如果能自动化上报页面性能， 用户点击路径行为，就更好了。 自动上报页面异常。 发送埋点信息的时候， 不影响性能， 不阻碍页面主流程加载和请求发送。 能够自定义日志"},{"id":"633","title":"token 进行身份验证了解多少？【热度: 942】","category":"web应用场景","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/633","page":"q/web应用场景-633.html","excerpt":"**关键词**：身份验证、token 验证 token 概念和作用 Token是一种用于身份验证和授权的令牌。在Web应用程序中，当用户进行登录或授权时，服务器会生成一个Token并将其发送给客户端。客户端在后续的请求中将Token作为身份凭证携带，以证明自己的身份。 Token可以是一个字符串，通常是经过加密和签名的"},{"id":"632","title":"在前端应用如何进行权限设计？【热度: 329】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/632","page":"q/web应用场景-632.html","excerpt":"**关键词**：权限设计 在前端应用的权限设计中，以下是一些建议： 角色与权限分离 将用户的权限分为不同的角色，每个角色拥有特定的权限。 这样可以简化权限管理，并且当需求变化时，只需要调整角色的权限，而不需要逐个修改用户的权限。 **在角色与权限分离的设计中，可以按照以下几个步骤进行** 确定权限集合：首先，需要确定系"},{"id":"603","title":"为何现在市面上做表格渲染可视化技术的，大多数都是 canvas ， 而很少用 svg 的？【热度: 302】","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/603","page":"q/web应用场景-603.html","excerpt":"**关键词**：canvas使用场景、canvas可视化、svg使用场景 都用上了可视化技术做渲染， 在这个场景下， 大多数考虑的是性能； 所以主要基于几个方面去衡量技术方案的选择： 性能、动态交互、复杂图形支持 性能：Canvas 通常比 SVG 具有更好的性能。Canvas 是基于像素的绘图技术，而 SVG 是基于"},{"id":"569","title":"前端有哪些跨页面通信方式？【热度: 791】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/569","page":"q/web应用场景-569.html","excerpt":"在前端中，有多种跨页面通信的方式，下面列举了其中一些常见的方式： **使用URL参数**：可以通过URL参数在不同页面之间传递数据。例如，可以在URL中添加查询字符串参数来传递数据，并通过解析URL参数来获取传递的数据。 **使用localStorage或sessionStorage**：可以使用浏览器的本地存储（lo"},{"id":"555","title":"vue-cli 都做了哪些事儿，有哪些功能？【热度: 386】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/555","page":"q/web应用场景-555.html","excerpt":"**关键词**：vue-cli 作用、vue-cli 功能 Vue CLI 是一个基于 Vue.js 的命令行工具，用于快速搭建、开发和构建 Vue.js 项目。它提供了一系列的功能来简化 Vue.js 项目的开发和部署流程，包括： 项目脚手架：Vue CLI 可以通过简单的命令行交互方式快速生成一个新的 Vue.js"},{"id":"554","title":"如何理解数据驱动视图， 有哪些核心要素？【热度: 943】","category":"web应用场景","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/554","page":"q/web应用场景-554.html","excerpt":"**关键词**：理解数据驱动视图 数据驱动视图是指将数据作为主要驱动力，通过对数据的处理和分析，动态地更新和呈现视图的过程。它强调将数据与视图进行解耦，使得视图的呈现可以根据数据的变化自动更新，实现更灵活、可扩展和可维护的视图。 数据驱动视图的核心要素包括： 数据源：数据驱动视图需要有一个或多个数据源，这些数据源可以是"},{"id":"549","title":"用户访问页面白屏了， 原因是啥， 如何排查？【热度: 609】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/549","page":"q/web应用场景-549.html","excerpt":"**关键词**：白屏处理办法 用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤： 网络问题：用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。 服务端问题：服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和"},{"id":"548","title":"如果用户反馈说感觉网页很卡顿，这个时候该如何排查问题?【热度: 768】","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/548","page":"q/web应用场景-548.html","excerpt":"**关键词**：网页卡顿、网页卡顿处理办法 排查网页卡顿问题时，可以按照以下步骤进行处理： 验证用户反馈：首先，确认用户反馈的卡顿问题是否普遍存在，还是个别用户的特殊情况。可以与其他用户进行沟通或观察其他设备上的表现。 检查网络连接：检查用户的网络连接是否稳定。卡顿问题可能由于网络延迟或不稳定导致。可以要求用户进行网络"},{"id":"544","title":"web 网页如何禁止别人移除水印【热度: 540】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/544","page":"q/web应用场景-544.html","excerpt":"**关键词**：前端防止移除水印 关于加水印的问题， 可以看这篇文档： https://github.com/pro-collection/interview-question/issues/351 关于如何防止移除水印： 可以通过监听 DOM 的变化来检测是否有人删除水印，可以使用 MutationObserver "},{"id":"533","title":"单点登录是什么， 具体流程是什么【热度: 1,168】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/533","page":"q/web应用场景-533.html","excerpt":"**关键词**：单点登录流程 SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport"},{"id":"496","title":"[React] 如何进行路由变化监听【热度: 698】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/496","page":"q/web应用场景-496.html","excerpt":"**关键词**：React 路由、React 路由监听 在 React 中，你可以使用 React Router 库来进行路由变化的监听。React Router 是 React 的一个常用路由库，它提供了一组组件和 API 来帮助你在应用中管理路由。 下面是一个示例代码，演示如何使用 React Router 监听路"},{"id":"493","title":"为什么 SPA 应用都会提供一个 hash 路由，好处是什么？【热度: 681】","category":"web应用场景","labels":["web应用场景","快手"],"url":"https://github.com/pro-collection/interview-question/issues/493","page":"q/web应用场景-493.html","excerpt":"**关键词**：hash路由优势、hash路由和history路由区别 SPA（单页应用）通常会使用 hash 路由的方式来实现页面的导航和路由功能。这种方式将路由信息存储在 URL 的片段标识符（hash）中，例如：www.example.com/#/home。 以下是使用 hash 路由的 SPA 的一些好处： 兼"},{"id":"485","title":"script 标签上有那些属性，分别作用是啥？【热度: 744】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/485","page":"q/web应用场景-485.html","excerpt":"**关键词**：script 标签属性、script 标签属性作用、常用 script 标签属性 在HTML中，<script>标签用于引入或嵌入JavaScript代码。<script>标签可以使用以下属性来调整脚本的行为： **常用属性** src：指定要引入的外部JavaScript文件的URL。例如：<scri"},{"id":"473","title":"package.json 里面 sideEffects 属性的作用是啥【热度: 629】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/473","page":"q/web应用场景-473.html","excerpt":"**关键词**：sideEffects作用、package.json sideEffects 属性、webpack Tree Shaking 优化、Tree Shaking 优化 sideEffects 作用 sideEffects是package.json文件中的一个字段，它用于指定一个模块是否具有副作用。副作用是指"},{"id":"472","title":"用 nodejs 实现一个命令行工具， 统计输入目录下面指定代码的行数【热度: 732】","category":"web应用场景","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/472","page":"q/web应用场景-472.html","excerpt":"**关键词**：统计指定目录下代码行数 要实现一个命令行工具来统计输入目录下指定代码的行数，你可以使用Node.js的fs模块来读取文件内容并进行行数统计。以下是一个简单的实现示例： 你可以将上述代码保存为一个JavaScript文件，比如line-counter.js。然后，在终端中运行以下命令： 其中/path/t"},{"id":"471","title":"webpack 如何配置按需加载的模块【热度: 693】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/471","page":"q/web应用场景-471.html","excerpt":"**关键词**：webpack 配置按需加载、webpack 按需加载、react lazy 加载 如何配置 webpack 按需加载 要配置webpack项目模块按需加载，你可以使用webpack的代码分割（code splitting）功能和动态导入（dynamic import）语法。 以下是一些配置步骤： 在w"},{"id":"470","title":"如果不使用脚手架， 如果用 webpack 构建一个自己的 react 应用【热度: 729】","category":"web应用场景","labels":["web应用场景","快手"],"url":"https://github.com/pro-collection/interview-question/issues/470","page":"q/web应用场景-470.html","excerpt":"**关键词**：构建 react 应用 利用 webpack 初始化基本应用构建 要在Webpack配置中添加对Less和Ant Design组件库的支持，需要进行以下步骤： 安装所需的依赖。 在Webpack配置文件中添加对Less的支持。 在入口文件中引入Ant Design的样式文件。 现在你可以在React组件"},{"id":"469","title":"如何通过设置失效时间清除本地存储的数据？【热度: 1,085】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/469","page":"q/web应用场景-469.html","excerpt":"**关键词**：定时清除本地存储 要清除本地存储的数据，可以通过设置失效时间来实现。以下是一种常见的方法： 将数据存储到本地存储中，例如使用localStorage或sessionStorage。 在存储数据时，同时设置一个失效时间。可以将失效时间存储为一个时间戳或特定的日期时间。 在读取数据时，检查当前时间是否超过了"},{"id":"468","title":"前端如何用 canvas 来做电影院选票功能","category":"web应用场景","labels":["web应用场景","网易"],"url":"https://github.com/pro-collection/interview-question/issues/468","page":"q/web应用场景-468.html","excerpt":"电影院选票功能可以通过 Canvas 来实现，具体实现步骤如下： 绘制座位图案：使用 Canvas 绘制座位图案，可以用矩形或圆形来表示每个座位，还可以添加不同颜色来表示该座位的状态（已售、已选、可选等）。 添加鼠标事件：添加鼠标事件，如鼠标移动、鼠标单击等，来实现用户交互操作。例如，当用户点击座位时，将该座位的状态改"},{"id":"458","title":"如何判断dom元素是否在可视区域【热度: 846】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/458","page":"q/web应用场景-458.html","excerpt":"**关键词**：元素是否在可视区域 判断 DOM 元素是否在可视区域可以使用以下方法： getBoundingClientRect() 方法 该方法返回元素的大小及其相对于视口的位置，包括 top、right、bottom、left 四个属性。我们可以根据这四个属性来判断元素是否在可视区域内。 Intersection"},{"id":"446","title":"移动端如何实现上拉加载，下拉刷新？【热度: 718】","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/446","page":"q/web应用场景-446.html","excerpt":"**关键词**：上拉加载、下拉刷新 移动端实现上拉加载和下拉刷新通常使用一些特定的库或框架来简化开发。以下是两种常见的实现方式： 使用第三方库：一些流行的移动端UI库（如iScroll、BetterScroll、Ant Design Mobile等）提供了上拉加载和下拉刷新的功能，你可以使用它们来实现。这些库通常提供了"},{"id":"429","title":"html 中前缀为 data- 开头的元素属性是什么？【热度：903】","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/429","page":"q/web应用场景-429.html","excerpt":"HTML 中前缀为 data- 开头的元素属性被称为自定义数据属性（Custom Data Attributes）或者数据属性（Data Attributes）。 这些属性的命名以 data- 开头，后面可以跟上任意自定义的名称。这样的属性可以用来存储与元素相关的自定义数据，以便在 JavaScript 或 CSS 中"},{"id":"428","title":"web 应用中如何对静态资源加载失败的场景做降级处理【热度: 1,093】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/428","page":"q/web应用场景-428.html","excerpt":"**关键词**：静态资源降级、静态资源加载失败 在 Web 应用中，可以使用以下方法对静态资源加载进行降级处理，即在某个资源加载失败时使用备用的静态资源链接： 使用多个 CDN 链接：在 HTML 中使用多个静态资源链接，按照优先级顺序加载，如果其中一个链接加载失败，则尝试加载下一个链接。 在加载 JavaScript"},{"id":"391","title":"小程序为什么会有两个线程","category":"web应用场景","labels":["web应用场景","Shopee"],"url":"https://github.com/pro-collection/interview-question/issues/391","page":"q/web应用场景-391.html","excerpt":"小程序之所以有两个线程，是为了实现小程序的高效运行和良好的用户体验。 渲染线程（UI 线程）： 渲染线程负责小程序界面的渲染和响应用户的交互。它使用 WebView 进行页面渲染，包括解析和绘制 DOM、布局、样式计算和渲染等操作。渲染线程是单线程的，所有的界面操作都在这个线程中进行。 逻辑线程（JS 线程）： 逻辑线"},{"id":"378","title":"常见 web 安全解析【热度: 1,968】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/378","page":"q/web应用场景-378.html","excerpt":"**关键词**：XSS攻击、CSRF攻击、点击劫持共计、URL跳转漏洞、SQL注入攻击、OS命令注入攻击 参考文档： https://github.com/ljianshu/Blog/issues/56"},{"id":"375","title":"深度 SEO 优化的方式有哪些， 从技术层面来说","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/375","page":"q/web应用场景-375.html","excerpt":"深度 SEO 优化涉及到一些技术层面的优化策略，以下是一些常见的方式： 网站结构优化：优化网站的结构，确保每个页面都可以被搜索引擎爬取和索引。使用合适的 HTML 标签和语义化的内容结构，使搜索引擎能够更好地理解页面的内容。 网站速度优化：提升网站的加载速度对 SEO 很重要。通过压缩和合并 CSS 和 JavaScr"},{"id":"369","title":"一直在 window 上面挂东西是否有什么风险","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/369","page":"q/web应用场景-369.html","excerpt":"在前端开发中，将内容或应用程序运行在浏览器的全局window对象上可能会带来一些潜在的风险。以下是一些需要注意的风险： 命名冲突：window对象是浏览器的全局对象，它包含许多内置属性和方法。如果您在全局命名空间中定义的变量或函数与现有的全局对象属性或方法发生冲突，可能会导致意外行为或错误。 安全漏洞：在全局windo"},{"id":"368","title":"什么是领域模型【热度: 1,092】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/368","page":"q/web应用场景-368.html","excerpt":"**关键词**：前端领域模型 什么是领域模型 领域模型是软件开发中用于描述领域（业务）概念和规则的一种建模技术。它通过定义实体、值对象、关联关系、行为等元素，抽象出领域的核心概念和业务规则，帮助开发人员理解和设计软件系统。 以下是领域模型中常见的一些元素： 实体（Entity）：实体是领域模型中具有唯一标识的对象，通常"},{"id":"367","title":"react native 工作原理是什么？","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/367","page":"q/web应用场景-367.html","excerpt":"React Native是一种基于JavaScript的开发框架，用于构建移动应用程序。它允许开发人员使用React的组件化开发模式来构建原生移动应用，同时跨平台共享代码。 工作原理如下： JavaScript线程：React Native的应用程序逻辑是通过JavaScript代码来编写的。React Native应"},{"id":"358","title":"base64 的编码原理是什么","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/358","page":"q/web应用场景-358.html","excerpt":"Base64编码是一种用于将二进制数据转换为可打印ASCII字符的编码方式。它的原理如下： 将原始数据划分为连续的字节序列。 将每个字节转换为8位二进制数。 将这些二进制数按照6位一组进行分组，不足6位的用0补齐。 将每个6位的二进制数转换为对应的十进制数。 根据Base64字符表，将十进制数转换为相应的可打印ASCI"},{"id":"351","title":"前端水印了解多少？【热度: 641】","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/351","page":"q/web应用场景-351.html","excerpt":"**关键词**：前端 明水印 暗水印 明水印和暗水印的区别 前端水印可以分为明水印和暗水印两种类型。它们的区别如下： 明水印：明水印是通过在文本或图像上覆盖另一层图像或文字来实现的。这种水印会明显地出现在页面上，可以用来显示版权信息或其他相关信息。 暗水印：暗水印是指在文本或图像中隐藏相关信息的一种技术。这种水印不会直"},{"id":"337","title":"函数式编程了解多少？【热度: 1,789】","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/337","page":"q/web应用场景-337.html","excerpt":"**关键词**：函数式编程 函数式编程的核心概念 函数式编程是一种编程范式，它将程序看做是一系列函数的组合，函数是应用的基础单位。函数式编程主要有以下核心概念： 纯函数：函数的输出只取决于输入，没有任何副作用，不会修改外部变量或状态，所以对于同样的输入，永远返回同样的输出值。因此，纯函数可以有效地避免副作用和竞态条件等"},{"id":"332","title":"DNS 协议了解多少【热度: 712】","category":"web应用场景","labels":["网络","web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/332","page":"q/web应用场景-332.html","excerpt":"**关键词**：DNS协议、DNS加速 DNS 基本概念 DNS（Domain Name System，域名系统）是因特网上用于将主机名转换为 IP 地址的协议。它是一个分布式数据库系统，通过将主机名映射到 IP 地址来实现主机名解析，并使用户能够通过更容易识别的主机名来访问互联网上的资源。 在使用 DNS 协议进行主"},{"id":"331","title":"扫码登录实现方式【热度: 734】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/331","page":"q/web应用场景-331.html","excerpt":"**关键词**：扫码登录 扫码登录的实现原理核心是基于一个中转站，该中转站通常由应用提供商提供，用于维护手机和PC之间的会话状态。 整个扫码登录的流程如下： 用户在PC端访问应用，并选择使用扫码登录方式。此时，应用生成一个随机的认证码，并将该认证码通过二维码的形式显示在PC端的页面上。 用户打开手机上的应用，并选择使用"},{"id":"330","title":"cookie 构成部分有哪些【热度: 598】","category":"web应用场景","labels":["浏览器","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/330","page":"q/web应用场景-330.html","excerpt":"**关键词**：cookie 构成部分、cookie 作用路径、cookie 作用域 在 HTTP 协议中，cookie 是一种包含在请求和响应报文头中的数据，用于在客户端存储和读取信息。cookie 是由服务器发送的，客户端可以使用浏览器 API 将 cookie 存储在本地进行后续使用。 一个 cookie 通常由"},{"id":"329","title":"常见图片懒加载方式有哪些？【热度: 1,001】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/329","page":"q/web应用场景-329.html","excerpt":"**关键词**：图片懒加载、Intersection Observer API 图片懒加载可以延迟图片的加载，只有当图片即将进入视口范围时才进行加载。这可以大大减轻页面的加载时间，并降低带宽消耗，提高了用户的体验。以下是一些常见的实现方法： Intersection Observer API Intersection "},{"id":"328","title":"script 预加载方式有哪些， 这些加载方式有何区别？【热度: 420】","category":"web应用场景","labels":["浏览器","web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/328","page":"q/web应用场景-328.html","excerpt":"**关键词**：script 预加载 在浏览器中，可以通过预加载 JavaScript 脚本来提高性能和用户体验。预加载是指在浏览器解析完当前页面之前，提前加载并解析相关资源（例如 JavaScript 文件、CSS 文件等）。这样可以在用户请求访问其他页面时，减少资源加载的时间和延迟，从而提高页面加载速度和用户体验。"},{"id":"308","title":"web components 了解多少？【热度: 1,206】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/308","page":"q/web应用场景-308.html","excerpt":"Web Components 是一套不同的技术，允许您创建可重用的定制元素并且在您的 web 应用中使用它们 三要素 Custom elements（自定义元素）： 一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。 通过 class A"},{"id":"307","title":"CSR、SSR、SSG、NSR、ESR、ISR 都是啥？【热度: 3,492】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/307","page":"q/web应用场景-307.html","excerpt":"CSR、SSR、SSG、NSR、ESR、ISR 都是啥？ 根据不同的构建、渲染过程有不同的优劣势和适用情况。 现代 UI 库加持下常用的 CSR、 具有更好 SEO 效果的 SSR (SPR)、 转换思路主打**构建时生成**的 SSG、 大架构视野之上的 ISR、DPR， 还有更少听到的 NSR、ESR。 CSR(C"},{"id":"298","title":"git merge 和 git rebase 区别【热度: 1,150】","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/298","page":"q/web应用场景-298.html","excerpt":"git merge 和 git rebase 都是用来合并不同分支的命令，但是它们的实现方式和结果不同。 git merge 会把两个分支的最新提交点合并起来，生成一个新的合并提交，并且会保留两个分支各自的提交记录，形成一条分支合并的历史线。合并后的代码中，两个分支的修改都会被保留下来。 git rebase 也是用来"},{"id":"294","title":"如何实现网页加载进度条？","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/294","page":"q/web应用场景-294.html","excerpt":"监听静态资源加载情况 可以通过 window.performance 对象来监听页面资源加载进度。该对象提供了各种方法来获取资源加载的详细信息。 可以使用 performance.getEntries() 方法获取页面上所有的资源加载信息。可以使用该方法来监测每个资源的加载状态，计算加载时间，并据此来实现一个资源加载进"},{"id":"293","title":"站点一键换肤的实现方式有哪些？","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/293","page":"q/web应用场景-293.html","excerpt":"网站一键换肤实现方式有以下几种 使用 CSS 变量：通过定义一些变量来控制颜色、字体等，然后在切换主题时动态修改这些变量的值。 使用 class 切换：在 HTML 的根元素上添加不同的 class 名称，每个 class 名称对应不同的主题样式，在切换主题时切换根元素的 class 名称即可。 使用 JavaScri"},{"id":"292","title":"H5 如何解决移动端适配问题","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/292","page":"q/web应用场景-292.html","excerpt":"移动端适配问题是指如何让网页在不同的移动设备上显示效果相同。下面是一些常见的 H5 移动端适配方案： 使用 viewport 标签 通过设置 viewport 标签的 meta 属性，来控制页面的缩放比例和宽度，以适配不同的设备。例如： 其中 width=device-width 表示设置 viewport 的宽度为设"},{"id":"278","title":"大文件上传了解多少","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/278","page":"q/web应用场景-278.html","excerpt":"大文件分片上传 如果太大的文件，比如一个视频1g 2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分 比如2M。 Blob 它表示原始数据, 也就是二进制数据，同时提供了对数据截取的方法 sli"},{"id":"256","title":"Server-sent events(SSE) 了解多少（服务端推送）","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/256","page":"q/web应用场景-256.html","excerpt":"一个网页获取新的数据通常需要发送一个请求到服务器，也就是向服务器请求的页面。使用 server-sent 事件，服务器可以在任何时刻向我们的 Web 页面推送数据和信息。这些被推送进来的信息可以在这个页面上作为 Events + data 的形式来处理。 从服务器接受事件 服务器发送事件 API 也就是 EventSo"},{"id":"254","title":"Service Worker 是如何缓存 http 请求资源的？","category":"web应用场景","labels":["web应用场景","京东"],"url":"https://github.com/pro-collection/interview-question/issues/254","page":"q/web应用场景-254.html","excerpt":"Service Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。 Service Worker 可以通过以下步骤来缓存 http 请求资源： 注册 Service Worker：通过在页面中注册 Service Work"},{"id":"252","title":"设计一套全站请求耗时统计工具","category":"web应用场景","labels":["web应用场景","阿里巴巴"],"url":"https://github.com/pro-collection/interview-question/issues/252","page":"q/web应用场景-252.html","excerpt":"首先我们要知道有哪些方式可以统计前端请求耗时 从代码层面上统计全站所有请求的耗时方式主要有以下几种： Performance API：Performance API 是浏览器提供的一组 API，可以用于测量网页性能。通过 Performance API，可以获取页面各个阶段的时间、资源加载时间等。其中，Performa"},{"id":"250","title":"如何解决页面请求接口大规模并发问题","category":"web应用场景","labels":["web应用场景","美团"],"url":"https://github.com/pro-collection/interview-question/issues/250","page":"q/web应用场景-250.html","excerpt":"如何解决页面请求接口大规模并发问题， 不仅仅是包含了接口并发， 还有前端资源下载的请求并发。 应该说这是一个话题讨论了； **个人认为可以从以下几个方面来考虑如何解决这个并发问题:** 后端优化：可以对接口进行优化，采用缓存技术，对数据进行预处理，减少数据库操作等。使用集群技术，将请求分散到不同的服务器上，提高并发量。"},{"id":"245","title":"react 中是如何实现 下拉菜单场景， 点击区域外关闭下拉组件？","category":"web应用场景","labels":["web应用场景","百度"],"url":"https://github.com/pro-collection/interview-question/issues/245","page":"q/web应用场景-245.html","excerpt":"在 React 中，要实现点击区域外关闭下拉组件，一般可以使用以下几种方法： 在下拉组件的根元素上监听点击事件，当点击区域不在下拉组件内时，触发关闭下拉组件的操作。这可以通过添加全局点击事件，然后在事件处理程序中判断点击区域是否在下拉组件内来实现。具体实现如下： 在下拉组件的父元素上监听点击事件，当点击区域不在下拉组件"},{"id":"238","title":"如何保证用户的使用体验","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/238","page":"q/web应用场景-238.html","excerpt":"【如何保证用户的使用体验】这个也是一个较为复杂的话题， 这个也不是问题了， 这个算是话题吧； 主要从以下几个方面思考问题： 性能方向的思考 用户线上问题反馈，线上 on call 的思考 用户使用体验的思考， 交互体验使用方向 提升用户能效方向思考"},{"id":"237","title":"canvas 与 svg 在可视化领域优劣如何","category":"web应用场景","labels":["web应用场景","腾讯"],"url":"https://github.com/pro-collection/interview-question/issues/237","page":"q/web应用场景-237.html","excerpt":"SVG、Canvas和WebGL在可视化方向各有优劣，具体如下： **SVG（Scalable Vector Graphics）：** 优势： 矢量图形：SVG 使用矢量图形描述，图形会根据缩放和放大而保持清晰，适用于需要无损放大的情况。 文本处理：SVG 对于文本处理较好，可以方便地添加和编辑文本。 简单图形绘制：S"},{"id":"232","title":"使用同一个链接，  如何实现 PC 打开是 web 应用、手机打开是一个 H5 应用？","category":"web应用场景","labels":["web应用场景","小米"],"url":"https://github.com/pro-collection/interview-question/issues/232","page":"q/web应用场景-232.html","excerpt":"可以通过根据请求来源（User-Agent）来判断访问设备的类型，然后在服务器端进行适配。例如，可以在服务器端使用 Node.js 的 Express 框架，在路由中对不同的 User-Agent 进行判断，返回不同的页面或数据。具体实现可以参考以下步骤： 根据 User-Agent 判断访问设备的类型，例如判断是否为"},{"id":"190","title":"js 超过 Number 最大值的数怎么处理？","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/190","page":"q/web应用场景-190.html","excerpt":"js 超过 Number 最大值的数怎么处理 在 JavaScript 中，超过 Number.MAX_VALUE 的数值被认为是 Infinity（正无穷大）。如果要处理超过 Number.MAX_VALUE 的数值，可以使用第三方的 JavaScript 库，如 big.js 或 bignumber.js，这些库可"},{"id":"189","title":"当QPS达到峰值时, 该如何处理？","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/189","page":"q/web应用场景-189.html","excerpt":"当QPS达到峰值时，可以从以下几个方面来进行优化： 数据库优化：数据库的优化包括优化SQL语句、使用索引、避免全表扫描、分表分库等措施，以提高数据库的读写性能。 缓存优化：缓存可以降低对数据库的访问频率，提高响应速度。可以使用Redis、Memcached等缓存技术，减轻服务器负载。 代码优化：优化代码可以提高代码的执"},{"id":"188","title":"前端如何实现截图？","category":"web应用场景","labels":["web应用场景"],"url":"https://github.com/pro-collection/interview-question/issues/188","page":"q/web应用场景-188.html","excerpt":"前端实现截图需要使用 HTML5 的 Canvas 和相关 API，具体步骤如下： 首先在页面中创建一个 Canvas 元素，并设置其宽高和样式。 使用 Canvas API 在 Canvas 上绘制需要截图的内容，比如页面的某个区域、某个元素、图片等。 调用 Canvas API 中的 toDataURL() 方法将"}]