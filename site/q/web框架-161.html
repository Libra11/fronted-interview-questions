<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何实现洋葱模式？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先调用 &lt;code&gt;use&lt;/code&gt; 方法收集中间件，调用 &lt;code&gt;listen&lt;/code&gt; 方法执行中间件。&lt;/li&gt;&lt;li&gt;每一个中间件都有一个&lt;code&gt;next&lt;/code&gt;参数（暂时不考虑c" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="如何实现洋葱模式？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先调用 &lt;code&gt;use&lt;/code&gt; 方法收集中间件，调用 &lt;code&gt;listen&lt;/code&gt; 方法执行中间件。&lt;/li&gt;&lt;li&gt;每一个中间件都有一个&lt;code&gt;next&lt;/code&gt;参数（暂时不考虑ctx参数），&lt;code&gt;next&lt;/code&gt;参数可以控制进入下一个中间件的时机。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;stron" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/161" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>如何实现洋葱模式？</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-03-26T06:44:01Z · 更新：2023-03-26T06:44:02Z</div>
    </div>
    <article class="content markdown-body"><p><strong>思路</strong></p><ul><li>首先调用 <code>use</code> 方法收集中间件，调用 <code>listen</code> 方法执行中间件。</li><li>每一个中间件都有一个<code>next</code>参数（暂时不考虑ctx参数），<code>next</code>参数可以控制进入下一个中间件的时机。</li></ul><p><strong>需要解决的问题</strong></p><ul><li>最后一个中间件调用next如何处理</li><li>如何解决同一个中间件多次调用next</li></ul><p><strong>完整代码</strong></p><p>其中最精华的部分就是<code>compose</code>函数，细数一下，只有<code>11</code>行代码，1比1还原了<code>koa</code>的<code>compose</code>函数（去除了不影响主逻辑判断）。</p><blockquote>koa是利用koa-compose这个库进行组合中间件的，在koa-compose里面，next返回的都是一个promise函数。</blockquote><pre class="code-block"><code class="language-js">function Koa () {
  this.middleares = [];
}
Koa.prototype.use = function (middleare) {
  this.middleares.push(middleare);
  return this;
}
Koa.prototype.listen = function () {
  const fn = compose(this.middleares);
}
function compose(middleares) {
  let index = -1;
  const dispatch = (i) =&gt; {
    if(i &lt;= index) throw new Error(&#39;next（） 不能调用多次&#39;);
    index = i;
    if(i &gt;= middleares.length) return;
    const middleare = middleares[i];
    return middleare(&#39;ctx&#39;, dispatch.bind(null, i + 1));
  }
  return dispatch(0);
}

const app = new Koa();
app.use(async (ctx, next) =&gt; {
  console.log(&#39;1&#39;);
  next();
  console.log(&#39;2&#39;);
});
app.use(async (ctx, next) =&gt; {
  console.log(&#39;3&#39;);
  next();
  console.log(&#39;4&#39;);
});
app.use(async (ctx, next) =&gt; {
  console.log(&#39;5&#39;);
  next();
  console.log(&#39;6&#39;);
});

app.listen();

</code></pre><p><strong>使用</strong></p><pre class="code-block"><code class="language-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

// 中间件过多，可以创建一个middleares文件夹，将cors函数放到middleares/cors.js文件里面
const cors = () =&gt; {
  return async (ctx, next) =&gt; {
    ctx.set(&#39;Access-Control-Allow-Headers&#39;, &#39;X-Requested-With&#39;)
    ctx.set(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)
    ctx.set(&#39;Access-Control-Allow-Methods&#39;, &#39;GET,HEAD,PUT,POST,DELETE,PATCH&#39;)
    await next();
  }
};

app.use(cors());
app.use(async (ctx, next) =&gt; {
  console.log(&#39;第一个中间件&#39;, ctx.request.method,ctx.request.url);
  await next();
  ctx.body = &#39;hello world&#39;
});

</code></pre><p><code>koa</code>的中间件都是有固定模板的，首先是一个函数，并且返回一个<code>async</code>函数（闭包的应用），这个<code>async</code>函数有两个参数，一个是<code>koa</code>的<code>context</code>，一个是<code>next</code>函数。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>