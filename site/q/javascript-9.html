<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>call、apply、bind 的区别和用法？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;call、apply 和 bind 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法，它们的区别和用法如下：&lt;/p&gt;&lt;h2&gt;call&lt;/h2&gt;&lt;p&gt;call 方法可以改变函数的 this 指向，同时还能传递多个参数。&lt;/p&gt;&lt;p&gt;&lt;stron" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="call、apply、bind 的区别和用法？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;call、apply 和 bind 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法，它们的区别和用法如下：&lt;/p&gt;&lt;h2&gt;call&lt;/h2&gt;&lt;p&gt;call 方法可以改变函数的 this 指向，同时还能传递多个参数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;call 方法的语法如下：&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code cl" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/9" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>call、apply、bind 的区别和用法？</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-06T15:19:39Z · 更新：2023-03-06T15:19:40Z</div>
    </div>
    <article class="content markdown-body"><p>call、apply 和 bind 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法，它们的区别和用法如下：</p><h2>call</h2><p>call 方法可以改变函数的 this 指向，同时还能传递多个参数。</p><p><strong>call 方法的语法如下：</strong></p><pre class="code-block"><code class="language-js">fun.call(thisArg, arg1, arg2, ...)
</code></pre><p>fun：要调用的函数。</p><p>thisArg：函数内部 this 指向的对象。</p><p>arg1, arg2, ...：传递给函数的参数列表。</p><p><strong>call 方法的使用示例：</strong></p><pre class="code-block"><code class="language-js">const person = {
  name: &#39;Alice&#39;,
  sayHello: function () {
    console.log(`Hello, ${this.name}!`)
  },
}

const person2 = {
  name: &#39;Bob&#39;,
}

person.sayHello.call(person2) // 输出：Hello, Bob!
</code></pre><h2>apply</h2><p>apply 方法和 call 方法类似，它也可以改变函数的 this 指向，但是它需要传递一个数组作为参数列表。</p><p><strong>apply 方法的语法如下：</strong></p><pre class="code-block"><code class="language-js">fun.apply(thisArg, [argsArray])
</code></pre><p>fun：要调用的函数。</p><p>thisArg：函数内部 this 指向的对象。</p><p>argsArray：传递给函数的参数列表，以数组形式传递。</p><p><strong>apply 方法的使用示例：</strong></p><pre class="code-block"><code class="language-js">const person = {
  name: &#39;Alice&#39;,
  sayHello: function (greeting) {
    console.log(`${greeting}, ${this.name}!`)
  },
}

const person2 = {
  name: &#39;Bob&#39;,
}

person.sayHello.apply(person2, [&#39;Hi&#39;]) // 输出：Hi, Bob!
</code></pre><h2>bind</h2><p>bind 方法和 call、apply 方法不同，它并不会立即调用函数，而是返回一个新的函数，这个新函数的 this 指向被绑定的对象。</p><p><strong>bind 方法的语法如下：</strong></p><pre class="code-block"><code class="language-js">fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre><p>fun：要调用的函数。</p><p>thisArg：函数内部 this 指向的对象。</p><p>arg1, arg2, ...：在调用函数时，绑定到函数参数的值。</p><p><strong>bind 方法的使用示例：</strong></p><pre class="code-block"><code class="language-js">const person = {
  name: &#39;Alice&#39;,
  sayHello: function () {
    console.log(`Hello, ${this.name}!`)
  },
}

const person2 = {
  name: &#39;Bob&#39;,
}

const sayHelloToBob = person.sayHello.bind(person2)
sayHelloToBob() // 输出：Hello, Bob!
</code></pre><p><strong>参数传递</strong></p><p>在使用 bind 方法时，我们可以通过传递参数来预先填充函数的一些参数，这样在调用函数时只需要传递剩余的参数即可。</p><pre class="code-block"><code class="language-js">const person = {
  name: &#39;Alice&#39;,
  sayHello: function (greeting, punctuation) {
    console.log(`${greeting}, ${this.name}, ${punctuation}`)
  },
}

const person2 = {
  name: &#39;Bob&#39;,
}

const sayHelloToBob = person.sayHello.bind(person2);

sayHelloToBob(1,2); // 输出：1, Bob, 2
</code></pre><p><strong>再举一个例子：</strong></p><pre class="code-block"><code class="language-js">this.x = 9;    // 在浏览器中，this 指向全局的 &quot;window&quot; 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>