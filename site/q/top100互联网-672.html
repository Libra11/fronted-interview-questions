<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JS 执行 100 万个任务， 如何保证浏览器不卡顿？【热度: 806】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：大批量执行任务不卡顿&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Web Workers&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;要确保浏览器在执行100万个任务时不会卡顿，你可以考虑使用Web Workers来将这些任务从主线程中分离出来。Web Work" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="JS 执行 100 万个任务， 如何保证浏览器不卡顿？【热度: 806】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：大批量执行任务不卡顿&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Web Workers&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;要确保浏览器在执行100万个任务时不会卡顿，你可以考虑使用Web Workers来将这些任务从主线程中分离出来。Web Workers允许在后台线程中运行脚本，从而避免阻塞主线程，保持页面的响应性。&lt;/p&gt;&lt;p&gt;以下是一个使用Web Workers" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/672" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>JS 执行 100 万个任务， 如何保证浏览器不卡顿？【热度: 806】</h1>
      <div class="subtitle">TOP100互联网 · web应用场景 · TOP100互联网</div>
      <div class="meta">创建：2024-01-27T13:15:57Z · 更新：2024-01-28T14:05:05Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：大批量执行任务不卡顿</p><p><strong>Web Workers</strong></p><p>要确保浏览器在执行100万个任务时不会卡顿，你可以考虑使用Web Workers来将这些任务从主线程中分离出来。Web Workers允许在后台线程中运行脚本，从而避免阻塞主线程，保持页面的响应性。</p><p>以下是一个使用Web Workers的简单示例：</p><pre class="code-block"><code class="language-javascript">// 主线程代码
const worker = new Worker(&#39;worker.js&#39;); // 创建一个新的Web Worker

worker.postMessage({ start: 0, end: 1000000 }); // 向Web Worker发送消息

worker.onmessage = function(event) {
  const result = event.data;
  console.log(&#39;任务完成：&#39;, result);
};

// worker.js - Web Worker代码
onmessage = function(event) {
  const start = event.data.start;
  const end = event.data.end;
  let sum = 0;
  for (let i = start; i &lt;= end; i++) {
    sum += i;
  }
  postMessage(sum); // 向主线程发送消息
};
</code></pre><p>在这个示例中，主线程创建了一个新的Web Worker，并向其发送了一个包含任务范围的消息。Web Worker在后台线程中执行任务，并将结果发送回主线程。</p><p><strong>requestAnimationFrame 来实现任务分割</strong></p><p>使用<code>requestAnimationFrame</code>来实现任务分割是一种常见的方式，它可以确保任务在浏览器的每一帧之间执行，从而避免卡顿。以下是一个使用<code>requestAnimationFrame</code>来分割任务的简单例子：</p><pre class="code-block"><code class="language-javascript">// 假设有一个包含大量元素的数组
const bigArray = Array.from({ length: 1000000 }, (_, i) =&gt; i + 1);

// 定义一个处理函数，例如对数组中的每个元素进行平方操作
function processChunk(chunk) {
  return chunk.map(num =&gt; num * num);
}

// 分割任务并使用requestAnimationFrame
const chunkSize = 1000; // 每个小块的大小
let index = 0;

function processArrayWithRAF() {
  function processChunkWithRAF() {
    const chunk = bigArray.slice(index, index + chunkSize); // 从大数组中取出一个小块
    const result = processChunk(chunk); // 处理小块任务
    console.log(&#39;处理完成：&#39;, result);
    index += chunkSize;

    if (index &lt; bigArray.length) {
      requestAnimationFrame(processChunkWithRAF); // 继续处理下一个小块
    }
  }

  requestAnimationFrame(processChunkWithRAF); // 开始处理大数组
}

processArrayWithRAF();
</code></pre><p>在这个例子中，我们使用<code>requestAnimationFrame</code>来循环执行处理小块任务的函数<code>processChunkWithRAF</code>，从而实现对大数组的任务分割。这样可以确保任务在每一帧之间执行，避免卡顿。</p><p><strong>针对上面的改进一下</strong></p><p><code>const chunkSize = 1000; // 每个小块的大小</code> 是不能保证不卡的， 那么久需要动态调整 <code>chunkSize</code> 的大小， 代码可以参考下面的示范：</p><pre class="code-block"><code class="language-javascript">  const $result = document.getElementById(&quot;result&quot;);

// 假设有一个包含大量元素的数组
const bigArray = Array.from({ length: 1000000 }, (_, i) =&gt; i + 1);

// 定义一个处理函数，对数组中的每个元素执行一次
function processChunk(chunk) {
  return `chunk: ${chunk}`;
}

// 动态调整 chunkSize 的优化方式
let chunkSize = 1000; // 初始的 chunkSize
let index = 0;

function processArrayWithDynamicChunkSize() {
  function processChunkWithRAF() {
    let startTime = performance.now(); // 记录结束时间
    for (let i = 0; i &lt; chunkSize; i++) {
      if (index &lt; bigArray.length) {
        const result = processChunk(bigArray[index]); // 对每个元素执行处理函数
        $result.innerText = result;
        index++;
      }
    }
    let endTime = performance.now();
    let timeTaken = endTime - startTime; // 计算处理时间

    // 根据处理时间动态调整 chunkSize
    if (timeTaken &gt; 16) { // 如果处理时间超过一帧的时间（16毫秒），则减小 chunkSize
      chunkSize = Math.floor(chunkSize * 0.9); // 减小10%
    } else if (timeTaken &lt; 16) { // 如果处理时间远小于一帧的时间（8毫秒），则增加 chunkSize
      chunkSize = Math.floor(chunkSize * 1.1); // 增加10%
    }

    if (index &lt; bigArray.length) {
      requestAnimationFrame(processChunkWithRAF); // 继续处理下一个小块
    }
  }

  requestAnimationFrame(processChunkWithRAF); // 开始处理大数组
}

processArrayWithDynamicChunkSize();
</code></pre><p>在这个例子中，我们动态调整<code>chunkSize</code>的大小，根据处理时间来优化任务分割。根据处理时间的表现，动态调整<code>chunkSize</code>的大小，以确保在处理大量任务时，浏览器能够保持流畅，避免卡顿。</p><p>参考文档： <a href="https://github.com/yanlele/node-index/tree/master/books/%E7%9F%A5%E8%AF%86%E5%BA%93/01%E3%80%81%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/29.100%E4%B8%87%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%BF%9D%E8%AF%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%8D%A1" target="_blank" rel="noopener">100万个函数执行保证浏览器不卡</a></p><p><strong>requestIdleCallback</strong></p><p><code>window.requestIdleCallback</code> 是一个用于在浏览器空闲时执行任务的API。它允许开发者在浏览器的主线程空闲时执行一些任务，而不会影响用户界面的流畅性和响应性。</p><p>这个 API 的基本思想是利用浏览器在空闲时的空闲时间来执行任务，这样就可以避免在用户执行交互操作时造成卡顿。<code>requestIdleCallback</code> 接受一个回调函数作为参数，该回调函数会在浏览器空闲时被调用。</p><p>以下是 <code>window.requestIdleCallback</code> 的基本用法：</p><pre class="code-block"><code class="language-javascript">window.requestIdleCallback(function(deadline) {
  // 在空闲时执行的任务
  // deadline 参数提供了一些信息，比如剩余的空闲时间等
});
</code></pre><p><code>requestIdleCallback</code> 的回调函数接收一个 <code>deadline</code> 参数，它包含了一些有关当前空闲时间的信息。通过这个参数，你可以决定是否继续执行任务或者推迟到下一次空闲时段。</p><p>此外，还有一个配套的 <code>window.cancelIdleCallback</code> 方法，用于取消通过 <code>requestIdleCallback</code> 请求的回调：</p><pre class="code-block"><code class="language-javascript">const id = window.requestIdleCallback(function(deadline) {
  // 在空闲时执行的任务
});

// 取消回调
window.cancelIdleCallback(id);
</code></pre><p>需要注意的是，<code>requestIdleCallback</code> 并不是所有浏览器都支持的标准，因此在使用时要注意检查浏览器的兼容性。在一些现代浏览器中，这个 API 已经得到了广泛的支持，但在某些老旧的浏览器中可能并不可用。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>