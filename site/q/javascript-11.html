<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>常见数组排序算法有哪些？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;常见排序算法中，时间复杂度和空间复杂度是怎样的？&lt;/h2&gt;&lt;p&gt;如图所示：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;01_10&quot; src=&quot;https://user-images.githubusercontent.com/22188674/222961047-79023840-" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="常见数组排序算法有哪些？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;常见排序算法中，时间复杂度和空间复杂度是怎样的？&lt;/h2&gt;&lt;p&gt;如图所示：&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;01_10&quot; src=&quot;https://user-images.githubusercontent.com/22188674/222961047-79023840-bd63-4a2c-93fe-2d94f2a8ac04.png&quot; /&gt;&lt;/p&gt;&lt;h2&gt;快速排序：&lt;/h2&gt;&lt;p&gt;先从数列" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/11" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>常见数组排序算法有哪些？</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-06T15:19:45Z · 更新：2023-03-06T15:19:46Z</div>
    </div>
    <article class="content markdown-body"><h2>常见排序算法中，时间复杂度和空间复杂度是怎样的？</h2><p>如图所示：</p><p><img alt="01_10" src="https://user-images.githubusercontent.com/22188674/222961047-79023840-bd63-4a2c-93fe-2d94f2a8ac04.png" /></p><h2>快速排序：</h2><p>先从数列中取出一个数作为“基准”。</p><p>分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。</p><p>再对左右区间重复第二步，直到各区间只有一个数。</p><pre class="code-block"><code class="language-javascript">var quickSort = function(arr) {
    if (arr.length &lt;= 1) { return arr; }
    var pivotIndex = Math.floor(arr.length / 2);   //基准位置（理论上可任意选取）
    var pivot = arr.splice(pivotIndex, 1)[0];  //基准数
    var left = [];
    var right = [];
    for (var i = 0; i &lt; arr.length; i++){
        if (arr[i] &lt; pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat([pivot], quickSort(right));  //链接左数组、基准数构成的数组、右数组
};
</code></pre><h2>选择排序：</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><pre class="code-block"><code class="language-javascript">function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
</code></pre><h2>插入排序：</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><pre class="code-block"><code class="language-javascript">function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
</code></pre><h2>冒泡法排序：</h2><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><pre class="code-block"><code class="language-javascript">function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre><h2>希尔排序</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。</p><p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><p>选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；</p><p>按增量序列个数k，对序列进行k 趟排序；</p><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</p><p>仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><pre class="code-block"><code class="language-javascript">function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while (gap &lt; len / 3) {          // 动态定义间隔序列
        gap = gap * 3 + 1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
    return arr;
}
</code></pre><h2>归并排序</h2><p>直接上代码了</p><pre class="code-block"><code class="language-js">function mergeSort(arr){
    var len = arr.length;
    if(len &lt;2)
        return arr;
    var mid = Math.floor(len/2),
        left = arr.slice(0,mid),
        right =arr.slice(mid);
    //send left and right to the mergeSort to broke it down into pieces
    //then merge those
    return merge(mergeSort(left),mergeSort(right));
}

function merge(left, right){
    var result = [],
        lLen = left.length,
        rLen = right.length,
        l = 0,
        r = 0;
    while(l &lt; lLen &amp;&amp; r &lt; rLen){
        if(left[l] &lt; right[r]){
            result.push(left[l++]);
        }
        else{
            result.push(right[r++]);
        }
    }
    //remaining part needs to be addred to the result
    return result.concat(left.slice(l)).concat(right.slice(r));
}
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>