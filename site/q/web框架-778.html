<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] 如何避免使用 context 的时候， 引起整个挂载节点树的重新渲染【热度: 420】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React Context 渲染问题&lt;/p&gt;&lt;p&gt;要避免在 React 开发中使用 &lt;code&gt;context&lt;/code&gt; 时引起整个挂载节点树的重新渲染，可以采取以下方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;React Context 数据" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] 如何避免使用 context 的时候， 引起整个挂载节点树的重新渲染【热度: 420】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React Context 渲染问题&lt;/p&gt;&lt;p&gt;要避免在 React 开发中使用 &lt;code&gt;context&lt;/code&gt; 时引起整个挂载节点树的重新渲染，可以采取以下方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;React Context 数据分割：把提供 &lt;code&gt;context value&lt;/code&gt; 的部分提取到单独的组件中，并且仅在该组件中修改 &lt;c" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/778" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] 如何避免使用 context 的时候， 引起整个挂载节点树的重新渲染【热度: 420】</h1>
      <div class="subtitle">web框架 · web框架 · TOP100互联网</div>
      <div class="meta">创建：2024-07-12T11:40:46Z · 更新：2024-07-12T11:40:46Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：React Context 渲染问题</p><p>要避免在 React 开发中使用 <code>context</code> 时引起整个挂载节点树的重新渲染，可以采取以下方法：</p><ol><li>React Context 数据分割：把提供 <code>context value</code> 的部分提取到单独的组件中，并且仅在该组件中修改 <code>context value</code>。这样，当 <code>context value</code> 变化时，只有真正使用该 <code>context</code> 的消费组件会重新渲染，而非所有挂载节点都会重新渲染。</li></ol><p>假设我们有一个应用，需要管理主题颜色和用户信息两个不同的数据。</p><p>首先，创建两个 Context：</p><pre class="code-block"><code class="language-jsx">import React from &quot;eact&quot;;

// 创建主题颜色 Context
const ThemeContext = React.createContext({ theme: &quot;light&quot; });

// 创建用户信息 Context
const UserContext = React.createContext({ user: null });
</code></pre><p>在顶层组件中，提供这两个 Context 的 Provider，并设置相应的值：</p><pre class="code-block"><code class="language-jsx">class App extends React.Component {
  state = {
    theme: &quot;dark&quot;,
    user: { name: &quot;John Doe&quot;, age: 25 },
  };

  render() {
    return (
      &lt;ThemeContext.Provider value={this.state.theme}&gt;
        &lt;UserContext.Provider value={this.state.user}&gt;
          &lt;Toolbar /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/ThemeContext.Provider&gt;
    );
  }
}
</code></pre><p>然后，在需要使用主题颜色的组件中，可以通过以下方式获取：</p><pre class="code-block"><code class="language-jsx">class ThemedButton extends React.Component {
  static contextType = ThemeContext;

  render() {
    const theme = this.context;
    return &lt;Button theme={theme} /&gt;;
  }
}
</code></pre><p>在需要使用用户信息的组件中，同样方式获取：</p><pre class="code-block"><code class="language-jsx">class UserProfile extends React.Component {
  static contextType = UserContext;

  render() {
    const user = this.context;
    return (
      &lt;div&gt;
        &lt;p&gt;用户名：{user.name}&lt;/p&gt;
        &lt;p&gt;年龄：{user.age}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>在上述例子中，我们将主题颜色和用户信息分割到不同的 Context 中。<code>ThemeContext</code> 用于传递主题相关的数据，<code>UserContext</code> 用于传递用户相关的数据。这样，不同的组件可以根据自己的需求订阅相应的 Context，获取所需的数据，而不会相互干扰。每个组件只需要关注自己所使用的 Context，提高了代码的可读性和可维护性。同时，当某个 Context 的数据发生变化时，只有订阅了该 Context 的组件才会重新渲染，避免了不必要的重新渲染。</p><ol><li>对消费组件使用 <code>React.memo()</code> 进行包裹：<code>React.memo</code> 可以对函数组件进行浅比较，如果组件的 props 没有变化，就不会触发重新渲染。通过将消费 <code>context</code> 的组件用 <code>React.memo()</code> 包裹，可以避免不必要的重新渲染。</li></ol><p>例如，假设有一个 <code>ContextProvider</code> 组件提供 <code>context value</code>，以及一个使用该 <code>context</code> 的子组件 <code>ConsumerComponent</code>，优化后的代码可能如下所示：</p><pre class="code-block"><code class="language-jsx">const ContextProvider = ({ children }) =&gt; {
  // 管理 context value 的状态
  const [value, setValue] = useState(/* 初始值 */);

  return &lt;MyContext.Provider value={value}&gt;{children}&lt;/MyContext.Provider&gt;;
};

const ConsumerComponent = React.memo(({ contextValue }) =&gt; {
  // 仅根据 context value 进行渲染或处理逻辑
  return &lt;div&gt;{/* 使用 context value 的相关逻辑 */}&lt;/div&gt;;
});
</code></pre><p>在上述示例中，<code>ContextProvider</code> 负责管理 <code>context value</code> 的状态变化，而 <code>ConsumerComponent</code> 是使用 <code>context</code> 的消费组件，并通过 <code>React.memo()</code> 进行了包裹。这样，当 <code>value</code> 发生变化时，只有 <code>ConsumerComponent</code> 会根据浅比较来决定是否重新渲染，而不是整个挂载节点树都重新渲染。</p><p>通过以上方式，可以减少使用 <code>context</code> 时不必要的重新渲染，提高应用的性能。但具体的优化策略还需要根据项目的实际情况进行选择和调整。同时，还需注意避免在 <code>context</code> 中传递过于复杂或频繁变化的数据，以减少不必要的渲染次数。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>