<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>npm script 了解多少？【热度: 364】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h3&gt;什么是 npm script&lt;/h3&gt;&lt;p&gt;npm 允许在package.json文件里面，使用scripts字段定义脚本命令。&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-awk&quot;&gt;{ // ... &amp;quot;sc" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="npm script 了解多少？【热度: 364】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h3&gt;什么是 npm script&lt;/h3&gt;&lt;p&gt;npm 允许在package.json文件里面，使用scripts字段定义脚本命令。&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-awk&quot;&gt;{ // ... &amp;quot;scripts&amp;quot;: { &amp;quot;build&amp;quot;: &amp;quot;node build.js&amp;quot; " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/312" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>npm script 了解多少？【热度: 364】</h1>
      <div class="subtitle">工程化 · 工程化</div>
      <div class="meta">创建：2023-04-26T14:20:39Z · 更新：2023-04-26T14:23:07Z</div>
    </div>
    <article class="content markdown-body"><h3>什么是 npm script</h3><p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令。</p><pre class="code-block"><code class="language-awk">{
  // ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;node build.js&quot;
  }
}
</code></pre><p>上面代码是<code>package.json</code>文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是<code>node build.js</code>。</p><p>命令行下使用<code>npm run</code>命令，就可以执行这段脚本。</p><pre class="code-block"><code class="language-crmsh">
$ npm run build
# 等同于执行
$ node build.js
</code></pre><p>这些定义在<code>package.json</code>里面的脚本，就称为npm脚本。它的优点很多。</p><ul><li>项目的相关脚本，可以集中在一个地方。</li><li>不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。</li><li>用户不需要知道怎么测试你的项目，只要运行npm run test即可。</li><li>可以利用 npm 提供的很多辅助功能。</li></ul><p>查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的<code>npm run</code>命令。</p><pre class="code-block"><code class="language-applescript">$ npm run
</code></pre><hr /><h3>原理</h3><p>npm run 实际上是 npm run-script 命令的简写</p><ul><li>从 package.json 文件中读取 scripts 对象里面的全部配置；</li><li>以传给 npm run 的第一个参数作为键，如dev，在 scripts 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错；</li></ul><p>每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p><p>比较特别的是，npm run新建的这个 Shell，会将当前目录的node\_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p><p>这意味着，当前目录的node\_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。</p><pre class="code-block"><code class="language-json">&quot;test&quot;: &quot;mocha test&quot;
</code></pre><h3>通配符</h3><p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。</p><pre class="code-block"><code class="language-json">&quot;lint&quot;: &quot;jshint *.js&quot;
&quot;lint&quot;: &quot;jshint **/*.js&quot;
</code></pre><p>上面代码中，\<em>表示任意文件名，\</em>\*表示任意一层子目录。</p><p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p><pre class="code-block"><code class="language-json">&quot;test&quot;: &quot;tap test/\*.js&quot;
</code></pre><hr /><h3>传参</h3><p>给 npm script 传递参数 给 npm script 传递参数 eslint 内置了代码风格自动修复模式，只需给它传入 --fix 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学可能会忍不住复制粘贴，如下：</p><pre class="code-block"><code class="language-diff">@@ -5,6 +5,7 @@
     &quot;lint:js&quot;: &quot;eslint *.js&quot;,
+    &quot;lint:js:fix&quot;: &quot;eslint *.js --fix&quot;,
</code></pre><p>在 lint:js 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 lint:js 命令变的很长之后，难免后续会有人改了 lint:js 而忘记修改 lint:js:fix（别问我为啥，我就是踩着坑过来的），更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下：</p><pre class="code-block"><code class="language-diff">@@ -5,6 +5,7 @@
     &quot;lint:js&quot;: &quot;eslint *.js&quot;,
+    &quot;lint:js:fix&quot;: &quot;npm run lint:js -- --fix&quot;,
</code></pre><p>要格外注意 --fix 参数前面的 -- 分隔符，意指要给 npm run lint:js 实际指向的命令传递额外的参数。</p><hr /><h3>注释</h3><pre class="code-block"><code class="language-swift">&quot;test&quot;: &quot;# 运行所有代码检查和单元测试 .    npm-run-all --parallel lint:* mocha&quot;
</code></pre><p>或者在单独的文件中可以自由给它添加注释</p><hr /><h3>日志</h3><pre class="code-block"><code class="language-dockerfile">npm run test --loglevel silent
npm run test --slient
npm run test -s
</code></pre><p>这个日志级别，只有命令本身的输出，读起来非常的简洁</p><pre class="code-block"><code class="language-dockerfile">npm run test --loglevel verbose
npm run test --verbose
npm run test -d
</code></pre><p>这个日志级别，详细打印出了每个步骤的参数、返回值</p><hr /><h3>执行顺序</h3><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><p>如果是并行执行（即同时的平行执行），可以使用&符号。</p><pre class="code-block"><code class="language-routeros">$ npm run script1.js &amp; npm run script2.js
</code></pre><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。</p><pre class="code-block"><code class="language-routeros">$ npm run script1.js &amp;&amp; npm run script2.js
</code></pre><p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：<code>npm-run-all</code>、<code>script-runner</code></p><pre class="code-block"><code class="language-awk">// 串行
{
-    &quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown&quot;
+    &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown&quot;
   },
// 并行 --parallel
{
-    &quot;test&quot;: &quot;npm-run-all lint:*&quot;
+    &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;
}
</code></pre><hr /><h3>默认值</h3><p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p><pre class="code-block"><code class="language-1c">
&quot;start&quot;: &quot;node server.js&quot;，
&quot;install&quot;: &quot;node-gyp rebuild&quot;
</code></pre><p>上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。</p><hr /><h3>钩子</h3><p>npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。</p><pre class="code-block"><code class="language-smalltalk">&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,
&quot;postbuild&quot;: &quot;echo I run after the build script&quot;
</code></pre><p>用户执行npm run build的时候，会自动按照下面的顺序执行。</p><p>npm run prebuild && npm run build && npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p><pre class="code-block"><code class="language-json">
&quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;,
&quot;prebuild&quot;: &quot;npm run clean&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;
</code></pre><p>npm 默认提供下面这些钩子。</p><pre class="code-block"><code>prepublish，postpublish
preinstall，postinstall
preuninstall，postuninstall
preversion，postversion
pretest，posttest
prestop，poststop
prestart，poststart
prerestart，postrestart
</code></pre><p>自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。</p><p>npm 提供一个npm\_lifecycle\_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。</p><pre class="code-block"><code class="language-arcade">const TARGET = process.env.npm_lifecycle_event;

if (TARGET === &#39;test&#39;) {
  console.log(`Running the test task!`);
}

if (TARGET === &#39;pretest&#39;) {
  console.log(`Running the pretest task!`);
}

if (TARGET === &#39;posttest&#39;) {
  console.log(`Running the posttest task!`);
}
</code></pre><p>注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。</p><hr /><h3>简写形式</h3><p>四个常用的 npm 脚本有简写形式。</p><pre class="code-block"><code class="language-routeros">npm start是npm run start
npm stop是npm run stop的简写
npm test是npm run test的简写
npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写
</code></pre><p>npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。</p><pre class="code-block"><code class="language-crmsh">prerestart
prestop
stop
poststop
restart
prestart
start
poststart
postrestart
</code></pre><hr /><h3>变量</h3><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p><p>运行 <code>npm run env</code>能拿到完整的变量列表</p><p>使用<code>npm run env | grep npm_package | sort</code> 拿到部分排序后的环境变量</p><p>通过npm\_package\_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。</p><pre class="code-block"><code class="language-json">{
  &quot;name&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;1.2.5&quot;,
  &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; },
  &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }
}
</code></pre><p>那么，变量npm\_package\_name返回foo，变量npm\_package\_version返回1.2.5。</p><pre class="code-block"><code class="language-arcade">// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version); // 1.2.5
</code></pre><p>上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。</p><p><code>$npm_package_scripts_start</code></p><hr /><h3>结合 npm script 和 git-hooks</h3><p>Git 在代码版本管理之外，也提供了类似 npm script 里 pre、post 的钩子机制，叫做 Git Hooks，钩子机制能让我们在代码 commit、push 之前（后）做自己想做的事情。</p><p>前端社区里有多种结合 npm script 和 git-hooks 的方案，比如 <code>pre-commit</code>、<code>husky</code>，相比较而言 husky 更好用，它支持更多的 Git Hooks 种类，再结合 <code>lint-staged</code> 使用就更好了。</p><p><a href="https://juejin.cn/post/6844903479283040269" target="_blank" rel="noopener">了解更多</a></p><hr /><h3>常用脚本示例</h3><pre class="code-block"><code class="language-awk">// 删除目录
&quot;clean&quot;: &quot;rimraf dist/*&quot;,

// 本地搭建一个 HTTP 服务
&quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;,

// 打开浏览器
&quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;,

// 实时刷新
 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;,

// 构建 HTML 文件
&quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;,

// 只要 CSS 文件有变动，就重新执行构建
&quot;watch:css&quot;: &quot;watch &#39;npm run build:css&#39; assets/styles/&quot;,

// 只要 HTML 文件有变动，就重新执行构建
&quot;watch:html&quot;: &quot;watch &#39;npm run build:html&#39; assets/html&quot;,

// 部署到 Amazon S3
&quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;,

// 构建 favicon
&quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;,
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>