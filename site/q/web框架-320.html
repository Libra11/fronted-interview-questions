<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] React Reconciler 为何要采用 fiber 架构？【热度: 1,794】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 协调器&lt;/p&gt;&lt;h3&gt;代数效应的实践&lt;/h3&gt;&lt;p&gt;React中做的就是践行代数效应（Algebraic Effects）。&lt;/p&gt;&lt;p&gt;简" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] React Reconciler 为何要采用 fiber 架构？【热度: 1,794】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：react16 架构、react Reconciler、react fiber、react 协调器&lt;/p&gt;&lt;h3&gt;代数效应的实践&lt;/h3&gt;&lt;p&gt;React中做的就是践行代数效应（Algebraic Effects）。&lt;/p&gt;&lt;p&gt;简单点儿来说就是： &lt;strong&gt;用于将副作用从函数调用中分离。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;举例子：&lt;/p&gt;&lt;p&gt;比" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/320" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] React Reconciler 为何要采用 fiber 架构？【热度: 1,794】</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-04-27T15:37:45Z · 更新：2023-04-27T15:37:45Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：react16 架构、react Reconciler、react fiber、react 协调器</p><h3>代数效应的实践</h3><p>React中做的就是践行代数效应（Algebraic Effects）。</p><p>简单点儿来说就是： <strong>用于将副作用从函数调用中分离。</strong></p><p>举例子：</p><p>比如我们要获取用户的姓名做展示：</p><pre class="code-block"><code class="language-js">const resource = fetchProfileData();

function ProfileDetails() {
  // Try to read user info, although it might not have loaded yet
  const user = resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}
</code></pre><p>代码如上， 但是 resource 是通过异步获取的。 这个时候代码就要改为下面这种形式</p><pre class="code-block"><code class="language-js">const resource = fetchProfileData();

async function ProfileDetails() {
  // Try to read user info, although it might not have loaded yet
  const user = await resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}
</code></pre><p>但是 async/await 是具有传染性的。 这个穿践行就是副作用， 我们不希望有这样的副作用， 尽管里面有异步调用， 不希望这样的副作用传递给外部的函数， 只希望外部的函数是一个纯函数。</p><h3>代数效应在React中的应用</h3><p>在 react 代码中， 每一个函数式组件， 其实都是一个纯函数， 但是内部里面可能会有各种各样的副作用。 这些副作用就是我们使用的 hooks;</p><p>对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。</p><p>我们只需要假设useState返回的是我们想要的state，并编写业务逻辑就行。</p><p>可以看官方的 Suspense demo, 可以是通过 Suspense 让内部直接可以同步的方式调用异步代码；</p><p>代码链接： https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160</p><pre class="code-block"><code class="language-jsx">import React, { Suspense } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

import &quot;./styles.css&quot;;
import { fetchProfileData } from &quot;./fakeApi&quot;;

const resource = fetchProfileData();

function ProfilePage() {
  return (
    &lt;Suspense
      fallback={&lt;h1&gt;Loading profile...&lt;/h1&gt;}
    &gt;
      &lt;ProfileDetails /&gt;
      &lt;Suspense
        fallback={&lt;h1&gt;Loading posts...&lt;/h1&gt;}
      &gt;
        &lt;ProfileTimeline /&gt;
      &lt;/Suspense&gt;
    &lt;/Suspense&gt;
  );
}

function ProfileDetails() {
  // Try to read user info, although it might not have loaded yet
  const user = resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}

function ProfileTimeline() {
  // Try to read posts, although they might not have loaded yet
  const posts = resource.posts.read();
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

const rootElement = document.getElementById(
  &quot;root&quot;
);
ReactDOM.createRoot(rootElement).render(
  &lt;ProfilePage /&gt;
);
</code></pre><h3>Generator 架构</h3><p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。</p><p>异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p><p>其实，浏览器原生就支持类似的实现，这就是Generator。</p><p>但是Generator的一些缺陷使React团队放弃了他：</p><ul><li>类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。</li><li>Generator执行的中间状态是上下文关联的。</li></ul><p>例如这样的例子：</p><pre class="code-block"><code class="language-js">function* doWork(A, B, C) {
  var x = doExpensiveWorkA(A);
  yield;
  var y = x + doExpensiveWorkB(B);
  yield;
  var z = y + doExpensiveWorkC(C);
  return z;
}
</code></pre><p>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成doExpensiveWorkA与doExpensiveWorkB计算出x与y。</p><p>此时B组件接收到一个高优更新，由于Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算。</p><p>如果通过全局变量保存之前执行的中间状态，又会引入新的复杂度。</p><h3>fiber 架构</h3><p>他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p><p>在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。</p><p>所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。</p><p>React Fiber可以理解为：</p><p>React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</p><p>其中每个任务更新单元为React Element对应的Fiber节点。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>