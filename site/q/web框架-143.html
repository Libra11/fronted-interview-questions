<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[vue] 双向数据绑定原理? - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;blockquote&gt;在目前的前端面试中，vue的双向数据绑定已经成为了一个非常容易考到的点，即使不能当场写出来，至少也要能说出原理。本篇文章中我将会仿照vue写一个双向数据绑定的实例，名字就叫myVue吧。结合注释，希望能让大家有所收获。&lt;/blockquote&gt;&lt;h3&gt;1、" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[vue] 双向数据绑定原理?" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;blockquote&gt;在目前的前端面试中，vue的双向数据绑定已经成为了一个非常容易考到的点，即使不能当场写出来，至少也要能说出原理。本篇文章中我将会仿照vue写一个双向数据绑定的实例，名字就叫myVue吧。结合注释，希望能让大家有所收获。&lt;/blockquote&gt;&lt;h3&gt;1、原理&lt;/h3&gt;&lt;p&gt;Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过&lt;code&gt;Object对象的defin" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/143" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[vue] 双向数据绑定原理?</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2023-03-23T15:59:38Z · 更新：2023-03-23T15:59:39Z</div>
    </div>
    <article class="content markdown-body"><blockquote>在目前的前端面试中，vue的双向数据绑定已经成为了一个非常容易考到的点，即使不能当场写出来，至少也要能说出原理。本篇文章中我将会仿照vue写一个双向数据绑定的实例，名字就叫myVue吧。结合注释，希望能让大家有所收获。</blockquote><h3>1、原理</h3><p>Vue的双向数据绑定的原理相信大家也都十分了解了，主要是通过<code>Object对象的defineProperty属性，重写data的set和get函数来实现的</code>,这里对原理不做过多描述，主要还是来实现一个实例。为了使代码更加的清晰，这里只会实现最基本的内容，主要实现v-model，v-bind 和v-click三个命令，其他命令也可以自行补充。</p><p>添加网上的一张图</p><p><img alt="" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/10/162ad3d5be3e5105~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" /></p><h3>2、实现</h3><p>页面结构很简单，如下</p><pre class="code-block"><code class="language-xml">&lt;div id=&quot;app&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;text&quot;  v-model=&quot;number&quot;&gt;
      &lt;button type=&quot;button&quot; v-click=&quot;increment&quot;&gt;增加&lt;/button&gt;
    &lt;/form&gt;
    &lt;h3 v-bind=&quot;number&quot;&gt;&lt;/h3&gt;
  &lt;/div&gt;

</code></pre><p>包含：</p><pre class="code-block"><code class="language-css">1. 一个input，使用v-model指令
2. 一个button，使用v-click指令
3. 一个h3，使用v-bind指令。

</code></pre><p>我们最后会通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释</p><pre class="code-block"><code class="language-php">var app = new myVue({
      el:&#39;#app&#39;,
      data: {
        number: 0
      },
      methods: {
        increment: function() {
          this.number ++;
        },
      }
    })

</code></pre><p>首先我们需要定义一个myVue构造函数：</p><pre class="code-block"><code class="language-javascript">function myVue(options) {

}

</code></pre><p>为了初始化这个构造函数，给它添加一 个\_init属性</p><pre class="code-block"><code class="language-kotlin">function myVue(options) {
  this._init(options);
}
myVue.prototype._init = function (options) {
    this.$options = options;  // options 为上面使用时传入的结构体，包括el,data,methods
    this.$el = document.querySelector(options.el); // el是 #app, this.$el是id为app的Element元素
    this.$data = options.data; // this.$data = {number: 0}
    this.$methods = options.methods;  // this.$methods = {increment: function(){}}
  }

</code></pre><p>接下来实现\_obverse函数，对data进行处理，重写data的set和get函数</p><p>并改造\_init函数</p><pre class="code-block"><code class="language-javascript"> myVue.prototype._obverse = function (obj) { // obj = {number: 0}
    var value;
    for (key in obj) {  //遍历obj对象
      if (obj.hasOwnProperty(key)) {
        value = obj[key];
        if (typeof value === &#39;object&#39;) {  //如果值还是对象，则遍历处理
          this._obverse(value);
        }
        Object.defineProperty(this.$data, key, {  //关键
          enumerable: true,
          configurable: true,
          get: function () {
            console.log(`获取${value}`);
            return value;
          },
          set: function (newVal) {
            console.log(`更新${newVal}`);
            if (value !== newVal) {
              value = newVal;
            }
          }
        })
      }
    }
  }

 myVue.prototype._init = function (options) {
    this.$options = options;
    this.$el = document.querySelector(options.el);
    this.$data = options.data;
    this.$methods = options.methods;

    this._obverse(this.$data);
  }

</code></pre><p>接下来我们写一个指令类Watcher，用来绑定更新函数，实现对DOM元素的更新</p><pre class="code-block"><code class="language-kotlin">function Watcher(name, el, vm, exp, attr) {
    this.name = name;         //指令名称，例如文本节点，该值设为&quot;text&quot;
    this.el = el;             //指令对应的DOM元素
    this.vm = vm;             //指令所属myVue实例
    this.exp = exp;           //指令对应的值，本例如&quot;number&quot;
    this.attr = attr;         //绑定的属性值，本例为&quot;innerHTML&quot;

    this.update();
  }

  Watcher.prototype.update = function () {
    this.el[this.attr] = this.vm.$data[this.exp]; //比如 H3.innerHTML = this.data.number; 当number改变时，会触发这个update函数，保证对应的DOM内容进行了更新。
  }

</code></pre><p>更新\_init函数以及\_obverse函数</p><pre class="code-block"><code class="language-javascript">myVue.prototype._init = function (options) {
    //...
    this._binding = {};   //_binding保存着model与view的映射关系，也就是我们前面定义的Watcher的实例。当model改变时，我们会触发其中的指令类更新，保证view也能实时更新
    //...
  }

  myVue.prototype._obverse = function (obj) {
    //...
      if (obj.hasOwnProperty(key)) {
        this._binding[key] = {    // 按照前面的数据，_binding = {number: _directives: []}                                                                                                                                                  
          _directives: []
        };
        //...
        var binding = this._binding[key];
        Object.defineProperty(this.$data, key, {
          //...
          set: function (newVal) {
            console.log(`更新${newVal}`);
            if (value !== newVal) {
              value = newVal;
              binding._directives.forEach(function (item) {  // 当number改变时，触发_binding[number]._directives 中的绑定的Watcher类的更新
                item.update();
              })
            }
          }
        })
      }
    }
  }

</code></pre><p>那么如何将view与model进行绑定呢？接下来我们定义一个\_compile函数，用来解析我们的指令（v-bind,v-model,v-clickde）等，并在这个过程中对view与model进行绑定。</p><pre class="code-block"><code class="language-ini"> myVue.prototype._init = function (options) {
   //...
    this._complie(this.$el);
  }

myVue.prototype._complie = function (root) { root 为 id为app的Element元素，也就是我们的根元素
    var _this = this;
    var nodes = root.children;
    for (var i = 0; i &lt; nodes.length; i++) {
      var node = nodes[i];
      if (node.children.length) {  // 对所有元素进行遍历，并进行处理
        this._complie(node);
      }

      if (node.hasAttribute(&#39;v-click&#39;)) {  // 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++
        node.onclick = (function () {
          var attrVal = nodes[i].getAttribute(&#39;v-click&#39;);
          return _this.$methods[attrVal].bind(_this.$data);  //bind是使data的作用域与method函数的作用域保持一致
        })();
      }

      if (node.hasAttribute(&#39;v-model&#39;) &amp;&amp; (node.tagName == &#39;INPUT&#39; || node.tagName == &#39;TEXTAREA&#39;)) { // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件
        node.addEventListener(&#39;input&#39;, (function(key) {
          var attrVal = node.getAttribute(&#39;v-model&#39;);
           //_this._binding[&#39;number&#39;]._directives = [一个Watcher实例]
           // 其中Watcher.prototype.update = function () {
           //	node[&#39;vaule&#39;] = _this.$data[&#39;number&#39;];  这就将node的值保持与number一致
           // }
          _this._binding[attrVal]._directives.push(new Watcher(
            &#39;input&#39;,
            node,
            _this,
            attrVal,
            &#39;value&#39;
          ))

          return function() {
            _this.$data[attrVal] =  nodes[key].value; // 使number 的值与 node的value保持一致，已经实现了双向绑定
          }
        })(i));
      }

      if (node.hasAttribute(&#39;v-bind&#39;)) { // 如果有v-bind属性，我们只要使node的值及时更新为data中number的值即可
        var attrVal = node.getAttribute(&#39;v-bind&#39;);
        _this._binding[attrVal]._directives.push(new Watcher(
          &#39;text&#39;,
          node,
          _this,
          attrVal,
          &#39;innerHTML&#39;
        ))
      }
    }
  }

</code></pre><p>至此，我们已经实现了一个简单vue的双向绑定功能，包括v-bind, v-model, v-click三个指令。效果如下图</p><p><img alt="" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/10/162ad3d5beb544b6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" /></p><p>附上全部代码，不到150行</p><pre class="code-block"><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;title&gt;myVue&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
  #app {
    text-align: center;
  }
&lt;/style&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;text&quot;  v-model=&quot;number&quot;&gt;
      &lt;button type=&quot;button&quot; v-click=&quot;increment&quot;&gt;增加&lt;/button&gt;
    &lt;/form&gt;
    &lt;h3 v-bind=&quot;number&quot;&gt;&lt;/h3&gt;
    &lt;form&gt;
      &lt;input type=&quot;text&quot;  v-model=&quot;count&quot;&gt;
      &lt;button type=&quot;button&quot; v-click=&quot;incre&quot;&gt;增加&lt;/button&gt;
    &lt;/form&gt;
    &lt;h3 v-bind=&quot;count&quot;&gt;&lt;/h3&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
  function myVue(options) {
    this._init(options);
  }

  myVue.prototype._init = function (options) {
    this.$options = options;
    this.$el = document.querySelector(options.el);
    this.$data = options.data;
    this.$methods = options.methods;

    this._binding = {};
    this._obverse(this.$data);
    this._complie(this.$el);
  }

  myVue.prototype._obverse = function (obj) {
    var _this = this;
    Object.keys(obj).forEach(function (key) {
      if (obj.hasOwnProperty(key)) {
        _this._binding[key] = {
          _directives: []
        };
        console.log(_this._binding[key])
        var value = obj[key];
        if (typeof value === &#39;object&#39;) {
          _this._obverse(value);
        }
        var binding = _this._binding[key];
        Object.defineProperty(_this.$data, key, {
          enumerable: true,
          configurable: true,
          get: function () {
            console.log(`${key}获取${value}`);
            return value;
          },
          set: function (newVal) {
            console.log(`${key}更新${newVal}`);
            if (value !== newVal) {
              value = newVal;
              binding._directives.forEach(function (item) {
                item.update();
              })
            }
          }
        })
      }
    })
  }

  myVue.prototype._complie = function (root) {
    var _this = this;
    var nodes = root.children;
    for (var i = 0; i &lt; nodes.length; i++) {
      var node = nodes[i];
      if (node.children.length) {
        this._complie(node);
      }

      if (node.hasAttribute(&#39;v-click&#39;)) {
        node.onclick = (function () {
          var attrVal = nodes[i].getAttribute(&#39;v-click&#39;);
          return _this.$methods[attrVal].bind(_this.$data);
        })();
      }

      if (node.hasAttribute(&#39;v-model&#39;) &amp;&amp; (node.tagName = &#39;INPUT&#39; || node.tagName == &#39;TEXTAREA&#39;)) {
        node.addEventListener(&#39;input&#39;, (function(key) {
          var attrVal = node.getAttribute(&#39;v-model&#39;);
          _this._binding[attrVal]._directives.push(new Watcher(
            &#39;input&#39;,
            node,
            _this,
            attrVal,
            &#39;value&#39;
          ))

          return function() {
            _this.$data[attrVal] =  nodes[key].value;
          }
        })(i));
      }

      if (node.hasAttribute(&#39;v-bind&#39;)) {
        var attrVal = node.getAttribute(&#39;v-bind&#39;);
        _this._binding[attrVal]._directives.push(new Watcher(
          &#39;text&#39;,
          node,
          _this,
          attrVal,
          &#39;innerHTML&#39;
        ))
      }
    }
  }

  function Watcher(name, el, vm, exp, attr) {
    this.name = name;         //指令名称，例如文本节点，该值设为&quot;text&quot;
    this.el = el;             //指令对应的DOM元素
    this.vm = vm;             //指令所属myVue实例
    this.exp = exp;           //指令对应的值，本例如&quot;number&quot;
    this.attr = attr;         //绑定的属性值，本例为&quot;innerHTML&quot;

    this.update();
  }

  Watcher.prototype.update = function () {
    this.el[this.attr] = this.vm.$data[this.exp];
  }

  window.onload = function() {
    var app = new myVue({
      el:&#39;#app&#39;,
      data: {
        number: 0,
        count: 0,
      },
      methods: {
        increment: function() {
          this.number ++;
        },
        incre: function() {
          this.count ++;
        }
      }
    })
  }
&lt;/script&gt;

</code></pre><p>如果喜欢请关注我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flouzhedong%2Fblog %22https://github.com/louzhedong/blog%22" target="_blank" rel="noopener">Github</a>，给个<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flouzhedong%2Fblog %22https://github.com/louzhedong/blog%22" target="_blank" rel="noopener">Star</a>吧，我会定期分享一些JS中的知识，^\_^</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>