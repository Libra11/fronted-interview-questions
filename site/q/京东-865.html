<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何防止前端页面重复请求【热度: 451】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：重复请求问题&lt;/p&gt;&lt;p&gt;防止前端页面的重复请求是提升用户体验和减轻服务器压力的重要策略之一。下面是一些实用的方法来减少或防止重复请求：&lt;/p&gt;&lt;h3&gt;1. 使用锁或标志位&lt;/h3&gt;&lt;p&gt;设置一个锁（flag）或状态标志位来控制请求" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="如何防止前端页面重复请求【热度: 451】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：重复请求问题&lt;/p&gt;&lt;p&gt;防止前端页面的重复请求是提升用户体验和减轻服务器压力的重要策略之一。下面是一些实用的方法来减少或防止重复请求：&lt;/p&gt;&lt;h3&gt;1. 使用锁或标志位&lt;/h3&gt;&lt;p&gt;设置一个锁（flag）或状态标志位来控制请求的发送。在首次点击或请求发起时设置该标志位，直到请求完成后再清除该标志，以阻止在请求未完成前再次发起相同的请求。&lt;/p&gt;" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/865" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>如何防止前端页面重复请求【热度: 451】</h1>
      <div class="subtitle">京东 · web应用场景 · 京东</div>
      <div class="meta">创建：2024-08-31T02:40:24Z · 更新：2024-08-31T02:42:12Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：重复请求问题</p><p>防止前端页面的重复请求是提升用户体验和减轻服务器压力的重要策略之一。下面是一些实用的方法来减少或防止重复请求：</p><h3>1. 使用锁或标志位</h3><p>设置一个锁（flag）或状态标志位来控制请求的发送。在首次点击或请求发起时设置该标志位，直到请求完成后再清除该标志，以阻止在请求未完成前再次发起相同的请求。</p><h4>示例：</h4><pre class="code-block"><code class="language-javascript">let isRequestPending = false;

function fetchData() {
  if (isRequestPending) {
    return; // 如果请求已经在进行中，则不再发起新的请求
  }

  isRequestPending = true; // 设置请求标志

  fetch(&quot;your-api-endpoint&quot;)
    .then((response) =&gt; response.json())
    .then((data) =&gt; {
      console.log(&quot;请求成功:&quot;, data);
    })
    .catch((error) =&gt; {
      console.error(&quot;请求失败:&quot;, error);
    })
    .finally(() =&gt; {
      isRequestPending = false; // 请求结束，无论成功或失败，都清除请求标志
    });
}

// 模拟用户多次点击
fetchData();
fetchData(); // 这个请求将不会被执行
</code></pre><h3>2. 使用防抖（Debounce）和节流（Throttle）</h3><p>防抖和节流是限制函数执行频率的两种常见技术，它们可以有效防止重复请求。</p><ul><li><strong>防抖</strong>：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。</li><li><strong>节流</strong>：在规定的时间内只能触发一次函数。如果这个时间内触发多次函数，只有一次生效。</li></ul><h4>示例：</h4><p>使用 lodash 的 <code>_.debounce</code> 和 <code>_.throttle</code> 方法：</p><pre class="code-block"><code class="language-javascript">import _ from &quot;lodash&quot;;

// 防抖函数
const fetchDataDebounced = _.debounce(fetchData, 300);

// 节流函数
const fetchDataThrottled = _.throttle(fetchData, 300);

// 使用防抖或节流方法来减少函数执行频率
button.addEventListener(&quot;click&quot;, fetchDataDebounced);
</code></pre><h3>3. 使用缓存结果（最佳办法）</h3><p>对于一些数据不经常变化的请求，例如用户信息、配置数据等，可以将请求的结果缓存起来。下一次请求相同的资源时，先从缓存中读取数据，如果缓存有效，则无需再发起新的网络请求。</p><p>思路类似于下面这张图</p><p><img alt="img" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6ce7486c01f451684160a7738c6417e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1103&amp;h=401&amp;s=57837&amp;e=png&amp;b=fdfdfd" /></p><p>要达到这样的效果，可以设计一个请求缓存管理器，来管理并发的请求。如果有相同的请求（URL、参数、方法相同）时，只发起一次网络调用，然后将结果分发给所有等待的请求。这种模式通常可以通过一个简单的缓存对象来实现，该对象将请求的唯一标识作为键，对应的 Promise 作为值。</p><p>以下是一个基本实现的示例：</p><pre class="code-block"><code class="language-javascript">class RequestCache {
  constructor() {
    this.cache = new Map();
  }

  // 生成请求的唯一标识符，这里仅以 URL 和 Method 为例，实际可能需要包括请求体等
  generateKey(url, method) {
    return `${method}:${url}`;
  }

  // 执行请求的方法，接受 fetch 的所有参数
  request(url, options = {}) {
    const { method = &quot;GET&quot; } = options;
    const key = this.generateKey(url, method);

    // 检查缓存中是否有相同的请求
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }

    // 没有相同的请求，发起新的请求
    const requestPromise = fetch(url, options)
      .then((response) =&gt; response.json())
      .then((data) =&gt; {
        // 请求成功后，将其从缓存中移除
        this.cache.delete(key);
        return data;
      })
      .catch((error) =&gt; {
        // 请求失败也应该从缓存中移除
        this.cache.delete(key);
        throw error;
      });

    // 将新的请求 Promise 保存在缓存中
    this.cache.set(key, requestPromise);

    return requestPromise;
  }
}

// 使用示例
const cache = new RequestCache();
const URL = &quot;https://api.example.com/data&quot;;

// 假设这三个请求几乎同时发起
cache.request(URL).then((data) =&gt; console.log(&quot;请求1:&quot;, data));
cache.request(URL).then((data) =&gt; console.log(&quot;请求2:&quot;, data));
cache.request(URL).then((data) =&gt; console.log(&quot;请求3:&quot;, data));
</code></pre><p>这个简单的 <code>RequestCache</code> 类通过一个内部的 <code>Map</code> 对象管理缓存的请求。当一个新的请求发起时，它会首先检查是否已经有相同的请求存在。如果已存在，那么它只返回先前请求的 Promise；如果不存在，它会发起一个新的网络请求，并将请求的 Promise 存储在缓存中，直到请求完成（无论是成功还是失败）之后，再将其从缓存中移除。</p><p>请注意，这里的示例非常基础，且主要用于说明如何缓存并复用请求的结果。在实际应用中，你可能还需要考虑更多细节，比如如何更精细地处理 POST 请求的请求体内容、如何设置缓存的过期时间、错误处理策略、缓存大小限制等。</p><p><strong>推荐参考文档</strong>： https://juejin.cn/post/7341840038964363283</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>