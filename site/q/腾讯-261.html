<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[Vue] 使用Proxy实现简易的vue双向数据绑定 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h3&gt;proxy 的基本使用&lt;/h3&gt;&lt;p&gt;可以直接看这个链接： https://github.com/pro-collection/interview-question/issues/8&lt;/p&gt;&lt;p&gt;使用proxy实现数据劫持&lt;/p&gt;&lt;pre class=&quot;code-bloc" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[Vue] 使用Proxy实现简易的vue双向数据绑定" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h3&gt;proxy 的基本使用&lt;/h3&gt;&lt;p&gt;可以直接看这个链接： https://github.com/pro-collection/interview-question/issues/8&lt;/p&gt;&lt;p&gt;使用proxy实现数据劫持&lt;/p&gt;&lt;pre class=&quot;code-block&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;let data = { name: YoLinDeng, h" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/261" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[Vue] 使用Proxy实现简易的vue双向数据绑定</h1>
      <div class="subtitle">腾讯 · web框架 · 腾讯</div>
      <div class="meta">创建：2023-04-08T15:28:09Z · 更新：2023-04-08T15:28:10Z</div>
    </div>
    <article class="content markdown-body"><h3>proxy 的基本使用</h3><p>可以直接看这个链接： https://github.com/pro-collection/interview-question/issues/8</p><p>使用proxy实现数据劫持</p><pre class="code-block"><code class="language-js">let data = {
    name: YoLinDeng,
    height: &#39;176cm&#39;
}

const p = new Proxy(data, {
    get(target, prop) {
        return Reflect.get(...arguments)
    },
    set(target, prop, newValue) {
        return Reflect.set(...arguments)
    }
})
</code></pre><h3>关于vue中数据响应式的原理</h3><h4>对数据进行侦测</h4><ul><li>在vue2.X中，实现一个<code>observe</code>类，对于对象数据，通过<code>Object.defineProperty</code>来劫持对象的属性，实现<code>getter</code>和<code>setter</code>方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过<code>Dep类</code>（订阅器）收集统一管理，在setter的时候调用Dep类中的<code>notify</code>方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用<code>observe</code>进行处理。</li><li>对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用<code>push/pop/shift/unshift/splice/sort/reverse</code>修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。</li><li>vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。</li></ul><h4>对模板字符串进行编译</h4><ul><li>实现Compile解析器类，将<code>template</code>中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（<code>start</code>）并判断是否自闭和以及解析属性、结束标签（<code>end</code>）、文本（<code>chars</code>）、注释（<code>comment</code>）</li><li>将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面<code>dom-diff</code>算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。</li><li>最后根据处理好的ast生产<code>render</code>函数，在组件挂载的时候调用<code>render</code>函数就可以得到虚拟dom。</li></ul><h4>虚拟dom</h4><ul><li>vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</li><li>通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做<code>patch</code>的过程，其主要做了三件事，分别是创建/删除/更新节点。</li><li>对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。</li></ul><h3>实现简易的vue双向数据绑定</h3><p>vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。</p><p><strong>实现代码如下</strong></p><pre class="code-block"><code class="language-handlebars">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width= , initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;myVue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    {{name}}
    &lt;div&gt;{{message}}&lt;/div&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;test&quot;&gt;
    &lt;span&gt;{{test}}&lt;/span&gt;
  &lt;/div&gt;
  &lt;script&gt;
    let vm = new vue({
      el: &#39;#app&#39;,
      data: {
        name: &#39;YoLinDeng&#39;,
        message: &#39;打篮球&#39;,
        test: &#39;双向绑定数据&#39;
      }
    })
    // console.log(vm._data)
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre class="code-block"><code class="language-js">class vue extends EventTarget {
  constructor(option) {
    super()
    this.option = option
    this._data = this.option.data
    this.el = document.querySelector(this.option.el)
    this.compileNode(this.el)
    this.observe(this._data)
  }
  // 实现监听器方法
  observe(data) {
    const context = this
    // 使用proxy代理，劫持数据
    this._data = new Proxy(data, {
      set(target, prop, newValue) {
        // 自定义事件
        let event = new CustomEvent(prop, {
          detail: newValue
        })
        // 发布自定义事件
        context.dispatchEvent(event)
        return Reflect.set(...arguments)
      }
    })
  }
  // 实现解析器方法，解析模板
  compileNode(el) {
    let child = el.childNodes
    let childArr = [...child]
    childArr.forEach(node =&gt; {
      if (node.nodeType === 3) {
        let text = node.textContent
        let reg = /\{\{\s*([^\s\{\}]+)\s*\}\}/g
        if (reg.test(text)) {
          let $1 = RegExp.$1
          this._data[$1] &amp;&amp; (node.textContent = text.replace(reg, this._data[$1]))
          // 监听数据更改事件
          this.addEventListener($1, e =&gt; {
            node.textContent = text.replace(reg, e.detail)
          })
        }
      } else if (node.nodeType === 1) { // 如果是元素节点
        let attr = node.attributes
        // 判断属性中是否含有v-model
        if (attr.hasOwnProperty(&#39;v-model&#39;)) {
          let keyName = attr[&#39;v-model&#39;].nodeValue
          node.value = this._data[keyName]
          node.addEventListener(&#39;input&#39;, e =&gt; {
            this._data[keyName] = node.value
          })
        }
        // 递归调用解析器方法
        this.compileNode(node)
      }
    })
  }
}
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>