<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[webpack] 手写 loader: 我要在方法调用的时候， 上报调用源文件地址【热度: 117】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：手写 webpack loader&lt;/p&gt;&lt;p&gt;要在方法调用时上报调用源文件的地址，并且希望通过 webpack 编译时来实现，你可以通过编写一个自定义的 webpack loader 来操作源代码，为特定的方法调用插入上报的代码。" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[webpack] 手写 loader: 我要在方法调用的时候， 上报调用源文件地址【热度: 117】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：手写 webpack loader&lt;/p&gt;&lt;p&gt;要在方法调用时上报调用源文件的地址，并且希望通过 webpack 编译时来实现，你可以通过编写一个自定义的 webpack loader 来操作源代码，为特定的方法调用插入上报的代码。自定义 loader 本质上是一个函数，该函数接收源码作为输入，对源码进行处理后返回新的源码。&lt;/p&gt;&lt;h3&gt;步骤 1:" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/839" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[webpack] 手写 loader: 我要在方法调用的时候， 上报调用源文件地址【热度: 117】</h1>
      <div class="subtitle">工程化 · 工程化 · 阿里巴巴</div>
      <div class="meta">创建：2024-08-18T06:36:13Z · 更新：2024-08-18T06:36:14Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：手写 webpack loader</p><p>要在方法调用时上报调用源文件的地址，并且希望通过 webpack 编译时来实现，你可以通过编写一个自定义的 webpack loader 来操作源代码，为特定的方法调用插入上报的代码。自定义 loader 本质上是一个函数，该函数接收源码作为输入，对源码进行处理后返回新的源码。</p><h3>步骤 1: 设计你的上报逻辑</h3><p>首先明确你想要上报的信息和上报的方式。比如，你可能想要在方法调用时，插入一个上报函数调用，该函数包含当前文件的路径和文件名。</p><h3>步骤 2: 创建自定义 Loader</h3><p>你可以开始编写你的 loader。假设你有一个上报函数 <code>reportFunction(filePath)</code>，你希望自动为所有 <code>targetMethod()</code> 调用注入这个上报函数。</p><p>loader 文件 <code>report-loader.js</code> 可能看起来像这样：</p><pre class="code-block"><code class="language-javascript">module.exports = function (source) {
  // 使用此 loader 处理的文件的路径
  const filePath = this.resourcePath;

  // 定义一个正则表达式匹配特定的方法调用，比如 targetMethod()
  const methodCallRegex = /targetMethod\(\)/g;

  // 替换匹配到的方法调用
  const modifiedSource = source.replace(methodCallRegex, function (match) {
    // 插入上报函数调用，传入文件路径
    return `reportFunction(&#39;${filePath}&#39;); ${match}`;
  });

  return modifiedSource;
};
</code></pre><p>这个简单的 loader 使用正则表达式查找文件中所有的 <code>targetMethod()</code> 调用，并在每个调用前插入 <code>reportFunction(filePath)</code> 的调用。注意，考虑到文件路径可能需要处理才能安全地用作字符串字面量（例如，转义特殊字符），这里的实现做得很简单，可能需要根据你的具体需求调整。</p><h3>步骤 3: 在 webpack 配置中使用你的 Loader</h3><p>在你的 <code>webpack.config.js</code> 文件中，添加一个 <code>module.rules</code> 条目，以确定哪些文件应该通过你的 loader 处理：</p><pre class="code-block"><code class="language-javascript">module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/, // 匹配 JavaScript 文件
        use: [
          {
            loader: &quot;path/to/your/report-loader.js&quot;, // 使用自定义 loader 的路径
          },
        ],
      },
    ],
  },
};
</code></pre><p>确保将 <code>loader</code> 属性设置为你自定义 loader 文件的路径。</p><h3>注意事项</h3><ol><li><strong>正则表达式</strong>: 我在例子中使用的正则表达式非常简单，只匹配特定形式的方法调用。根据你的需要，可能要编写更复杂的正则表达式或使用其他方法（比如抽象语法树解析库，如 Babel）来更准确地识别和修改代码。</li></ol><ol><li><strong>安全性</strong>: 自动修改源代码会带来风险，确保你的匹配和替换逻辑不会导致代码中出现意外的改变。</li></ol><ol><li><strong>性能</strong>: 增加自定义 loader 可能会影响构建的速度，特别是匹配和修改逻辑比较复杂的时候。</li></ol><p>编写和测试好你的 loader 后，就可以集成到你的项目中，通过 webpack 构建过程中自动执行所需的代码注入了。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>