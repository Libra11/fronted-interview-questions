<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何 对 react 状态库进行单测， 比如 redux、recoil 等状态库【热度: 170】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：前端单测模拟 react 状态&lt;/p&gt;&lt;p&gt;下面分别介绍如何对 Redux 和 Recoil 这两种常见的 React 状态库进行单元测试。&lt;/p&gt;&lt;h3&gt;测试 Redux&lt;/h3&gt;&lt;p&gt;Redux 是一个可预测的状态容器，主要由 " />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="如何 对 react 状态库进行单测， 比如 redux、recoil 等状态库【热度: 170】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：前端单测模拟 react 状态&lt;/p&gt;&lt;p&gt;下面分别介绍如何对 Redux 和 Recoil 这两种常见的 React 状态库进行单元测试。&lt;/p&gt;&lt;h3&gt;测试 Redux&lt;/h3&gt;&lt;p&gt;Redux 是一个可预测的状态容器，主要由 actions、reducers 和 store 构成。单元测试时可分别对这些部分进行测试。&lt;/p&gt;&lt;h4&gt;1. 测试 " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/1105" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>如何 对 react 状态库进行单测， 比如 redux、recoil 等状态库【热度: 170】</h1>
      <div class="subtitle">工程化 · 工程化</div>
      <div class="meta">创建：2025-03-25T15:42:24Z · 更新：2025-03-25T15:42:24Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：前端单测模拟 react 状态</p><p>下面分别介绍如何对 Redux 和 Recoil 这两种常见的 React 状态库进行单元测试。</p><h3>测试 Redux</h3><p>Redux 是一个可预测的状态容器，主要由 actions、reducers 和 store 构成。单元测试时可分别对这些部分进行测试。</p><h4>1. 测试 Actions</h4><p>Actions 是用于描述状态变化的普通 JavaScript 对象。可以测试 action 创建函数是否返回正确的 action 对象。</p><pre class="code-block"><code class="language-javascript">// actions.js
export const increment = () =&gt; ({
  type: &quot;INCREMENT&quot;,
});

// actions.test.js
import { increment } from &quot;./actions&quot;;

describe(&quot;increment action&quot;, () =&gt; {
  test(&quot;should return an action with type INCREMENT&quot;, () =&gt; {
    const action = increment();
    expect(action.type).toBe(&quot;INCREMENT&quot;);
  });
});
</code></pre><h4>2. 测试 Reducers</h4><p>Reducers 是纯函数，接收当前状态和 action，返回新的状态。可以测试 reducer 在不同 action 下是否返回正确的状态。</p><pre class="code-block"><code class="language-javascript">// reducer.js
const initialState = {
  count: 0,
};

const counterReducer = (state = initialState, action) =&gt; {
  switch (action.type) {
    case &quot;INCREMENT&quot;:
      return {
        ...state,
        count: state.count + 1,
      };
    default:
      return state;
  }
};

export default counterReducer;

// reducer.test.js
import counterReducer from &quot;./reducer&quot;;

describe(&quot;counterReducer&quot;, () =&gt; {
  test(&quot;should handle INCREMENT action&quot;, () =&gt; {
    const initialState = { count: 0 };
    const action = { type: &quot;INCREMENT&quot; };
    const newState = counterReducer(initialState, action);
    expect(newState.count).toBe(1);
  });

  test(&quot;should return the same state for unknown action&quot;, () =&gt; {
    const initialState = { count: 0 };
    const action = { type: &quot;UNKNOWN_ACTION&quot; };
    const newState = counterReducer(initialState, action);
    expect(newState).toEqual(initialState);
  });
});
</code></pre><h4>3. 测试 Connected Components</h4><p>如果组件通过 <code>connect</code> 函数连接到 Redux store，可以使用 <code>enzyme</code> 或 <code>@testing-library/react</code> 来测试组件是否正确接收和使用 store 中的状态和 actions。</p><pre class="code-block"><code class="language-jsx">// CounterComponent.jsx
import React from &quot;react&quot;;
import { connect } from &quot;react-redux&quot;;
import { increment } from &quot;./actions&quot;;

const CounterComponent = ({ count, increment }) =&gt; (
  &lt;div&gt;
    &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
);

const mapStateToProps = (state) =&gt; ({
  count: state.count,
});

const mapDispatchToProps = {
  increment,
};

export default connect(mapStateToProps, mapDispatchToProps)(CounterComponent);

// CounterComponent.test.js
import React from &quot;react&quot;;
import { render, fireEvent, screen } from &quot;@testing-library/react&quot;;
import { Provider } from &quot;react-redux&quot;;
import configureStore from &quot;redux-mock-store&quot;;
import CounterComponent from &quot;./CounterComponent&quot;;

const mockStore = configureStore([]);

describe(&quot;CounterComponent&quot;, () =&gt; {
  let store;

  beforeEach(() =&gt; {
    store = mockStore({ count: 0 });
  });

  test(&quot;should display the count from the store&quot;, () =&gt; {
    render(
      &lt;Provider store={store}&gt;
        &lt;CounterComponent /&gt;
      &lt;/Provider&gt;
    );
    const countElement = screen.getByText(&quot;Count: 0&quot;);
    expect(countElement).toBeInTheDocument();
  });

  test(&quot;should dispatch increment action on button click&quot;, () =&gt; {
    render(
      &lt;Provider store={store}&gt;
        &lt;CounterComponent /&gt;
      &lt;/Provider&gt;
    );
    const incrementButton = screen.getByText(&quot;Increment&quot;);
    fireEvent.click(incrementButton);
    const actions = store.getActions();
    expect(actions).toEqual([{ type: &quot;INCREMENT&quot; }]);
  });
});
</code></pre><h3>测试 Recoil</h3><p>Recoil 是一个用于管理 React 应用状态的库，主要包含 atoms（原子状态）和 selectors（派生状态）。</p><h4>1. 测试 Atoms</h4><p>Atoms 是 Recoil 中的基本状态单元。可以测试 atoms 的初始值是否正确。</p><pre class="code-block"><code class="language-javascript">// atoms.js
import { atom } from &quot;recoil&quot;;

export const counterState = atom({
  key: &quot;counterState&quot;,
  default: 0,
});

// atoms.test.js
import { counterState } from &quot;./atoms&quot;;
import { useRecoilValue } from &quot;recoil&quot;;
import { renderHook } from &quot;@testing-library/react-hooks&quot;;

describe(&quot;counterState&quot;, () =&gt; {
  test(&quot;should have an initial value of 0&quot;, () =&gt; {
    const { result } = renderHook(() =&gt; useRecoilValue(counterState));
    expect(result.current).toBe(0);
  });
});
</code></pre><h4>2. 测试 Selectors</h4><p>Selectors 是基于 atoms 或其他 selectors 派生出来的状态。可以测试 selectors 是否正确计算派生状态。</p><pre class="code-block"><code class="language-javascript">// selectors.js
import { atom, selector } from &quot;recoil&quot;;

export const counterState = atom({
  key: &quot;counterState&quot;,
  default: 0,
});

export const doubleCounterSelector = selector({
  key: &quot;doubleCounterSelector&quot;,
  get: ({ get }) =&gt; {
    const count = get(counterState);
    return count * 2;
  },
});

// selectors.test.js
import { counterState, doubleCounterSelector } from &quot;./selectors&quot;;
import { useRecoilValue, set } from &quot;recoil&quot;;
import { renderHook } from &quot;@testing-library/react-hooks&quot;;

describe(&quot;doubleCounterSelector&quot;, () =&gt; {
  test(&quot;should return double the counter value&quot;, () =&gt; {
    const { result } = renderHook(() =&gt; useRecoilValue(doubleCounterSelector));
    expect(result.current).toBe(0);

    const { set } = renderHook(() =&gt; ({
      set: (value) =&gt; useSetRecoilState(counterState)(value),
    })).result.current;

    set(5);
    const { result: newResult } = renderHook(() =&gt; useRecoilValue(doubleCounterSelector));
    expect(newResult.current).toBe(10);
  });
});
</code></pre><h4>3. 测试 Recoil 组件</h4><p>可以测试使用 Recoil 状态的组件是否正确更新和渲染。</p><pre class="code-block"><code class="language-jsx">// CounterComponent.jsx
import React from &quot;react&quot;;
import { useRecoilState } from &quot;recoil&quot;;
import { counterState } from &quot;./atoms&quot;;

const CounterComponent = () =&gt; {
  const [count, setCount] = useRecoilState(counterState);

  const increment = () =&gt; {
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default CounterComponent;

// CounterComponent.test.js
import React from &quot;react&quot;;
import { render, fireEvent, screen } from &quot;@testing-library/react&quot;;
import { RecoilRoot } from &quot;recoil&quot;;
import CounterComponent from &quot;./CounterComponent&quot;;

describe(&quot;CounterComponent&quot;, () =&gt; {
  test(&quot;should display the count and increment on button click&quot;, () =&gt; {
    render(
      &lt;RecoilRoot&gt;
        &lt;CounterComponent /&gt;
      &lt;/RecoilRoot&gt;
    );
    const countElement = screen.getByText(&quot;Count: 0&quot;);
    expect(countElement).toBeInTheDocument();

    const incrementButton = screen.getByText(&quot;Increment&quot;);
    fireEvent.click(incrementButton);

    const newCountElement = screen.getByText(&quot;Count: 1&quot;);
    expect(newCountElement).toBeInTheDocument();
  });
});
</code></pre><p>通过以上方法，可以对 Redux 和 Recoil 状态库进行有效的单元测试，确保状态管理逻辑的正确性。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>