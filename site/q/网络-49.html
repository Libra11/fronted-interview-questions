<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>fetch 了解多少？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h1&gt;深入fetch&lt;/h1&gt;&lt;h2&gt;fetch 的简单介绍&lt;/h2&gt;&lt;p&gt;Fetch 被称为下一代Ajax技术,采用Promise方式来处理数据。&lt;/p&gt;&lt;p&gt;是一种简洁明了的API，比XMLHttpRequest更加简单易用。&lt;/p&gt;&lt;p&gt;页面中需要向服务器请求数据时，基本" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="fetch 了解多少？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h1&gt;深入fetch&lt;/h1&gt;&lt;h2&gt;fetch 的简单介绍&lt;/h2&gt;&lt;p&gt;Fetch 被称为下一代Ajax技术,采用Promise方式来处理数据。&lt;/p&gt;&lt;p&gt;是一种简洁明了的API，比XMLHttpRequest更加简单易用。&lt;/p&gt;&lt;p&gt;页面中需要向服务器请求数据时，基本上都会使用Ajax来实现。&lt;/p&gt;&lt;p&gt;Ajax的本质是使用XMLHttpRequest对象来请求数据，而XMLHttp" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/49" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>fetch 了解多少？</h1>
      <div class="subtitle">网络 · 网络</div>
      <div class="meta">创建：2023-03-09T16:03:43Z · 更新：2025-05-31T05:22:03Z</div>
    </div>
    <article class="content markdown-body"><h1>深入fetch</h1><h2>fetch 的简单介绍</h2><p>Fetch  被称为下一代Ajax技术,采用Promise方式来处理数据。</p><p>是一种简洁明了的API，比XMLHttpRequest更加简单易用。</p><p>页面中需要向服务器请求数据时，基本上都会使用Ajax来实现。</p><p>Ajax的本质是使用XMLHttpRequest对象来请求数据，而XMLHttpRequest对象是通过事件的模式来实现返回数据的处理。</p><p>与XMLHttpRequest类似，Fetch允许你发出AJAX请求。</p><p>区别在于Fetch API使用Promise方式，Promise是已经正式发布的ES6的内容之一，</p><p>因此是一种简洁明了的API，比XMLHttpRequest更加简单易用。</p><h2>XMLHttpRequest 的使用</h2><p>AJAX半遮半掩的底层API是饱受诟病的一件事情. XMLHttpRequest 并不是专为Ajax而设计的。</p><p>虽然各种框架对 XHR 的封装已经足够好用, 但我们可以做得更好。更好用的API是 fetch 。</p><p>下面简单介绍 window.fetch 方法, 在最新版的 Firefox 和 Chrome 中已经提供支持。</p><p>在我看来 XHR 有点复杂。使用XHR的方式大致如下:</p><pre class="code-block"><code class="language-javascript">let getJson = function (url) {
    return new Promise(function (resolve, reject) {
        let client = new XMLHttpRequest();
        client.open(&#39;GET&#39;, url);
        client.setRequestHeader(&#39;Accept&#39;, &#39;application/json&#39;);
        client.responseType = &#39;json&#39;;
        client.onreadystatechange = function () {
            if(this.status === 200) {
                resolve(this.response)
            } else {
                reject(this.statusText)
            }
        };
        client.send()
    })
};
</code></pre><h2>fetch 的使用</h2><p>fetch 是全局量 window 的一个方法, 第一个参数是URL:</p><pre class="code-block"><code class="language-javascript">// url (必须), options (可选)
fetch(&#39;/some/url&#39;, {
    method: &#39;get&#39;
}).then(function(response) {

}).catch(function(err) {
    // 出错了;等价于 then 的第二个参数,但这样更好用更直观 :(
});
</code></pre><p>fetch API 也使用了 JavaScript Promises 来处理结果/回调:</p><pre class="code-block"><code class="language-javascript">// 对响应的简单处理
fetch(&#39;/some/url&#39;).then(function(response) {

}).catch(function(err) {
    // 出错了;等价于 then 的第二个参数,但这样更直观 :(
});

// 链式处理,将异步变为类似单线程的写法: 高级用法.
fetch(&#39;/some/url&#39;).then(function(response) {
    return new Promise()  //... 执行成功, 第1步...
}).then(function(returnedValue) {
    // ... 执行成功, 第2步...
}).catch(function(err) {
    // 中途任何地方出错...在此处理 :( 
});
</code></pre><h2>请求头(Request Headers)</h2><p>自定义请求头信息极大地增强了请求的灵活性。我们可以通过 new Headers() 来创建请求头:</p><pre class="code-block"><code class="language-javascript">// 创建一个空的 Headers 对象,注意是Headers，不是Header
var headers = new Headers();

// 添加(append)请求头信息
headers.append(&#39;Content-Type&#39;, &#39;text/plain&#39;);
headers.append(&#39;X-My-Custom-Header&#39;, &#39;CustomValue&#39;);

// 判断(has), 获取(get), 以及修改(set)请求头的值
headers.has(&#39;Content-Type&#39;); // true
headers.get(&#39;Content-Type&#39;); // &quot;text/plain&quot;
headers.set(&#39;Content-Type&#39;, &#39;application/json&#39;);

// 删除某条请求头信息(a header)
headers.delete(&#39;X-My-Custom-Header&#39;);

// 创建对象时设置初始化信息
var headers = new Headers({
    &#39;Content-Type&#39;: &#39;text/plain&#39;,
    &#39;X-My-Custom-Header&#39;: &#39;CustomValue&#39;
});
</code></pre><p>可以使用的方法包括: append, has, get, set, 以及 delete 。</p><p>需要创建一个 Request 对象来包装请求头:</p><pre class="code-block"><code class="language-javascript">var request = new Request(&#39;/some-url&#39;, {
    headers: new Headers({
        &#39;Content-Type&#39;: &#39;text/plain&#39;
    })
});

fetch(request).then(function() { /* handle response */ });
</code></pre><h2>Request 简介</h2><p>Request 对象表示一次 fetch 调用的请求信息。传入 Request 参数来调用 fetch, 可以执行很多自定义请求的高级用法:</p><ul><li>method - 支持 GET, POST, PUT, DELETE, HEAD</li><li>url - 请求的 URL</li><li>body(String): HTTP的请求参数</li><li>headers - 对应的 Headers 对象</li><li>referrer - 请求的 referrer 信息</li><li>mode - 可以设置 cors, no-cors, same-origin</li><li>credentials - 设置 cookies 是否随请求一起发送。可以设置: omit, same-origin</li><li>redirect - follow, error, manual</li><li>integrity - subresource 完整性值(integrity value)</li><li>cache - 设置 cache 模式 (default, reload, no-cache)</li></ul><p>Request 的示例如下:</p><pre class="code-block"><code class="language-javascript">var request = new Request(&#39;/users.json&#39;, {
    method: &#39;POST&#39;, 
    mode: &#39;cors&#39;, 
    redirect: &#39;follow&#39;,
    headers: new Headers({
        &#39;Content-Type&#39;: &#39;text/plain&#39;
    })
});

fetch(request).then(function() { /* handle response */ });
</code></pre><p>只有第一个参数 URL 是必需的。在 Request 对象创建完成之后, 所有的属性都变为只读属性.</p><p>请注意, Request 有一个很重要的 clone 方法, 特别是在 Service Worker API 中使用时 —— 一个 Request 就代表一串流(stream), 如果想要传递给另一个 fetch 方法,则需要进行克隆。</p><p>fetch 的方法签名(signature,可理解为配置参数), 和 Request 很像, 示例如下:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;/users.json&#39;, {
    method: &#39;POST&#39;, 
    mode: &#39;cors&#39;, 
    redirect: &#39;follow&#39;,
    headers: new Headers({
        &#39;Content-Type&#39;: &#39;text/plain&#39;
    })
}).then(function() { /* handle response */ });
</code></pre><h2>Response 简介</h2><p>Response 代表响应, fetch 的 then 方法接收一个 Response 实例,</p><p>当然你也可以手动创建 Response 对象 —— 比如在 service workers 中可能会用到. Response 可以配置的参数包括:</p><ul><li>type - 类型,支持: basic, cors</li><li>url</li><li>useFinalURL - Boolean 值, 代表 url 是否是最终 URL</li><li>status - 状态码 (例如: 200, 404, 等等)</li><li>ok - Boolean值,代表成功响应(status 值在 200-299 之间)</li><li>statusText - 状态值(例如: OK)</li><li>headers - 与响应相关联的 Headers 对象.</li></ul><pre class="code-block"><code class="language-javascript">// 在 service worker 测试中手动创建 response
// new Response(BODY, OPTIONS)
var response = new Response(&#39;.....&#39;, {
    ok: false,
    status: 404,
    url: &#39;/&#39;
});

// fetch 的 `then` 会传入一个 Response 对象
fetch(&#39;/&#39;)
    .then(function(responseObj) {
        console.log(&#39;status: &#39;, responseObj.status);
    });
</code></pre><p><strong>Response 提供的方法如下:</strong></p><ul><li>clone() - 创建一个新的 Response 克隆对象.</li><li>error() - 返回一个新的,与网络错误相关的 Response 对象.</li><li>redirect() - 重定向,使用新的 URL 创建新的 response 对象..</li><li>arrayBuffer() - Returns a promise that resolves with an ArrayBuffer.</li><li>blob() - 返回一个 promise, resolves 是一个 Blob.</li><li>formData() - 返回一个 promise, resolves 是一个 FormData 对象.</li><li>json() - 返回一个 promise, resolves 是一个 JSON 对象.</li><li>text() - 返回一个 promise, resolves 是一个 USVString (text).</li></ul><h3>处理 JSON响应</h3><p>假设需要请求 JSON —— 回调结果对象 response 中有一个json()方法,用来将原始数据转换成 JavaScript 对象:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;https://davidwalsh.name/demo/arsenal.json&#39;).then(function(response) { 
    // 转换为 JSON
    return response.json();
}).then(function(j) {
    // 现在, `j` 是一个 JavaScript object
    console.log(j); 
});
</code></pre><h3>处理基本的Text / HTML响应</h3><p>JSON 并不总是理想的请求/响应数据格式, 那么我们看看如何处理 HTML或文本结果:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;/next/page&#39;)
  .then(function(response) {
    return response.text();
  }).then(function(text) { 
    // &lt;!DOCTYPE ....
    console.log(text); 
  });
</code></pre><h3>处理Blob结果</h3><p>如果你想通过 fetch 加载图像或者其他二进制数据, 则会略有不同:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;flowers.jpg&#39;)
    .then(function(response) {
      return response.blob();
    })
    .then(function(imageBlob) {
      document.querySelector(&#39;img&#39;).src = URL.createObjectURL(imageBlob);
    });
</code></pre><h3>提交表单数据(Posting Form Data)</h3><p>另一种常用的 AJAX 调用是提交表单数据 —— 示例代码如下:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;/submit&#39;, {
    method: &#39;post&#39;,
    body: new FormData(document.getElementById(&#39;comment-form&#39;))
});
</code></pre><p>提交 JSON 的示例如下:</p><pre class="code-block"><code class="language-javascript">fetch(&#39;/submit-json&#39;, {
    method: &#39;post&#39;,
    body: JSON.stringify({
        email: document.getElementById(&#39;email&#39;).value
        answer: document.getElementById(&#39;answer&#39;).value
    })
});
</code></pre><h2>fetch取消</h2><p>fetch 并不支持 取消请求的功能</p><h2>Comments / Answers</h2><hr /><p><strong>Guan-Erjia</strong> at 2025-05-31T05:22:02Z</p><p>现在好像支持传入 AbortController 了</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>