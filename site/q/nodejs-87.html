<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何进行 node 内存优化？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;目录&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#V8内存生命周期&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V8 内存生命周期&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#垃圾回收器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;垃圾" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="如何进行 node 内存优化？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;目录&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#V8内存生命周期&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V8 内存生命周期&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#垃圾回收器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;垃圾回收器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#JavaScript的垃圾回收器&quot; target=&quot;_blank&quot; " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/87" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>如何进行 node 内存优化？</h1>
      <div class="subtitle">Nodejs · Nodejs</div>
      <div class="meta">创建：2023-03-11T12:26:19Z · 更新：2023-03-11T12:26:58Z</div>
    </div>
    <article class="content markdown-body"><p>目录</p><ul><li><a href="#V8内存生命周期" target="_blank" rel="noopener">V8 内存生命周期</a></li><li><a href="#垃圾回收器" target="_blank" rel="noopener">垃圾回收器</a></li><li><a href="#JavaScript的垃圾回收器" target="_blank" rel="noopener">JavaScript的垃圾回收器</a></li><li><a href="#内存管理问题" target="_blank" rel="noopener">内存管理问题</a></li><li><a href="#Chrome的内存限制" target="_blank" rel="noopener">Chrome的内存限制</a></li><li><a href="#存在限制" target="_blank" rel="noopener">存在限制</a></li><li><a href="#为何限制" target="_blank" rel="noopener">为何限制</a></li><li><a href="#ChromeV8的堆构成" target="_blank" rel="noopener">Chrome-V8的堆构成</a></li><li><a href="#ChromeV8的垃圾回收机制" target="_blank" rel="noopener">ChromeV8的垃圾回收机制</a></li><li><a href="#如何判断回收内容" target="_blank" rel="noopener">如何判断回收内容</a></li><li><a href="#如何识别指针和数据" target="_blank" rel="noopener">如何识别指针和数据</a></li><li><a href="#V8的回收策略" target="_blank" rel="noopener">V8的回收策略</a></li><li><a href="#V8的分代内存" target="_blank" rel="noopener">V8的分代内存</a></li><li><a href="#新生代" target="_blank" rel="noopener">新生代</a></li><li><a href="#新生代的特点" target="_blank" rel="noopener">新生代的特点</a></li><li><a href="#新生代的垃圾回收算法" target="_blank" rel="noopener">新生代的垃圾回收算法</a></li><li><a href="#写屏障" target="_blank" rel="noopener">写屏障</a></li><li><a href="#对象的晋升" target="_blank" rel="noopener">对象的晋升</a></li><li><a href="#老生代" target="_blank" rel="noopener">老生代</a></li><li><a href="#老生代的特点" target="_blank" rel="noopener">老生代的特点</a></li><li><a href="#老生代的垃圾回收算法" target="_blank" rel="noopener">老生代的垃圾回收算法</a></li><li><a href="#算法思路" target="_blank" rel="noopener">算法思路</a></li><li><a href="#结合使用标记清除和标记整理" target="_blank" rel="noopener">结合使用标记清除和标记整理</a></li></ul><p><a href="/books/专题知识库/05、基础知识点专题/other/14、V8引擎初步介绍/README.md" target="_blank" rel="noopener">前置知识点儿请看这里</a></p><h2>V8内存生命周期</h2><p>假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：</p><p>1、这个对象被分配到了 new space；</p><p>2、随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；</p><p>3、gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；</p><p>4、随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。</p><p>说明：</p><p>第二步里，清理 new space 的过程叫做 <strong>Scavenge</strong>，这个过程采用了空间换时间的做法，</p><p>用到了上面图中的 <strong>inactive new space</strong>，过程如下：</p><p>当活跃区满了之后，交换活跃区和非活跃区，交换后活跃区变空了；</p><p>将非活跃区的两次清理都没清理出去的对象移动到 old space；</p><p>将还没清理够两次的但是活跃状态的对象移动到活跃区。</p><p>第四步里，清理 old space 的过程叫做 <strong>Mark-sweep</strong> ，这块占用内存很大，所以没有使用 Scavenge，</p><p>这个回收过程包含了若干次标记过程和清理过程：</p><p>标记从根（root）可达的对象为黑色；</p><p>遍历黑色对象的邻接对象，直到所有对象都标记为黑色；</p><p>循环标记若干次；</p><p>清理掉非黑色的对象。</p><p>简单来说，<strong>Mark-sweep 就是把从根节点无法获取到的对象清理掉了。</strong></p><h2>垃圾回收器</h2><h3>JavaScript的垃圾回收器</h3><p>JavaScript使用垃圾回收机制来自动管理内存。</p><p>垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因 长时间运转而带来的内存泄露问题。</p><p>但使用了垃圾回收即意味着程序员将无法掌控内存。</p><p>ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进 行垃圾回收，更无法干预内存管理</p><h3>内存管理问题</h3><p>在浏览器中，Chrome V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。</p><p>如果不幸发生内存泄露等问题，仅仅会 影响到一个终端用户。</p><p>且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需 要管理内存）。</p><p>但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。</p><h2>Chrome的内存限制</h2><h3>存在限制</h3><p>Chrome限制了所能使用的内存极限（64位为1.4GB，32位为1.0GB），这也就意味着将无法直接操作一些大内存对象。</p><h3>为何限制</h3><p>Chrome之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，</p><p>而深层次的原因 则是由于<strong>V8的垃圾回收机制的限制。</strong></p><p>由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞 JavaScript应用逻辑，</p><p>直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。</p><p>若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。</p><p>这样浏览器将在1s内失去对用户的响 应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。</p><h2>ChromeV8的堆构成</h2><p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：</p><ul><li>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁</li><li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li><li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</li><li>大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象</li><li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li><li>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li></ul><p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，</p><p>其他区的内存页都是1MB大小，而且按照1MB对 齐。</p><p>内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。</p><p>另外每个内存页还有一个单独分配在另外内 存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。</p><p>垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收</p><h2>ChromeV8的垃圾回收机制</h2><h3>如何判断回收内容</h3><p>如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。</p><p>我们可以这样假定，一个对象为活对象当且仅当它被一个根对象 或另一个活对象指向。根对象永远是活对象，它是被浏览器或V8所引用的对象。</p><h3>如何识别指针和数据</h3><p>垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写。</p><p>目前主要有三种方法来识别指针：</p><ol><li>保守法：</li></ol><p>将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。</p><p>于是某些实际是数字的假指针，会背误认为指向活跃对象，</p><p>导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。</p><ol><li>编译器提示法：</li></ol><p>如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，</p><p>而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。</p><p>这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言</p><ol><li>标记指针法：</li></ol><p>这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。</p><p>这种方法需要编译器支持，但实现简单，而且性能不错。</p><p>V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</p><h3>V8的回收策略</h3><p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。</p><p>所以V8采用了一种分代回收的策 略，将内存分为两个生代：新生代和老生代。</p><p>新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p><p>分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。</p><p>对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p><h3>V8的分代内存</h3><p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。</p><p>V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。</p><p>具体的计算公式是4*reserved_semispace_space_ + max_old_generation_size_，</p><p>新生代由两块reserved_semispace_space_组成，每块16MB（64位）或8MB（32位）</p><h2>新生代</h2><h3>新生代的特点</h3><p>大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。</p><p>在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。</p><p>当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p><h3>新生代的垃圾回收算法</h3><p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p><p>具体的执行过程大致是这样：</p><p>首先将From空间中所有能从根对象到达的对象复制到To区，</p><p>然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将 扫描的活跃对象和即将为新对象分配内存的地方，开始循环。</p><p>循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。</p><p>如果指向 老生代我们就不必考虑它了。</p><p>如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr 所指向的位置。</p><p>复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。</p><p>如果一个对象内部的所有指针 都被处理完，scanPtr就会向前移动，进入下一个循环。</p><p>若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From 区剩下的都可以被视为垃圾，可以进行清理了。</p><p>举个栗子(以及凑篇幅)，如果有类似如下的引用情况：</p><pre class="code-block"><code>          +----- A对象
          |
根对象----+----- B对象 ------ E对象
          |
          +----- C对象 ----+---- F对象 
                           |
                           +---- G对象 ----- H对象

    D对象
</code></pre><p>在执行Scavenge之前，From区长这幅模样</p><pre class="code-block"><code>+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
</code></pre><p>那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：</p><pre class="code-block"><code>          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
 ↑
scanPtr  
</code></pre><p>接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样</p><pre class="code-block"><code>          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
     ↑
  scanPtr  
</code></pre><p>接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：</p><pre class="code-block"><code>            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
     ↑
  scanPtr  
</code></pre><p>B对象里所有指针都已被复制完，所以移动scanPtr：</p><pre class="code-block"><code>            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
         ↑
      scanPtr  
</code></pre><p>接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：</p><pre class="code-block"><code>                allocationPtr
                     ↓ 
+---+---+---+---+---+--------------------+
| A | B | C | E | F |                    |
+---+---+---+---+---+--------------------+
         ↑
      scanPtr  
</code></pre><p>然后复制G对象到To区</p><pre class="code-block"><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
         ↑
      scanPtr  
</code></pre><p>这样C对象内部的指针已经复制完成了，移动scanPtr：</p><pre class="code-block"><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
             ↑
          scanPtr  
</code></pre><p>逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：</p><pre class="code-block"><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
                     ↑
                  scanPtr  
</code></pre><p>扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：</p><pre class="code-block"><code>                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                     ↑
                  scanPtr  
</code></pre><p>完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：</p><pre class="code-block"><code>                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                             ↑
                           scanPtr  
</code></pre><p>此时scanPtr和allocationPtr重合，说明复制结束</p><p>可以对比一下From区和To区在复制完成后的结果：</p><pre class="code-block"><code>//From区
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
//To区
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
</code></pre><p>D对象没有被复制，它将被作为垃圾进行回收</p><h3>写屏障</h3><p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，</p><p>我们如何判断这个新生代的对象是否存活？</p><p>为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。</p><p>每当有老生代对象指向新生代对象的时候，我们就记录下来</p><h3>对象的晋升</h3><p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：</p><ol><li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li><li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li></ol><h2>老生代</h2><h3>老生代的特点</h3><p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p><h3>老生代的垃圾回收算法</h3><p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，</p><p>浪费一半空间不说，复制如此大块的内存消耗时间将 会相当长。所以Scavenge算法显然不适合。</p><p>V8在老生代中的垃圾回收策略采用 <strong>Mark-Sweep和Mark-Compact</strong> 相结合</p><h3>Mark-Sweep（标记清除）</h3><p>标记清除分为标记和清除两个阶段。</p><p>在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。</p><p>在清除阶段总，只清除没有被标记的对象。</p><p>由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p><p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。</p><p>如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p><h3>Mark-Compact（标记整理）</h3><p>标记整理正是为了解决标记清除所带来的内存碎片的问题。</p><p>标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。</p><p>在整理的过程中，将活着的 对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。</p><p>紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片。</p><h3>算法思路</h3><p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p><p>在标记阶段，所有堆上的活跃对象都会被标记。</p><p>每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。</p><p>这个位图需要占据一定的空 间（32位下为3.1%，64位为1.6%）。</p><p>另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：</p><ul><li>如果一个对象为白对象，它还没未被垃圾回收器发现</li><li>如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li><li>如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了</li></ul><h3>结合使用标记清除和标记整理</h3><p>Chrome V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">V8 内存浅析</a></li><li><a href="https://www.cnblogs.com/liangdaye/p/4654734.html" target="_blank" rel="noopener">浅谈Chrome V8引擎中的垃圾回收机制</a></li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>