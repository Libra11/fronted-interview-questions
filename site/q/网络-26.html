<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TCP 传输过程？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;传输过程&lt;/h2&gt;&lt;p&gt;TCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;建立连接&lt;/strong&gt;：TCP 通过三次握手建立连接，即" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="TCP 传输过程？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;传输过程&lt;/h2&gt;&lt;p&gt;TCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;建立连接&lt;/strong&gt;：TCP 通过三次握手建立连接，即客户端向服务器发送 SYN（同步）数据包，服务器接收到 SYN 后回应一个 SYN-ACK（同步-确认）数据包，客户端再" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/26" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>TCP 传输过程？</h1>
      <div class="subtitle">网络 · 网络</div>
      <div class="meta">创建：2023-03-06T15:20:32Z · 更新：2023-03-06T15:20:33Z</div>
    </div>
    <article class="content markdown-body"><h2>传输过程</h2><p>TCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下：</p><ul><li><strong>建立连接</strong>：TCP 通过三次握手建立连接，即客户端向服务器发送 SYN（同步）数据包，服务器接收到 SYN 后回应一个 SYN-ACK（同步-确认）数据包，客户端再回应一个 ACK（确认）数据包，连接建立成功。</li></ul><ul><li><strong>数据传输</strong>：数据在应用层被拆分成数据段，在传输层被拆分成数据包（也称为报文段），每个数据包包含源端口号、目标端口号、序列号、确认号、标志位等信息。发送方发送数据包后，等待接收方回复确认信息，如果未收到确认信息，则进行重传，直到接收方成功接收数据包。</li></ul><ul><li><strong>拥塞控制</strong>：当网络拥塞时，TCP 会采取措施来减少数据的传输速率，如减小窗口大小、降低拥塞窗口等。</li></ul><ul><li><strong>连接终止</strong>：TCP 通过四次挥手来关闭连接，即客户端发送一个 FIN（终止）数据包，服务器回应一个 ACK 数据包表示接收到 FIN，然后服务器再发送一个 FIN 数据包，客户端回应一个 ACK 数据包表示接收到 FIN，连接关闭成功。</li></ul><p>总的来说，<strong>TCP 通过三次握手建立连接、数据分段传输、拥塞控制和四次挥手关闭连接来保证数据的可靠传输</strong>。</p><h2>详细说一下 TCP 通过三次握手建立连接？</h2><p>TCP通过三次握手建立连接的过程如下：</p><ul><li><strong>第一次握手</strong>：客户端向服务端发送 <code>SYN</code>（同步）包，其中 <code>SYN=1，seq=x</code>，表示客户端希望与服务端建立连接，同时指定自己的初始序号为<code>x</code>。此时客户端处于 <code>SYN_SENT</code> 状态。</li></ul><ul><li><strong>第二次握手</strong>：服务端接收到 SYN 包后，向客户端发送 <code>SYN-ACK</code> 包，其中 SYN=1，<code>ACK=1，ack=x+1，seq=y</code>，表示服务端已经收到客户端的请求，同意建立连接，同时指定自己的初始序号为y，确认号为<code>x+1</code>。此时服务端处于 <code>SYN_RCVD</code> 状态。</li></ul><ul><li><strong>第三次握手</strong>：客户端收到 SYN-ACK 包后，向服务端发送 <code>ACK</code> 包，其中 <code>SYN=0，ACK=1，ack=y+1，seq=x+1</code>，表示客户端已经收到服务端的确认，连接建立成功。此时客户端处于 <code>ESTABLISHED</code> 状态，服务端也处于 <code>ESTABLISHED</code> 状态。</li></ul><p>这样就完成了三次握手建立连接的过程。在这个过程中，客户端和服务端都可以向对方发送数据。</p><p>需要注意的是，如果客户端在等待服务端的 SYN-ACK 包时超时或未收到响应，会重新发送 SYN 包，直到建立连接或达到最大重试次数。同时，在建立连接后，每个数据包都会在传输时带有序号和确认号，以保证数据的可靠传输。</p><h2>TCP数据分段传输的过程是怎么样的？</h2><ul><li>应用层将需要传输的数据分成适当大小的数据段，每个数据段称为一个TCP数据包。</li></ul><ul><li>TCP协议根据MSS（最大报文长度）将TCP数据包分割成更小的IP数据包，以适应底层网络的MTU（最大传输单元）。</li></ul><ul><li>在传输数据之前，TCP在每个数据包中添加一个包头（header），其中包含序列号（sequence number）和确认号</li></ul><p>（acknowledgment number）等信息。</p><ul><li>发送方将数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。</li></ul><ul><li>接收方收到数据包后，会对数据包进行确认，向发送方发送确认响应。如果接收方没有收到正确的数据包，它会要求发送方重发数据。</li></ul><ul><li>发送方收到确认响应后，会将下一个数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。</li></ul><ul><li>接收方根据收到的数据包的序列号和确认号，组装数据包，然后将数据包传递给上层应用程序。</li></ul><p>TCP数据分段传输可以提高网络的可靠性和稳定性，<strong>避免了数据包的丢失和重传，但是也会造成额外的网络开销。</strong></p><h2>TCP 是如何进行拥塞控制？</h2><p>TCP使用拥塞控制算法来避免网络中的拥塞现象，并在发生拥塞时减少发送数据的速率，从而避免网络拥塞的加剧。TCP的拥塞控制算法主要包括以下几个方面：</p><ul><li><strong>慢启动（Slow Start）</strong>：在TCP连接刚建立时，发送方限制了自己的初始发送窗口大小，从而避免发送过多的数据导致网络拥塞。发送方以指数级别的方式增加其发送窗口大小，直到达到一个阈值，然后就会进入拥塞避免状态。</li></ul><ul><li><strong>拥塞避免（Congestion Avoidance）</strong>：在拥塞避免状态下，TCP发送方每经过一轮的传输，就将其发送窗口大小增加一个MSS（最大报文段长度）的值。这样可以逐渐增加发送窗口大小，从而提高数据传输速率。</li></ul><p><strong>拥塞检测（Congestion Detection）</strong>：当TCP发送方收到一个超时重传的确认消息时，它就认为网络中出现了拥塞，并将其发送窗口大小减半，然后重新进入慢启动状态。</p><ul><li><strong>拥塞避免（Congestion Avoidance）</strong>：当TCP发送方收到一个失序的确认消息时，它就知道它发送的某些数据包在网络中已经丢失了，此时就不必等到超时重传定时器时间到期，而是立即重传那些丢失的数据包。</li></ul><ul><li><strong>快速恢复（Fast Recovery）</strong>：在快速重传后，TCP发送方将进入快速恢复状态，其中发送方的发送窗口大小将设置为丢失数据包的数量加上MSS的值，从而避免了发送窗口大小的降低和慢启动状态的重新启动。</li></ul><h2>四次挥手关闭连接流程如何？</h2><p>TCP 通过四次挥手来关闭连接，具体过程如下：</p><ul><li>客户端向服务端发送 FIN 报文，表示客户端不再发送数据。</li></ul><ul><li>服务端收到 FIN 报文后，向客户端发送 ACK 报文，表示收到了客户端的 FIN 报文。</li></ul><ul><li>服务端向客户端发送 FIN 报文，表示服务端不再发送数据。</li></ul><ul><li>客户端收到 FIN 报文后，向服务端发送 ACK 报文，表示收到了服务端的 FIN 报文。</li></ul><p>图示如下：</p><pre class="code-block"><code>客户端                服务端
|                      |
|  FIN(seq=x)          |
|---------------------&gt;|
|  ACK(seq=x+1,ack=y)  |
|&lt;---------------------|
|                      |
|  FIN(seq=y)          |
|&lt;---------------------|
|  ACK(seq=y+1,ack=x+1)|
|---------------------&gt;|
</code></pre><p>其中，<code>seq</code> 表示序号，<code>ack</code> 表示确认号。第一次握手中，客户端发送的序号 seq=x，表示客户端的数据流的第一个字节的序号。第二次握手中，服务端发送的确认号 ack=y，表示服务端期望下一个收到的字节的序号是 y。第三次握手中，服务端发送的序号 seq=y，表示服务端的数据流的第一个字节的序号。第四次握手中，客户端发送的确认号 ack=x+1，表示客户端期望下一个收到的字节的序号是 x+1。注意，在第四次握手中，客户端发送 ACK 报文后，不再发送数据，但服务端可能还有数据需要发送，因此服务端需要先发送 FIN 报文。</p><p>四次挥手的过程中，最后一个 ACK 报文可能会丢失，因此需要等待一段时间后才能确认连接已经关闭。这个等待时间称为 <code>TIME_WAIT</code> 状态，一般为 <code>2MSL</code>（Maximum Segment Lifetime，最长报文寿命）时间，即一个报文在网络中最长的生命周期，通常为 2 分钟。</p><p>值得注意的是，TCP 的四次挥手过程是可靠的，可以确保数据可靠传输。但由于四次挥手需要消耗额外的时间和网络资源，因此在某些情况下，<strong>可以使用 TCP 的强制断开连接方式（RST），通过发送一个 RST 报文来立即中断连接</strong>。但这种方式可能会导致数据的丢失和损坏，因此应该谨慎使用。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>