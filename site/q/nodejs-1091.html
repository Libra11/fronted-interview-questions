<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>node 里面 stream 是什么, 有啥应用场景【热度: 495】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：node stream&lt;/p&gt;&lt;h3&gt;一、stream 的概念与应用场景&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;概念引入与文件读取对比&lt;/strong&gt;：文章以一个简单的 HTTP 服务读取文件并返回响应的示例引入。起初，使用&lt;c" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="node 里面 stream 是什么, 有啥应用场景【热度: 495】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：node stream&lt;/p&gt;&lt;h3&gt;一、stream 的概念与应用场景&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;概念引入与文件读取对比&lt;/strong&gt;：文章以一个简单的 HTTP 服务读取文件并返回响应的示例引入。起初，使用&lt;code&gt;fs.readFileSync&lt;/code&gt;读取小文件并返回响应，这种方式在文件较小时可行。但当文件增大到几百 " />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/1091" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>node 里面 stream 是什么, 有啥应用场景【热度: 495】</h1>
      <div class="subtitle">Nodejs · Nodejs</div>
      <div class="meta">创建：2025-01-11T16:59:23Z · 更新：2025-01-11T16:59:24Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：node stream</p><h3>一、stream 的概念与应用场景</h3><ol><li><strong>概念引入与文件读取对比</strong>：文章以一个简单的 HTTP 服务读取文件并返回响应的示例引入。起初，使用<code>fs.readFileSync</code>读取小文件并返回响应，这种方式在文件较小时可行。但当文件增大到几百 M 时，全部读取完再返回会导致长时间等待，此时便引出了 stream 的概念。通过<code>fs.createReadStream</code>创建文件读取流，并使用<code>pipe</code>方法将其连接到响应流，实现了流式返回，解决了大文件读取的效率问题。</li><li><strong>HTTP 传输中的流</strong>：在 HTTP 传输大文件时，有两种常见的确定文件下载结束的方式。一种是在<code>header</code>里带上<code>Content-Length</code>，浏览器下载到指定长度即结束；另一种是设置<code>transfer-encoding:chunked</code>，服务器以不固定长度分块返回内容，当返回一个空块时代表传输结束。这种分块传输的方式，使得服务器可以在不知道文件总长度的情况下，持续向客户端发送数据，提高了传输的灵活性和效率。</li><li><strong>Shell 命令与 Node 脚本中的流</strong>：在 Shell 命令中，<code>ls | grep pack</code>展示了<code>ls</code>命令的输出流作为<code>grep</code>命令的输入流的应用。同时，Node 脚本也能接收 Shell 命令的输出流作为输入，如<code>ls | grep pack | node src/read.mjs</code>，其中<code>process.stdin</code>作为输入流，通过监听<code>readable</code>事件并使用<code>read</code>方法读取数据，体现了流在不同命令和程序间的传递和交互。</li></ol><h3>二、四种底层 stream 类型</h3><ol><li><strong>Readable（可读流）</strong></li></ol><ul><li><strong>实现方式与示例</strong>：可读流需要实现<code>_read</code>方法，通过<code>push</code>方法返回具体的数据，当<code>push(null)</code>时，表示流结束。文章给出了多种创建可读流的方式，包括直接创建实例、通过继承<code>Readable</code>类创建，以及结合生成器创建。例如，通过直接创建实例的方式如下：</li></ul><pre class="code-block"><code class="language-javascript">import { Readable } from &quot;node:stream&quot;;
const readableStream = new Readable();
readableStream._read = function () {
  this.push(&quot;阿门阿前一棵葡萄树，&quot;);
  this.push(&quot;阿东阿东绿的刚发芽，&quot;);
  this.push(&quot;阿东背着那重重的的壳呀，&quot;);
  this.push(&quot;一步一步地往上爬。&quot;);
  this.push(null);
};
readableStream.on(&quot;data&quot;, (data) =&gt; {
  console.log(data.toString());
});
readableStream.on(&quot;end&quot;, () =&gt; {
  console.log(&quot;done&quot;);
});
</code></pre><ul><li><strong>与其他API的关联</strong>：文件读取流<code>fs.createReadStream</code>是基于<code>Readable</code>封装的，<code>http</code>服务的<code>request</code>对象也是<code>Readable</code>的实例。这意味着在处理HTTP请求时，可以像操作普通可读流一样读取请求数据。</li></ul><ol><li><strong>Writable（可写流）</strong></li></ol><ul><li><strong>实现方式与特点</strong>：可写流要实现<code>_write</code>方法，用于接收写入的内容。其特点是可以通过控制<code>next</code>方法的调用时机，来控制消费数据的频率。例如，以下代码实现了一个简单的可写流，每 1 秒处理一次写入的数据：</li></ul><pre class="code-block"><code class="language-javascript">import { Writable } from &quot;node:stream&quot;;
class WritableDong extends Writable {
  constructor(iterator) {
    super();
    this.iterator = iterator;
  }
  _write(data, enc, next) {
    console.log(data.toString());
    setTimeout(() =&gt; {
      next();
    }, 1000);
  }
}
function createWriteStream() {
  return new WritableDong();
}
const writeStream = createWriteStream();
writeStream.on(&quot;finish&quot;, () =&gt; console.log(&quot;done&quot;));
writeStream.write(&quot;阿门阿前一棵葡萄树，&quot;);
writeStream.write(&quot;阿东阿东绿的刚发芽，&quot;);
writeStream.write(&quot;阿东背着那重重的的壳呀，&quot;);
writeStream.write(&quot;一步一步地往上爬。&quot;);
writeStream.end();
</code></pre><ul><li><strong>与其他API的关联</strong>：<code>fs.createWriteStream</code>是<code>Writable</code>的常见封装应用，<code>http</code>服务的<code>response</code>对象也是<code>Writable</code>实例，这使得在处理HTTP响应时，可以方便地向客户端写入数据。</li></ul><ol><li><strong>Duplex（双工流）</strong></li></ol><ul><li><strong>实现方式与功能</strong>：双工流需要同时实现<code>_read</code>和<code>_write</code>方法，具备可读可写的功能。文章通过一个示例展示了双工流的实现：</li></ul><pre class="code-block"><code class="language-javascript">import { Duplex } from &quot;node:stream&quot;;
class DuplexStream extends Duplex {
  _read() {
    this.push(&quot;阿门阿前一棵葡萄树，&quot;);
    this.push(&quot;阿东阿东绿的刚发芽，&quot;);
    this.push(&quot;阿东背着那重重的的壳呀，&quot;);
    this.push(&quot;一步一步地往上爬。&quot;);
    this.push(null);
  }
  _write(data, enc, next) {
    console.log(data.toString());
    setTimeout(() =&gt; {
      next();
    }, 1000);
  }
}
const duplexStream = new DuplexStream();
duplexStream.on(&quot;data&quot;, (data) =&gt; {
  console.log(data.toString());
});
duplexStream.on(&quot;end&quot;, (data) =&gt; {
  console.log(&quot;read done&quot;);
});
duplexStream.write(&quot;阿门阿前一棵葡萄树，&quot;);
duplexStream.write(&quot;阿东阿东绿的刚发芽，&quot;);
duplexStream.write(&quot;阿东背着那重重的的壳呀，&quot;);
duplexStream.write(&quot;一步一步地往上爬。&quot;);
duplexStream.end();
duplexStream.on(&quot;finish&quot;, (data) =&gt; {
  console.log(&quot;write done&quot;);
});
</code></pre><ul><li><strong>实际应用</strong>：TCP协议中的<code>socket</code>是<code>Duplex</code>的典型实现，通过<code>net</code>模块创建的TCP服务端和客户端，可以实现双向通信，其中<code>write</code>方法用于发送数据，<code>data</code>和<code>end</code>事件用于接收和处理数据。</li></ul><ol><li><strong>Transform（转换流）</strong></li></ol><ul><li><strong>实现方式与功能</strong>：转换流继承自<code>Duplex</code>，需要实现<code>_transform</code>方法，对写入的内容进行转换后提供给消费者读取。例如，以下代码实现了一个将输入内容反转的转换流：</li></ul><pre class="code-block"><code class="language-javascript">import { Transform } from &quot;node:stream&quot;;
class ReverseStream extends Transform {
  _transform(buf, enc, next) {
    const res = buf.toString().split(&quot;&quot;).reverse().join(&quot;&quot;);
    this.push(res);
    next();
  }
}
var transformStream = new ReverseStream();
transformStream.on(&quot;data&quot;, (data) =&gt; console.log(data.toString()));
transformStream.on(&quot;end&quot;, (data) =&gt; console.log(&quot;read done&quot;));
transformStream.write(&quot;阿门阿前一棵葡萄树&quot;);
transformStream.write(&quot;阿东阿东绿的刚发芽&quot;);
transformStream.write(&quot;阿东背着那重重的的壳呀&quot;);
transformStream.write(&quot;一步一步地往上爬&quot;);
transformStream.end();
transformStream.on(&quot;finish&quot;, (data) =&gt; console.log(&quot;write done&quot;));
</code></pre><ul><li><strong>实际应用</strong>：<code>zlib</code>模块中的<code>createGzip</code>是转换流的重要应用，可用于文件的压缩。通过<code>source.pipe(gzip).pipe(destination)</code>，可以将文件读取流经过<code>gzip</code>转换流后，传输到文件写入流，实现文件的压缩功能，也可以使用<code>pipeline</code> API简化操作。</li></ul><h3>三、总结</h3><p>Stream 是 Node.js 中非常重要且常用的 API，在文件读写、网络通信等场景中发挥着关键作用。文章详细介绍了四种底层 stream 类型：<code>Readable</code>通过实现<code>_read</code>方法和<code>push</code>操作提供数据；<code>Writable</code>通过实现<code>_write</code>方法和<code>next</code>操作消费数据；<code>Duplex</code>同时具备可读可写功能；<code>Transform</code>在<code>Duplex</code>基础上对写入内容进行转换。在面试中，不仅要了解这四种类型的定义和实现方式，还需能够举例说明常见 API 所属的 stream 类型，如<code>fs.createReadStream</code>是<code>Readable</code>的实现，<code>fs.createWriteStream</code>是<code>Writable</code>的实现等。掌握 stream 的知识，对于理解和开发高效的 Node.js 应用程序至关重要。</p><h3>参考文档</h3><p>https://juejin.cn/post/7449185434615365682</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>