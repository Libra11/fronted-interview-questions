<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] Hooks 有哪些？【热度: 2,594】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h3&gt;react 16.8 hooks&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;useState&lt;/li&gt;&lt;li&gt;useEffect&lt;/li&gt;&lt;li&gt;useContext&lt;/li&gt;&lt;li&gt;useReducer&lt;/li&gt;&lt;li&gt;useMemo&lt;/li&gt;&lt;li&gt;useCallback&lt;/li&gt;&lt;l" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] Hooks 有哪些？【热度: 2,594】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h3&gt;react 16.8 hooks&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;useState&lt;/li&gt;&lt;li&gt;useEffect&lt;/li&gt;&lt;li&gt;useContext&lt;/li&gt;&lt;li&gt;useReducer&lt;/li&gt;&lt;li&gt;useMemo&lt;/li&gt;&lt;li&gt;useCallback&lt;/li&gt;&lt;li&gt;useRef&lt;/li&gt;&lt;li&gt;useImperativeHandle&lt;/li&gt;&lt;li&gt;useLayoutEffect" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/302" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] Hooks 有哪些？【热度: 2,594】</h1>
      <div class="subtitle">美团 · web框架 · 美团</div>
      <div class="meta">创建：2023-04-23T14:00:05Z · 更新：2023-10-02T03:40:53Z</div>
    </div>
    <article class="content markdown-body"><h3>react 16.8 hooks</h3><ul><li>useState</li><li>useEffect</li><li>useContext</li><li>useReducer</li><li>useMemo</li><li>useCallback</li><li>useRef</li><li>useImperativeHandle</li><li>useLayoutEffect</li><li>useDebugValue</li></ul><h3>React v18中的hooks</h3><ul><li>useSyncExternalStore</li><li>useTransition</li><li>useDeferredValue</li><li>useInsertionEffect</li><li>useId</li></ul><h3>简单介绍一下 react 18 新增的 hooks</h3><h3>useSyncExternalStore</h3><p><code>useSyncExternalStore</code>:是一个推荐用于<strong>读取和订阅外部数据源</strong>的 <code>hook</code>，其方式与选择性的 <code>hydration</code> 和时间切片等并发渲染功能兼容</p><pre class="code-block"><code class="language-javascript">const state = useSyncExternalStore(
    subscribe,
    getSnapshot[, getServerSnapshot]
)

</code></pre><ul><li><code>subscribe</code>: 订阅函数，用于注册一个回调函数，<strong>当存储值发生更改时被调用</strong>。此外， <code>useSyncExternalStore</code> 会通过带有记忆性的 <code>getSnapshot</code> 来判别数据是否发生变化，如果发生变化，那么会<strong>强制更新数据</strong>。</li><li><code>getSnapshot</code>: 返回当前存储值的函数。必须返回缓存的值。如果 <code>getSnapshot</code> 连续多次调用，则必须返回相同的确切值，除非中间有存储值更新。</li><li><code>getServerSnapshot</code>：返回服务端(hydration模式下)渲染期间使用的存储值的函数</li></ul><hr /><h4>useTransition</h4><blockquote><code>useTransition</code>：</blockquote><blockquote></blockquote><blockquote>* 返回一个<strong>状态值</strong>表示过渡任务的等待状态，</blockquote><blockquote>* 以及一个启动该过渡任务的函数。</blockquote><p><strong>过渡任务</strong> 在一些场景中，如：<code>输入框</code>、<code>tab切换</code>、<code>按钮</code>等，这些任务需要视图上立刻做出响应，这些任务可以称之为<strong>立即更新的任务</strong></p><p>但有的时候，更新任务并不是那么紧急，或者来说要去请求数据等，导致新的状态不能立马更新，需要用一个<code>loading...</code>的等待状态，这类任务就是过度任务</p><pre class="code-block"><code class="language-javascript">const [isPending, startTransition] = useTransition();

</code></pre><ul><li><code>isPending</code>：<strong>过渡状态的标志</strong>，为<code>true</code>时是等待状态</li><li><code>startTransition</code>：可以<strong>将里面的任务变成过渡任务</strong></li></ul><hr /><h4>useDeferredValue</h4><blockquote><code>useDeferredValue</code>：接受一个值，并返回该值的新副本，该副本将<strong>推迟</strong>到更紧急地更新之后。</blockquote><p>如果当前渲染是一个紧急更新的结果，比如用户输入，<code>React</code> 将<strong>返回之前的值</strong>，然后<strong>在紧急渲染完成后渲染新的值</strong>。</p><p>也就是说<code>useDeferredValue</code>可以让状态滞后派生。</p><pre class="code-block"><code class="language-javascript">const deferredValue = useDeferredValue(value);

</code></pre><ul><li><code>value</code>：可变的值，如<code>useState</code>创建的值</li><li><code>deferredValue</code>: 延时状态</li></ul><blockquote><strong>useTransition和useDeferredValue做个对比</strong></blockquote><blockquote></blockquote><blockquote>* 相同点：<code>useDeferredValue</code> 和 <code>useTransition</code> 一样，都是<strong>过渡更新任务</strong></blockquote><blockquote>* 不同点：<code>useTransition</code> 给的是一个<strong>状态</strong>，而<code>useDeferredValue</code>给的是一个<strong>值</strong></blockquote><hr /><h4>useInsertionEffect</h4><p><code>useInsertionEffect</code>：与 <code>useLayoutEffect</code> 一样，但它在所有 DOM 突变之前<strong>同步触发</strong></p><p>在执行顺序上 <code>useInsertionEffect</code> > <code>useLayoutEffect</code> > <code>useEffect</code></p><blockquote><code>seInsertionEffect</code> 应仅限于 <code>css-in-js</code> 库作者使用。  </blockquote><blockquote>优先考虑使用 <code>useEffect</code> 或 <code>useLayoutEffect</code> 来替代。</blockquote><hr /><h4>useId</h4><p><code>useId</code> ： 是一个<strong>用于生成横跨服务端和客户端的稳定的唯一 ID</strong> 的同时避免<code>hydration</code>不匹配的 hook。</p><hr /><h3>参考文档</h3><ul><li>https://juejin.cn/post/7118937685653192735</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>