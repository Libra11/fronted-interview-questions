<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>介绍一下 TypeScript 类型兼容——逆变、协变、双向协变和不变 这四个概念【热度: 30】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：TS 类型兼容&lt;/p&gt;&lt;p&gt;TypeScript 中的类型系统允许类型之间存在不同的兼容性关系，这在处理复杂的类型结构时非常重要，尤其是涉及到函数类型和类结构的相互作用。以下是对逆变、协变、双向协变和不变这四个概念的解释：&lt;/p&gt;&lt;" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="介绍一下 TypeScript 类型兼容——逆变、协变、双向协变和不变 这四个概念【热度: 30】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：TS 类型兼容&lt;/p&gt;&lt;p&gt;TypeScript 中的类型系统允许类型之间存在不同的兼容性关系，这在处理复杂的类型结构时非常重要，尤其是涉及到函数类型和类结构的相互作用。以下是对逆变、协变、双向协变和不变这四个概念的解释：&lt;/p&gt;&lt;h3&gt;协变（Covariance）&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：如果 &lt;code&gt;A" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/845" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>介绍一下 TypeScript 类型兼容——逆变、协变、双向协变和不变 这四个概念【热度: 30】</h1>
      <div class="subtitle">TypeScript · TypeScript</div>
      <div class="meta">创建：2024-08-25T03:26:02Z · 更新：2025-02-03T07:34:41Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：TS 类型兼容</p><p>TypeScript 中的类型系统允许类型之间存在不同的兼容性关系，这在处理复杂的类型结构时非常重要，尤其是涉及到函数类型和类结构的相互作用。以下是对逆变、协变、双向协变和不变这四个概念的解释：</p><h3>协变（Covariance）</h3><ul><li><strong>定义</strong>：如果 <code>A</code> 类型是 <code>B</code> 类型的子类型，则由 <code>A</code> 构成的类型 <code>T&lt;A&gt;</code> 也是由 <code>B</code> 构成的类型 <code>T&lt;B&gt;</code> 的子类型。</li><li><strong>应用场景</strong>：在 TypeScript 中，数组类型是协变的。这意味着如果我们有类型 <code>string extends object</code>，那么 <code>string[] extends object[]</code> 也成立。</li><li><strong>函数返回值</strong>：在函数类型中，返回值类型是协变的，意味着函数的返回类型可以是其声明的返回类型的子类型。</li></ul><p><strong>代码示例</strong>：</p><p>数组的协变是最常见的例子：</p><pre class="code-block"><code class="language-typescript">class Animal {}
class Dog extends Animal {}

// 协变：Dog是Animal的子类，因此Dog[]也可以赋值给Animal[]
let dogs: Dog[] = [new Dog(), new Dog()];
let animals: Animal[] = dogs; // 协变
</code></pre><p>函数返回值的协变：</p><pre class="code-block"><code class="language-typescript">function getAnimal(): Animal {
  return new Animal();
}
function getDog(): Dog {
  return new Dog();
}

// 协变：getDog的返回类型是getAnimal返回类型的子类型
let animalFunction: () =&gt; Animal = getDog; // 协变
</code></pre><h3>逆变（Contravariance）</h3><ul><li><strong>定义</strong>：在特定情况下，如果 <code>A</code> 类型是 <code>B</code> 类型的子类型，则由 <code>B</code> 构成的类型 <code>T&lt;B&gt;</code> 也是由 <code>A</code> 构成的类型 <code>T&lt;A&gt;</code> 的子类型。</li><li><strong>应用场景</strong>：主要体现在函数参数中。如果函数 <code>f</code> 的参数类型是 <code>B</code>，那么一个参数类型为 <code>A</code> 的函数可以分配给 <code>f</code>，前提是 <code>A</code> 是 <code>B</code> 的超类型。这意味着函数可以接受更泛化的参数类型。</li><li><strong>函数参数</strong>：在 TypeScript 的严格模式下，函数参数是双向协变的（见下），但在某些上下文中可以被视为逆变。</li></ul><p><strong>代码示例</strong></p><p>在 TypeScript 中，函数参数在默认情况下是双向协变的，但我们可以使用逆变的方式理解它们在特殊情况下的行为，比如在启用 <code>--strictFunctionTypes</code> 标志后，函数参数表现出逆变：</p><pre class="code-block"><code class="language-typescript">class Parent {}
class Child extends Parent {}

// 逆变：参数具有逆变的特性
let fn1: (param: Parent) =&gt; void = (child: Child) =&gt; {};
</code></pre><h3>双向协变（Bivariance）</h3><ul><li><strong>定义</strong>：如果类型 <code>A</code> 可以赋值给类型 <code>B</code>，或者类型 <code>B</code> 可以赋值给类型 <code>A</code>，则类型 <code>A</code> 与 <code>B</code> 是双向协变的。</li><li><strong>应用场景</strong>：TypeScript 中函数参数的默认行为。意味着如果有两个函数，其参数类型分别是彼此的父类型或子类型，这两个函数类型被认为是兼容的。</li><li><strong>注意事项</strong>：这种设计是出于实用和方便考虑，但可能会导致类型系统的一些不直观行为，特别是在函数参数类型检查上。</li></ul><p><strong>代码示例</strong></p><p>默认情况下，TypeScript 中的函数参数是双向协变的：</p><pre class="code-block"><code class="language-typescript">function fnA(param: Animal) {}
function fnD(param: Dog) {}

// 双向协变：尽管参数类型不完全相同，但两个函数类型在TS中是兼容的
let fn: (param: Dog) =&gt; void = fnA; // 双向协变允许这种赋值
fn = fnD;
</code></pre><h3>不变（Invariance）</h3><ul><li><strong>定义</strong>：类型 <code>T&lt;A&gt;</code> 仅与类型 <code>T&lt;B&gt;</code> 兼容，如果且仅如果 <code>A</code> 与 <code>B</code> 完全相同。</li><li><strong>应用场景</strong>：当我们处理类的实例类型时，经常会出现不变性。例如，如果有一个以 <code>T</code> 为泛型参数的类 <code>Container&lt;T&gt;</code>，则 <code>Container&lt;string&gt;</code> 与 <code>Container&lt;object&gt;</code> 将不兼容，除非它们具有完全相同的类型。</li><li><strong>类和接口成员</strong>：在 TypeScript 中，类和接口的成员默认是不变的。这意味着在赋值兼容性方面，类和接口的成员类型必须完全相同。</li></ul><p><strong>代码示例</strong></p><p>对于类的实例类型的兼容性，体现为不变性：</p><pre class="code-block"><code class="language-typescript">interface IContainer&lt;T&gt; {
  value: T;
}

let stringContainer: IContainer&lt;string&gt; = { value: &quot;Hello, World!&quot; };
let objectContainer: IContainer&lt;object&gt; = { value: { message: &quot;Hello, World!&quot; } };

// 不变：即使string是object的子类型，以下赋值仍然是不允许的。
// stringContainer = objectContainer; // 错误！
// objectContainer = stringContainer; // 错误！
</code></pre><hr /><p>这些类型兼容性的概念是理解和使用 TypeScript 高级类型系统的基础，尤其是在设计通用库或进行复杂类型转换时。</p><h2>Comments / Answers</h2><hr /><p><strong>BruceYuj</strong> at 2025-02-03T07:34:40Z</p><p>关于不变的部分写错啦。</p><ol><li>可以结合函数参数的逆变+返回值的协变来表示不变 <code>type InvariantFunc&lt;T&gt; = (arg: T) =&gt; T</code></li><li>或者使用 TS 4.7 新增的 in/out 关键字</li></ol><pre class="code-block"><code class="language-typescript">interface State&lt;in out T&gt; {
 get: () =&gt; T,
set: (arg: T) =&gt; void
}
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>