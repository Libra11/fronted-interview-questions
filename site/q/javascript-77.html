<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>虚拟 dom 原理是啥，手写一个简单的虚拟 dom 实现？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;vdom 概念&lt;/h2&gt;&lt;p&gt;用JS模拟DOM结构。&lt;/p&gt;&lt;p&gt;DOM变化的对比，放在JS层来做。&lt;/p&gt;&lt;p&gt;提升重绘性能。&lt;/p&gt;&lt;p&gt;比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="虚拟 dom 原理是啥，手写一个简单的虚拟 dom 实现？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;vdom 概念&lt;/h2&gt;&lt;p&gt;用JS模拟DOM结构。&lt;/p&gt;&lt;p&gt;DOM变化的对比，放在JS层来做。&lt;/p&gt;&lt;p&gt;提升重绘性能。&lt;/p&gt;&lt;p&gt;比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。这样做的成本会非常高。&lt;/p&gt;&lt;h2&gt;用JS模拟 dom&lt;/h2&gt;&lt;p&gt;例如下面的一个dom 结构：&lt;/p&gt;&lt;pre c" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/77" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>虚拟 dom 原理是啥，手写一个简单的虚拟 dom 实现？</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-11T08:54:21Z · 更新：2023-10-01T13:56:09Z</div>
    </div>
    <article class="content markdown-body"><h2>vdom 概念</h2><p>用JS模拟DOM结构。</p><p>DOM变化的对比，放在JS层来做。</p><p>提升重绘性能。</p><p>比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。这样做的成本会非常高。</p><h2>用JS模拟 dom</h2><p>例如下面的一个dom 结构：</p><pre class="code-block"><code class="language-html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li class=&quot;item&quot;&gt;item1&lt;/li&gt;
    &lt;li class=&quot;item&quot;&gt;item2&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>这样的dom 结构，可以模拟为下面的JS :</p><pre class="code-block"><code class="language-javascript">let dom = {
    tag: &#39;ul&#39;,
    attrs: {
        id: &#39;list&#39;
    },
    children: [
        {
            tag: &#39;li&#39;,
            attrs: {className: &#39;item&#39;},
            children: [&#39;item1&#39;]
        },
        {
            tag: &#39;li&#39;,
            attrs: {className: &#39;item&#39;},
            children: [&#39;item2&#39;]
        }
    ]
}
</code></pre><p>浏览器操作dom 是花销非常大的。执行JS花销要小非常多，所以这就是为什么虚拟dom 出现的一个根本原因。</p><h2>jquery实现virtual-dom</h2><h3>一个需求场景</h3><p>1、数据生成表格。 2、随便修改一个信息，表格也会跟着修改。</p><pre class="code-block"><code class="language-html">&lt;body&gt;
&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;br&gt;
&lt;button id=&quot;btn-change&quot;&gt;change&lt;/button&gt;
&lt;script&gt;
    let data = [
        {
            name: &#39;yanle&#39;,
            age: &#39;20&#39;,
            address: &#39;重庆&#39;
        },
        {
            name: &#39;yanle2&#39;,
            age: &#39;25&#39;,
            address: &#39;成都&#39;
        },
        {
            name: &#39;yanle3&#39;,
            age: &#39;27&#39;,
            address: &#39;深圳&#39;
        }
    ];

    // 渲染函数
    function render(data) {
        let $container = document.getElementById(&#39;container&#39;);
        $container.innerHTML = &#39;&#39;;

        let $table = document.createElement(&#39;table&#39;);
        $table.setAttribute(&#39;border&#39;, true);
        $table.insertAdjacentHTML(&#39;beforeEnd&#39;, `&lt;tr&gt;
                                    &lt;td&gt;name&lt;/td&gt;
                                    &lt;td&gt;age&lt;/td&gt;
                                    &lt;td&gt;address&lt;/td&gt;
                                    &lt;/tr&gt;`);

        data.forEach(function (item) {
            $table.insertAdjacentHTML(&#39;beforeEnd&#39;,
                `&lt;tr&gt;
                    &lt;td&gt;${item.name}&lt;/td&gt;
                    &lt;td&gt;${item.age}&lt;/td&gt;
                    &lt;td&gt;${item.address}&lt;/td&gt;
                &lt;/tr&gt;`
            )
        });

        $container.appendChild($table);
    }

    // 修改信息
    let button = document.getElementById(&#39;btn-change&#39;);
    button.addEventListener(&#39;click&#39;, function () {
        data[1].name = &#39;徐老毕&#39;;
        data[1].age = 30;
        data[1].address  = &#39;深圳&#39;;
        render(data);
    });
    render(data);
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>实际上上面的这段代码也是不符合预期的，因为每次使用render 方法，都会全部渲染整个table, 但是并未没有只渲染我们想要的第二行。</p><p><strong>遇到的问题</strong>：</p><p>DOM 操作是非常 "昂贵" 的， JS 运行效率高。虚拟dom 的核心就是diff算法，对比出不同的dom数据，定点渲染不同的数据。</p><h2>Comments / Answers</h2><hr /><p><strong>yanlele</strong> at 2023-10-01T13:56:08Z</p><p>补充文章： https://github.com/linwu-hi/code-interview/issues/90</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>