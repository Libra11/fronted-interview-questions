<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[React] 是如何处理组件更新和渲染的？【热度: 862】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React 组件更新、React 组件渲染&lt;/p&gt;&lt;p&gt;React 组件的更新和渲染遵循一个相对严格的生命周期，这个生命周期在 React 16 版本之后，也就是从引入 Fiber 架构开始，稍微有所变化。React 通过一系列的生" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[React] 是如何处理组件更新和渲染的？【热度: 862】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：React 组件更新、React 组件渲染&lt;/p&gt;&lt;p&gt;React 组件的更新和渲染遵循一个相对严格的生命周期，这个生命周期在 React 16 版本之后，也就是从引入 Fiber 架构开始，稍微有所变化。React 通过一系列的生命周期方法以及新引入的 Hooks API，对组件的更新进行管理，主要流程如下：&lt;/p&gt;&lt;h3&gt;类组件的生命周期方法包括" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/746" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[React] 是如何处理组件更新和渲染的？【热度: 862】</h1>
      <div class="subtitle">快手 · web框架 · 快手</div>
      <div class="meta">创建：2024-05-10T14:39:48Z · 更新：2024-05-10T14:39:48Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：React 组件更新、React 组件渲染</p><p>React 组件的更新和渲染遵循一个相对严格的生命周期，这个生命周期在 React 16 版本之后，也就是从引入 Fiber 架构开始，稍微有所变化。React 通过一系列的生命周期方法以及新引入的 Hooks API，对组件的更新进行管理，主要流程如下：</p><h3>类组件的生命周期方法包括：</h3><ol><li><strong>挂载(Mounting)</strong></li></ol><ul><li><code>constructor()</code>: 组件被创建时调用，初始化 state。</li><li><code>static getDerivedStateFromProps()</code>: 组件实例化后和接受新属性时将会调用。</li><li><code>render()</code>: 唯一必须实现的方法，返回元素描述。</li><li><code>componentDidMount()</code>: 组件挂载（插入 DOM 树中）之后调用。</li></ul><ol><li><strong>更新(Updating)</strong></li></ol><ul><li><code>static getDerivedStateFromProps()</code>: 在接收到新的 props 时调用。</li><li><code>shouldComponentUpdate()</code>: 在接收到新的 props 或者 state 时，决定是否进行渲染。</li><li><code>render()</code>: 重新渲染组件。</li><li><code>getSnapshotBeforeUpdate()</code>: 在最新的渲染输出提交到 DOM 前将会立即调用。</li><li><code>componentDidUpdate()</code>: 在组件更新后调用。</li></ul><ol><li><strong>卸载(Unmounting)</strong></li></ol><ul><li><code>componentWillUnmount()</code>: 在组件卸载及销毁之前直接调用。</li></ul><h3>React 16.3 之后的生命周期的变化</h3><p>React 团队增加了新的生命周期方法，并且准备弃用某些旧的生命周期方法（如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code> 等）。引入了如 <code>static getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 等新的生命周期方法。</p><h3>函数组件和 Hooks</h3><p>在 React 16.8 版本后，引入了 Hooks API，允许在不编写类的情况下使用 state 以及其他的 React 特性。对于函数组件，有几个常用的 Hooks：</p><ul><li><code>useState</code>: 在函数组件中添加 state。</li><li><code>useEffect</code>: 可以在组件中执行副作用操作（数据请求、订阅以及手动更改 React 组件中的 DOM 等）。</li><li><code>useContext</code>: 允许你访问 React 的 Context 对象。</li><li><code>useReducer</code>: 另一种在组件中管理 state 的方式，它用于复杂的 state 逻辑。</li><li>其他 Hooks（如 <code>useCallback</code>, <code>useMemo</code>, <code>useRef</code> 等）。</li></ul><h3>更新和渲染流程：</h3><ol><li>当组件的 state 或者 props 发生变化时，React 会将新的 props 和 state 比较之前的，根据比较结果决定是否进行更新。</li><li>如果 <code>shouldComponentUpdate</code>、<code>PureComponent</code> 或 React.memo 表示不需要更新，React 将不会进行更新。</li><li>如果需要更新，React 会调用 <code>render</code> 方法以及相关的生命周期方法或 Hooks，这个过程会创建一个虚拟 DOM 树。</li><li>React 之后会对比新的虚拟 DOM 树与上一次更新时的虚拟 DOM 树，通过 DOM diffing 算法判断在哪进行实际的 DOM 更新。</li><li>应用必要的 DOM 更新到实际的 DOM 树上，如果有必要，调用 <code>getSnapshotBeforeUpdate</code> 和 <code>componentDidUpdate</code> 方法。</li></ol><p>这个过程保持了 React 组件的高效和可预测性，同时提供了生命周期的方法和 Hooks，使开发者能够插入自定义行为或响应组件的生命周期事件。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>