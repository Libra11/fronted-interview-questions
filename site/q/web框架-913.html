<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>[Vue] 侦听器在什么情况下是需要清理副作用的【热度: 148】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：侦听器副作用&lt;/p&gt;&lt;p&gt;在 Vue 3 中，清理副作用主要指的是在一个响应式侦听器（例如：&lt;code&gt;watch&lt;/code&gt; 或 &lt;code&gt;watchEffect&lt;/code&gt;）中，当侦听的响应式状态（或侦听的回调函数）重新执" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="[Vue] 侦听器在什么情况下是需要清理副作用的【热度: 148】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：侦听器副作用&lt;/p&gt;&lt;p&gt;在 Vue 3 中，清理副作用主要指的是在一个响应式侦听器（例如：&lt;code&gt;watch&lt;/code&gt; 或 &lt;code&gt;watchEffect&lt;/code&gt;）中，当侦听的响应式状态（或侦听的回调函数）重新执行之前或组件销毁时，移除或停止之前创建的资源，以避免内存泄漏、性能问题或意外的行为。下面列举了一些需要清理副作用的典型情" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/913" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>[Vue] 侦听器在什么情况下是需要清理副作用的【热度: 148】</h1>
      <div class="subtitle">web框架 · web框架</div>
      <div class="meta">创建：2024-09-17T09:10:48Z · 更新：2024-09-17T09:10:49Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：侦听器副作用</p><p>在 Vue 3 中，清理副作用主要指的是在一个响应式侦听器（例如：<code>watch</code> 或 <code>watchEffect</code>）中，当侦听的响应式状态（或侦听的回调函数）重新执行之前或组件销毁时，移除或停止之前创建的资源，以避免内存泄漏、性能问题或意外的行为。下面列举了一些需要清理副作用的典型情况：</p><h3>1. <strong>使用定时器时</strong></h3><p>当你在侦听器的回调函数中设置了定时器（如使用<code>setInterval</code>或<code>setTimeout</code>），并且不希望这个定时器在回调函数下次执行时仍然活动，你就需要在回调函数下一次执行之前清理这个定时器。</p><pre class="code-block"><code class="language-javascript">watchEffect((onInvalidate) =&gt; {
  const timer = setInterval(() =&gt; {
    // 执行一些逻辑
  }, 1000);

  // 清理函数
  onInvalidate(() =&gt; {
    clearInterval(timer);
  });
});
</code></pre><h3>2. <strong>订阅外部或异步资源时</strong></h3><p>当你订阅了一些外部资源，如 WebSocket 连接、外部 API 的实时数据流、或是自定义事件监听器，如果这些资源在组件卸载后继续活动，可能会导致内存泄漏或其他意外行为。</p><pre class="code-block"><code class="language-javascript">watchEffect((onInvalidate) =&gt; {
  const ws = new WebSocket(&quot;ws://example.com/feed&quot;);

  ws.onmessage = (message) =&gt; {
    // 处理消息
  };

  // 侦听器清理函数
  onInvalidate(() =&gt; {
    ws.close();
  });
});
</code></pre><h3>3. <strong>响应式引用发生变化时</strong></h3><p>当你侦听的响应式引用（如 <code>ref</code> 或 <code>reactive</code> 对象）在回调函数生命周期中发生变化时，如果回调生产了外部副作用（比如修改了外部状态、操作了 DOM、设置了全局事件监听器等），你可能需要清理这些副作用，避免它们在重新计算或组件卸载时造成问题。</p><pre class="code-block"><code class="language-javascript">const user = ref(null);

watchEffect((onInvalidate) =&gt; {
  // 假设fetchUser返回一个取消订阅或清理资源的函数
  const unsubscribe = fetchUser(user.value, (newUser) =&gt; {
    user.value = newUser;
  });

  onInvalidate(() =&gt; {
    unsubscribe();
  });
});
</code></pre><h3>为什么要清理副作用</h3><p>清理副作用是为了防止不必要的资源占用和潜在的内存泄漏，尤其是在使用外部资源、设置定时器、或订阅数据时。Vue 提供的<code>onInvalidate</code>回调允许在侦听器重新运行之前或组件销毁时执行清理逻辑，确保应用资源被适当管理和释放。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>