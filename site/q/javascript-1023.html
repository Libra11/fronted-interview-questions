<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JS 浏览器事循环有哪些使用案例？【热度: 526】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：事件循环案例&lt;/p&gt;&lt;blockquote&gt;作者备注&lt;/blockquote&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;这个是一个很好的问题， 大多数人在面试过程中， 大多数都是问到的 - 什么是事件" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="JS 浏览器事循环有哪些使用案例？【热度: 526】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：事件循环案例&lt;/p&gt;&lt;blockquote&gt;作者备注&lt;/blockquote&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;这个是一个很好的问题， 大多数人在面试过程中， 大多数都是问到的 - 什么是事件循环&lt;/blockquote&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;blockquote&gt;但是真是事件循环" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/1023" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>JS 浏览器事循环有哪些使用案例？【热度: 526】</h1>
      <div class="subtitle">JavaScript · JavaScript · 腾讯</div>
      <div class="meta">创建：2024-10-26T06:50:34Z · 更新：2024-10-26T06:50:35Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：事件循环案例</p><blockquote>作者备注</blockquote><blockquote></blockquote><blockquote>这个是一个很好的问题， 大多数人在面试过程中， 大多数都是问到的 - 什么是事件循环</blockquote><blockquote></blockquote><blockquote>但是真是事件循环的场景可能大多数人不清楚， 所以也就是为了八股而八股。 这个问题很好的问到哪些场景下会使用到事件循环。 是属于原理考虑， 应用也要知道的场景</blockquote><p>JavaScript 的事件循环在实际开发中有很多使用案例，以下是一些常见的例子：</p><p><strong>一、异步操作处理</strong></p><ol><li>网络请求：</li></ol><ul><li>当进行 AJAX 请求时，浏览器不会阻塞等待响应，而是继续执行其他代码。一旦请求完成，相应的回调函数会被添加到任务队列中，等待事件循环处理。</li><li>例如，使用<code>XMLHttpRequest</code>或<code>fetch</code>进行网络请求：</li></ul><p>```javascript</p><p>function makeAjaxRequest(url) {</p><p>return new Promise((resolve, reject) => {</p><p>const xhr = new XMLHttpRequest();</p><p>xhr.open("GET", url);</p><p>xhr.onload = function () {</p><p>if (xhr.status === 200) {</p><p>resolve(xhr.responseText);</p><p>} else {</p><p>reject(new Error(xhr.statusText));</p><p>}</p><p>};</p><p>xhr.onerror = function () {</p><p>reject(new Error("Network error"));</p><p>};</p><p>xhr.send();</p><p>});</p><p>}</p><p>makeAjaxRequest("https://example.com/data")</p><p>.then((data) => {</p><p>console.log("Received data:", data);</p><p>})</p><p>.catch((error) => {</p><p>console.error("Error:", error);</p><p>});</p><p>```</p><ul><li>在这个例子中，网络请求是异步的，不会阻塞主线程。当请求完成后，对应的<code>then</code>或<code>catch</code>回调函数会被执行。</li></ul><ol><li>定时器：</li></ol><ul><li><code>setTimeout</code>和<code>setInterval</code>函数会在指定的时间后将回调函数添加到任务队列中。</li><li>例如：</li></ul><p>```javascript</p><p>console.log("Start");</p><p>setTimeout(() => {</p><p>console.log("Timeout after 1 second");</p><p>}, 1000);</p><p>console.log("End");</p><p>```</p><ul><li>输出结果为“Start”、“End”，然后在 1 秒后输出“Timeout after 1 second”。这表明<code>setTimeout</code>的回调函数是在主线程执行完其他代码后，由事件循环处理执行的。</li></ul><p><strong>二、用户交互响应</strong></p><ol><li>按钮点击事件：</li></ol><ul><li>当用户点击按钮时，会触发相应的点击事件处理程序。这些处理程序会被添加到任务队列中，等待事件循环处理。</li><li>例如：</li></ul><p>```html</p><p><button id="myButton">Click me</button></p><p><script></p><p>document.getElementById("myButton").addEventListener("click", function () {</p><p>console.log("Button clicked");</p><p>});</p><p></script></p><p>```</p><ul><li>当用户点击按钮时，“Button clicked”会被输出。这种方式确保了用户交互不会阻塞主线程，使得界面保持响应。</li></ul><ol><li>输入框实时验证：</li></ol><ul><li>可以使用事件循环来实现输入框的实时验证。当用户在输入框中输入内容时，触发<code>input</code>事件，相应的验证函数会被添加到任务队列中，进行异步验证。</li><li>例如：</li></ul><p>```html</p><p><input type="text" id="myInput" /></p><p><script></p><p>document.getElementById("myInput").addEventListener("input", function () {</p><p>const value = this.value;</p><p>setTimeout(() => {</p><p>if (value.length < 5) {</p><p>console.log("Input too short");</p><p>} else {</p><p>console.log("Input valid");</p><p>}</p><p>}, 500);</p><p>});</p><p></script></p><p>```</p><ul><li>在这个例子中，每次用户输入时，会在 500 毫秒后进行验证。如果输入长度小于 5，则输出“Input too short”；否则输出“Input valid”。</li></ul><p><strong>三、动画和界面更新</strong></p><ol><li>动画循环：</li></ol><ul><li>使用<code>requestAnimationFrame</code>函数可以创建一个动画循环，在每一帧更新动画状态并重新绘制界面。这个函数会在浏览器下一次重绘之前调用指定的回调函数，确保动画的流畅性。</li><li>例如：</li></ul><p>```javascript</p><p>function animate() {</p><p>// 更新动画状态</p><p>// 例如，移动一个元素的位置</p><p>element.style.left = parseInt(element.style.left) + 1 + 'px';</p><p>if (/<em> 动画未完成条件 </em>/) {</p><p>requestAnimationFrame(animate);</p><p>}</p><p>}</p><p>requestAnimationFrame(animate);</p><p>```</p><ul><li>在这个例子中，<code>animate</code>函数会在每一帧更新元素的位置，直到动画完成。<code>requestAnimationFrame</code>确保了动画在浏览器的最佳时机进行更新，避免了不必要的重绘和性能浪费。</li></ul><ol><li>界面更新：</li></ol><ul><li>在复杂的界面应用中，可以使用事件循环来异步更新界面，避免阻塞主线程。例如，当有大量数据需要渲染到界面上时，可以将渲染过程分成小块，每次在事件循环的空闲时间进行一部分渲染。</li><li>例如：</li></ul><p>```javascript</p><p>function updateUI(data) {</p><p>const chunkSize = 10;</p><p>let index = 0;</p><p>function renderChunk() {</p><p>for (let i = index; i < index + chunkSize && i < data.length; i++) {</p><p>// 渲染数据的一部分到界面上</p><p>const item = data[i];</p><p>const element = document.createElement("div");</p><p>element.textContent = item;</p><p>document.body.appendChild(element);</p><p>}</p><p>index += chunkSize;</p><p>if (index < data.length) {</p><p>requestIdleCallback(renderChunk);</p><p>}</p><p>}</p><p>requestIdleCallback(renderChunk);</p><p>}</p><p>const largeData = Array.from({ length: 1000 }, (_, i) => <code>Item ${i}</code>);</p><p>updateUI(largeData);</p><p>```</p><ul><li>在这个例子中，<code>updateUI</code>函数将大量数据分成小块进行渲染，每次在浏览器空闲时间（使用<code>requestIdleCallback</code>）进行一部分渲染，避免了长时间阻塞主线程，使得界面保持响应。</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>