<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>对象深拷贝的原理和代码实现【热度: 892】 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：对象什拷贝原理、避免循环引用和栈溢出&lt;/p&gt;&lt;p&gt;在 JavaScript 中，对象深拷贝指的是创建一个对象的副本，使得这个副本与原始对象不共享任何一个引用。这意味着，如果你修改了副本的属性，原始对象不会受到任何影响，反之亦然。&lt;/" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="对象深拷贝的原理和代码实现【热度: 892】" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：对象什拷贝原理、避免循环引用和栈溢出&lt;/p&gt;&lt;p&gt;在 JavaScript 中，对象深拷贝指的是创建一个对象的副本，使得这个副本与原始对象不共享任何一个引用。这意味着，如果你修改了副本的属性，原始对象不会受到任何影响，反之亦然。&lt;/p&gt;&lt;h3&gt;原理&lt;/h3&gt;&lt;p&gt;在实现深拷贝时，有几个关键的概念需要理解：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;值类型" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/716" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>对象深拷贝的原理和代码实现【热度: 892】</h1>
      <div class="subtitle">JavaScript · JavaScript · TOP100互联网</div>
      <div class="meta">创建：2024-04-20T06:06:42Z · 更新：2024-04-20T06:06:43Z</div>
    </div>
    <article class="content markdown-body"><p><strong>关键词</strong>：对象什拷贝原理、避免循环引用和栈溢出</p><p>在 JavaScript 中，对象深拷贝指的是创建一个对象的副本，使得这个副本与原始对象不共享任何一个引用。这意味着，如果你修改了副本的属性，原始对象不会受到任何影响，反之亦然。</p><h3>原理</h3><p>在实现深拷贝时，有几个关键的概念需要理解：</p><ol><li><strong>值类型与引用类型</strong>：值类型（如数字、字符串和布尔值）直接存储数据的值，而引用类型（如对象、数组等）存储的是对一个内存地址的引用。</li></ol><ol><li><strong>复制引用</strong>：如果你将一个对象赋值给一个新的变量，那么这个变量仅复制了对象的引用，而不是对象本身。因此，两个变量都指向同一个对象。</li></ol><ol><li><strong>深度克隆</strong>：深拷贝则需要递归地复制对象中的每个属性，确保每个属性都是独立的副本，而不共享引用。</li></ol><h3>实现</h3><p>实现对象的深拷贝有多种方式，以下是几种常见的实现方法：</p><h4>1. JSON 方法</h4><p>最简单的深拷贝方法之一是使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code>：</p><pre class="code-block"><code class="language-javascript">function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
</code></pre><p>但是，这种方法有局限性：</p><ul><li>它无法复制函数。</li><li>它无法复制循环引用。</li><li>它不会拷贝 <code>undefined</code>。</li><li>它无法处理特定属性（如 <code>Symbol</code> 属性、属性名为 <code>Symbol</code> 类型的属性等）。</li></ul><h4>2. 递归方法</h4><p>你可以编写一个递归函数来复制每个属性：</p><pre class="code-block"><code class="language-javascript">function deepClone(value) {
  if (typeof value !== &quot;object&quot; || value === null) {
    return value; // 返回原始值类型
  }

  let result = Array.isArray(value) ? [] : {};
  for (let key in value) {
    // 使用 hasOwnProperty 检查以避免原型链中的键
    if (value.hasOwnProperty(key)) {
      // 递归复制每个属性值
      result[key] = deepClone(value[key]);
    }
  }
  return result;
}
</code></pre><p>这种方法的优点是它可以处理循环引用的拷贝，并且能够处理函数以外的所有类型的值。但它仍然有局限性，比如它不会拷贝对象的原型链。</p><p><strong>补充进阶：避免循环引用和栈溢出的问题且支持拷贝原型链上的属性</strong></p><p>为了避免循环引用和栈溢出的问题，我们可以在递归函数中加入一个缓存（通常是对象或 Map），来存储已经被拷贝过的引用类型对象。这样，当遇到一个已经被拷贝的引用类型时，我们可以使用缓存中的数据而不是再次进行拷贝。</p><p>下面是实现该思想的深拷贝函数示例：</p><pre class="code-block"><code class="language-javascript">function deepClone(value, map = new WeakMap()) {
  if (typeof value !== &quot;object&quot; || value === null) {
    return value; // 返回基本数据类型的值
  }

  // 检查是否为 Date、RegExp、Function 或循环引用
  if (value instanceof Date || value instanceof RegExp) {
    return value; // Created with built-in constructors, directly returned
  }

  // 如果 map 中已存在，则返回之前拷贝的对象，避免循环引用
  if (map.has(value)) {
    return map.get(value);
  }

  let result;
  if (Array.isArray(value)) {
    result = [];
    map.set(value, result);
    for (let i = 0; i &lt; value.length; i++) {
      result[i] = deepClone(value[i], map); // 处理数组循环引用
    }
  } else {
    result = {};
    map.set(value, result);
    for (let key in value) {
      if (value.hasOwnProperty(key)) {
        result[key] = deepClone(value[key], map); // 递归复制每个属性
      }
    }
  }

  // 拷贝原型链上的属性
  // 根据需要可以取消以下注释
  // result.__proto__ = Object.getPrototypeOf(value);

  return result;
}
</code></pre><h4>3. 使用第三方库</h4><p>另一个选择是使用第三方库，如 Lodash，它提供了 <code>_.cloneDeep</code> 方法来实现深拷贝：</p><pre class="code-block"><code class="language-javascript">const _ = require(&quot;lodash&quot;);
const clone = _.cloneDeep(yourObject);
</code></pre><p>使用第三方库通常是最简单且最健壮的解决方案，因为它们已经考虑到了各种边缘情况，并包含了更高级的拷贝功能。</p><h3>注意</h3><p>无论选择哪种方法，都需要注意的是，深拷贝可能无法复制具有特定属性的对象，如：</p><ul><li>Function 对象</li><li>Map 和 Set 对象</li><li>React 组件</li><li>日期对象</li><li>正则表达式对象</li><li>以及一些其他通过构造函数创建的对象，可能会丢失它们的框架或库特定的属性或方法。</li></ul><p>在实现深拷贝时，需要根据实际情况调整和选择使用的方法。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>