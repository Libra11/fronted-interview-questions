<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>前端路由的实现原理 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。&lt;/p&gt;&lt;p&gt;前端路由的实现原理简单来说，就是在不跳转或者" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="前端路由的实现原理" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。&lt;/p&gt;&lt;p&gt;前端路由的实现原理简单来说，就是在不跳转或者刷新页面的前提下，为SPA应用中的每个视图匹配一个特殊的URL，之后的刷新、前进、后退等操作均通过这个特殊的URL实现。" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/269" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>前端路由的实现原理</h1>
      <div class="subtitle">腾讯 · web框架 · 腾讯</div>
      <div class="meta">创建：2023-04-09T06:18:33Z · 更新：2023-04-09T06:18:34Z</div>
    </div>
    <article class="content markdown-body"><p>在使用Vue、React等前端框架时，我们都会发现项目中只有一个HTML文件，并且在该HTML中都存在一个根标签，起到了类似于容器的作用。容器内部的内容就由我们后续编写的每个视图决定，页面的切换就是容器中视图的切换。</p><p>前端路由的实现原理简单来说，就是在不跳转或者刷新页面的前提下，为SPA应用中的每个视图匹配一个特殊的URL，之后的刷新、前进、后退等操作均通过这个特殊的URL实现。为实现上述要求，需要满足：</p><p>改变URL且不会向服务器发起请求；</p><p>可以监听到URL的变化，并渲染与之匹配的视图。</p><p>主要有Hash路由和History路由两种实现方式。下文对两者的基本原理进行简单介绍，并分别实现了一个简易的路由Demo。</p><h3>Hash路由</h3><p>原理就是通过键值对的形式保存路由及对应要执行的回调函数，当监听到页面hash发生改变时，根据最新的hash值调用注册好的回调函数，即改变页面。</p><h4>创建路由</h4><pre class="code-block"><code class="language-js">class Routers{
  constructor(){
    // 保存路由信息
    this.routes = {};
    this.currentUrl = &#39;&#39;;
    window.addEventListener(&#39;load&#39;, this.refresh, false);
    window.addEventListener(&#39;hashchange&#39;, this.refresh, false);
  }

  // 用于注册路由的函数
  route = (path, callback) =&gt; {
    this.routes[path] = callback || function(){};
  }

  // 监听事件的回调，负责当页面hash改变时执行对应hash值的回调函数
  refresh = () =&gt; {
    this.currentUrl = location.hash.slice(1) || &#39;/&#39;;
    this.routes[this.currentUrl]();
  }
}

window.Router = new Routers();
</code></pre><h4>注册路由</h4><p>使用route方法添加对应的路由及其回调函数即可。以下代码实现了一个根据不同hash改变页面颜色的路由，模拟了页面的切换，在实际的SPA应用中，对应的就是页面内容的变化了。</p><pre class="code-block"><code class="language-js">var content = document.querySelector(&#39;body&#39;);

function changeBgColor(color){
  content.style.background = color;
}

// 添加路由
Router.route(&#39;/&#39;, () =&gt; {
  changeBgColor(&#39;yellow&#39;);
});
Router.route(&#39;/red&#39;, () =&gt; {
  changeBgColor(&#39;red&#39;);
});
Router.route(&#39;/green&#39;, () =&gt; {
  changeBgColor(&#39;green&#39;);
});
Router.route(&#39;/blue&#39;, () =&gt; {
  changeBgColor(&#39;blue&#39;);
});
</code></pre><h3>History路由</h3><p>在H5之前，浏览器的history仅支持页面之前的跳转，包括前进和后退等功能。</p><p>在HTML5中，新增以下API：</p><pre class="code-block"><code class="language-js">history.pushState();			// 添加新状态到历史状态栈
history.replaceState();		// 用新状态代替当前状态
history.state;						// 获取当前状态对象
</code></pre><p>history.pushState()和history.replaceState()均接收三个参数：</p><ul><li>state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。</li><li>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。</li><li>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址</li></ul><p>由于history.pushState()和 history.replaceState()都具有在改变页面URL的同时，不刷新页面的能力，因此也可以用来实现前端路由。</p><h4>创建路由类</h4><pre class="code-block"><code class="language-js">class Routers{
  constructor(){
    this.routes = {};
    window.addEventListener(&#39;popstate&#39;, e =&gt; {
      const path = e.state &amp;&amp; e.state.path;
      this.routes[path] &amp;&amp; this.routes[path]();
    })
  }

  init(path){
    history.replaceState({path: path}, null, path);
    this.routes[path] &amp;&amp; this.routes[path]();
  }

  route(path, callback){
    this.routes[path] = callback || function(){};
  }

  go(path){
    history.pushState({path: path}, null, path);
    this.routes[path] &amp;&amp; this.routes[path]();
  }
}

window.Router = new Routers();
</code></pre><h4>注册路由</h4><pre class="code-block"><code class="language-js">function changeBgColor(color){
  content.style.background = color;
}

Router.route(location.pathname, () =&gt; {
  changeBgColor(&#39;yellow&#39;);
});
Router.route(&#39;/red&#39;, () =&gt; {
  changeBgColor(&#39;red&#39;);
});
Router.route(&#39;/green&#39;, () =&gt; {
  changeBgColor(&#39;green&#39;);
});
Router.route(&#39;/blue&#39;, () =&gt; {
  changeBgColor(&#39;blue&#39;);
});

const content = document.querySelector(&#39;body&#39;);
Router.init(location.pathname);
</code></pre><h4>触发事件</h4><p>在使用hash实现的路由中，我们通过hashchange事件来监听hash的变化，但是上述代码中history的改变本身不会触发任何事件，因此无法直接监听history的改变来改变页面。因此，对于不同的情况，我们选择不同的解决方案：</p><ul><li>点击浏览器的前进或者后退按钮：监听popstate事件，获取相应路径并执行回调函数</li><li>点击a标签：阻止其默认行为，获取其href属性，手动调用history.pushState()，并执行相应回调。</li></ul><pre class="code-block"><code class="language-js">const ul = document.querySelector(&#39;ul&#39;);

ul.addEventListener(&#39;click&#39;, e =&gt; {
  if(e.target.tagName === &#39;A&#39;){
    e.preventDefault();
    Router.go(e.target.getAttribute(&#39;href&#39;));
  }
})
</code></pre><h3>对比</h3><p>基于hash的路由：</p><p>缺点：</p><ul><li>看起来比较丑</li><li>会导致锚点功能失效</li></ul><p>优点：</p><ul><li>兼容性更好</li><li>无需服务器配合</li></ul></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>