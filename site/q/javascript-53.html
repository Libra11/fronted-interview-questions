<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>手写实现函数节流 - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;h2&gt;实现函数节流&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/beijiyang999/article/details/79836463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="手写实现函数节流" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;h2&gt;实现函数节流&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/beijiyang999/article/details/79836463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/beijiyang999/article/details/79836463&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;函数节流是什么&lt;/h" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/53" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>手写实现函数节流</h1>
      <div class="subtitle">JavaScript · JavaScript</div>
      <div class="meta">创建：2023-03-10T15:08:23Z · 更新：2023-03-10T15:08:24Z</div>
    </div>
    <article class="content markdown-body"><h2>实现函数节流</h2><p><a href="https://blog.csdn.net/beijiyang999/article/details/79836463" target="_blank" rel="noopener">https://blog.csdn.net/beijiyang999/article/details/79836463</a></p><h3>函数节流是什么</h3><p><strong>对于持续触发的事件，规定一个间隔时间（n秒），每隔一段只能执行一次。</strong></p><p>函数防抖（debounce）与本篇说的函数节流（throttle）相似又不同。</p><p>函数防抖一般是指对于<strong>在事件被触发n秒后再执行的回调，如果在这n秒内又重新被触发，则重新开始计时。</strong></p><p>二者都能防止函数过于频繁的调用。</p><p>区别在于，当事件持续被触发，如果触发时间间隔短于规定的等待时间（n秒），那么</p><ul><li>函数防抖的情况下，函数将一直推迟执行，造成不会被执行的效果；</li><li>函数节流的情况下，函数将每个 n 秒执行一次。</li></ul><h3>函数节流的实现</h3><p>函数节流的实现有不同的思路，可以通过<strong>时间戳实现</strong>，也可以通过<strong>定时器实现</strong>。</p><h3>时间戳</h3><h4>思路</h4><p>只要触发，就用 Date 获取现在的时间，与上一次的时间比较。</p><p>如果时间差大于了规定的等待时间，就可以执行一次；</p><p>目标函数执行以后，就更新 previous 值，确保它是“上一次”的时间。</p><p>否则就等下一次触发时继续比较。</p><h4>代码如下</h4><pre class="code-block"><code class="language-javascript">function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = +new Date();
        let context = this;
        if (now - previous &gt;= wait) {
            func.apply(context, arguments);
            previous = now; // 执行后更新 previous 值
        }
    }
}
container.onmousemove = throttle(doSomething, 1000);
</code></pre><h3>定时器</h3><h4>思路</h4><p>用定时器实现时间间隔。</p><p>当定时器不存在，说明可以执行函数，于是定义一个定时器来向任务队列注册目标函数</p><p>目标函数执行后设置保存定时器ID变量为空</p><p>当定时器已经被定义，说明已经在等待过程中。则等待下次触发事件时再进行查看。</p><h4>代码</h4><pre class="code-block"><code class="language-javascript">function throttle(func, wait) {
    let time, context;
    return function(){
        context = this;
        if(!time){
            time = setTimeout(function(){
                func.apply(context, arguments);
                time = null
            }, wait)
        }
    }
}
</code></pre><h3>效果差异</h3><p>一个周期内：</p><p>时间戳实现的：先执行目标函数，后等待规定的时间段；</p><p>计时器实现的：先等待够规定时间，再执行。 即停止触发后，若定时器已经在任务队列里注册了目标函数，它也会执行最后一次。</p><h3>优化：二者结合</h3><p>结合二者，实现一次触发，两次执行（先立即执行，结尾也有执行）</p><pre class="code-block"><code class="language-javascript">function throttle (func, wait) {
    let previous = 0;
    let context, args, time;
    return function(){
        let now = +new Date();
        context = this;
        args = arguments;
        if(now - previous &gt;= wait){ //当距上一次执行的间隔大于规定，可以直接执行
            func.apply(context, args);
            previous = now
        } else { // 否则继续等待，结尾执行一次
            if(time) clearTimeout(time);
            time = setTimeout(
                () =&gt; {
                        func.apply(context, args);
                        time = null
                      }
            , wait)
        }
    }
}
</code></pre><h4>问题</h4><p>已经实现了一次触发，两次执行，有头有尾的效果。</p><p>问题是，上一个周期的“尾”和下一个周期的“头”之间，失去了对时间间隔的控制。</p><h4>修复</h4><p>仔细查看，发现问题出在了 previous 的设置上。</p><p>仅仅在“可直接执行”的情况下更新了 previous 值，在通过计时器注册入任务队列后执行的情况下，忽略了 previous 的更新。</p><p>导致了 previous 的值不再是“上一次执行”时的时间，而是“上一次直接可执行情况下执行”的时间。</p><p>同时，引入变量 remaining 表示还需要等待的时间，来让尾部那一次的执行也符合时间间隔。</p><h4>完善后代码：</h4><pre class="code-block"><code class="language-javascript">function throttle(func, wait) {
    let previous = 0;
    let context, args, time, remaining;

    return function() {
        let now = +new Date();
        context = this;
        args = arguments;
        remaining = wait - (now - previous);    // 剩余的还需要等待的时间
        if (remaining &lt;= 0) {
            func.apply(context, args);
            previous = now // 重置“上一次执行”的时间
        } else {
            if (time) {
                clearTimeout(time);
            }
            time = setTimeout(() =&gt; {
                func.apply(context, args);
                time = null;
                previous = +new Date() // 重置“上一次执行”的时间
            }, remaining) //等待还需等待的时间
        }
    };
}
</code></pre><h4>更进一步的优化</h4><p>参考 underscore 与 mqyqingfeng ，实现是否启用第一次 / 尾部最后一次计时回调的执行。</p><p>设置 options 作为第三个参数，然后根据传的值判断到底哪种效果，约定:</p><ul><li>leading：false 表示禁用第一次执行</li><li>trailing: false 表示禁用停止触发的回调</li></ul><pre class="code-block"><code class="language-javascript">function throttle(func, wait, options) {
    let time, context, args, result;
    let previous = 0;
    if (!options) options = {};

    let later = function () {
        previous = options.leading === false ? 0 : new Date().getTime();
        time = null;
        func.apply(context, args);
        if (!time) context = args = null;
    };

    let throttled = function () {
        let now = new Date().getTime();
        if (!previous &amp;&amp; options.leading === false) previous = now;
        let remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining &lt;= 0 || remaining &gt; wait) {
            if (time) {
                clearTimeout(time);
                time = null;
            }
            previous = now;
            func.apply(context, args);
            if (!time) context = args = null;
        } else if (!time &amp;&amp; options.trailing !== false) {
            time = setTimeout(later, remaining);
        }
    };
    return throttled;
}
</code></pre><p>如果想添加一个取消功能：</p><pre class="code-block"><code class="language-javascript">throttled.cancel = function() {
    clearTimeout(time);
    time = null;
    previous = 0;
}
</code></pre></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>