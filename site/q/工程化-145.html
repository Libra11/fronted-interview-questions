<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>实现 JS 沙盒的方式有哪些？ - 面试题刷题</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <meta name="description" content="&lt;p&gt;微前端已经成为前端领域比较火爆的话题，在技术方面，微前端有一个始终绕不过去的话题就是前端沙箱&lt;/p&gt;&lt;h3&gt;什么是沙箱&lt;/h3&gt;&lt;blockquote&gt;Sandboxie(又叫沙箱、沙盘)即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以" />
  <link rel="icon" href="../assets/favicon.svg" />
  <style>.content a{color:var(--brand);} .content img{max-width:100%;}</style>
  
  <!-- Open Graph -->
  <meta property="og:title" content="实现 JS 沙盒的方式有哪些？" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="&lt;p&gt;微前端已经成为前端领域比较火爆的话题，在技术方面，微前端有一个始终绕不过去的话题就是前端沙箱&lt;/p&gt;&lt;h3&gt;什么是沙箱&lt;/h3&gt;&lt;blockquote&gt;Sandboxie(又叫沙箱、沙盘)即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 在网络安全中，沙箱指在隔" />
  <meta property="og:locale" content="zh_CN" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="logo" href="../index.html">面试题刷题</a>
      <nav class="nav">
        <a href="../index.html">首页</a>
        <a href="../index.html#categories">分类</a>
        <a href="https://github.com/pro-collection/interview-question/issues/145" target="_blank" rel="noopener">原始链接</a>
      </nav>
    </div>
  </header>
  <main class="container article">
    <div class="article-head">
      <a class="back" href="../index.html">← 返回列表</a>
      <h1>实现 JS 沙盒的方式有哪些？</h1>
      <div class="subtitle">工程化 · 工程化</div>
      <div class="meta">创建：2023-03-23T16:44:40Z · 更新：2023-03-23T16:45:35Z</div>
    </div>
    <article class="content markdown-body"><p>微前端已经成为前端领域比较火爆的话题，在技术方面，微前端有一个始终绕不过去的话题就是前端沙箱</p><h3>什么是沙箱</h3><blockquote>Sandboxie(又叫沙箱、沙盘)即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 在网络安全中，沙箱指在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具</blockquote><p>简单来说沙箱（sandbox）就是与外界隔绝的一个环境，内外环境互不影响，外界无法修改该环境内任何信息，沙箱内的东西单独属于一个世界。</p><h3>JavaScript 的沙箱</h3><p>对于 JavaScript 来说，沙箱并非传统意义上的沙箱，它只是一种语法上的 Hack 写法，沙箱是一种安全机制，把一些不信任的代码运行在沙箱之内，使其不能访问沙箱之外的代码。当需要解析或着执行不可信的 JavaScript 的时候，需要隔离被执行代码的执行环境的时候，需要对执行代码中可访问对象进行限制，通常开始可以把 JavaScript 中处理模块依赖关系的闭包称之为沙箱。</p><h3>JavaScript 沙箱实现</h3><p>我们大致可以把沙箱的实现总体分为两个部分：</p><ul><li>构建一个闭包环境</li><li>模拟原生浏览器对象</li></ul><h3>构建闭包环境</h3><p>我们知道 JavaScript 中，关于作用域（scope）,只有全局作用域（global scope）、函数作用域（function scope）以及从 ES6 开始才有的块级作用域（block scope）。如果要将一段代码中的变量、函数等的定义隔离出来，受限于 JavaScript 对作用域的控制，只能将这段代码封装到一个 Function 中，通过使用 function scope 来达到作用域隔离的目的。也因为需要这种使用函数来达到作用域隔离的目的方式，于是就有 IIFE（立即调用函数表达式）,这是一个被称为 自执行匿名函数的设计模式</p><pre class="code-block"><code class="language-javascript"> (function foo(){
    var a = 1;
    console.log(a);
 })();
 // 无法从外部访问变量 name
console.log(a) // 抛出错误：&quot;Uncaught ReferenceError: a is not defined&quot;

</code></pre><p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问，它拥有独立的词法作用域。不仅避免了外界访问 IIFE 中的变量，而且又不会污染全局作用域，弥补了 JavaScript 在 scope 方面的缺陷。一般常见于写插件和类库时，如 JQuery 当中的沙箱模式</p><pre class="code-block"><code class="language-javascript">(function (window) {
    var jQuery = function (selector, context) {
        return new jQuery.fn.init(selector, context);
    }
    jQuery.fn = jQuery.prototype = function () {
        //原型上的方法，即所有jQuery对象都可以共享的方法和属性
    }
    jQuery.fn.init.prototype = jQuery.fn;
    window.jQeury = window.$ = jQuery; //如果需要在外界暴露一些属性或者方法，可以将这些属性和方法加到window全局对象上去
})(window);

</code></pre><p>当将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p><pre class="code-block"><code class="language-ini">var result = (function () {
    var name = &quot;张三&quot;;
    return name;
})();
console.log(result); // &quot;张三&quot;

</code></pre><h3>原生浏览器对象的模拟</h3><p>模拟原生浏览器对象的目的是为了，防止闭包环境，操作原生对象。篡改污染原生环境；完成模拟浏览器对象之前我们需要先关注几个不常用的 API。</p><h4>eval</h4><p>eval 函数可将字符串转换为代码执行，并返回一个或多个值</p><pre class="code-block"><code class="language-css">   var b = eval(&quot;({name:&#39;张三&#39;})&quot;)
   console.log(b.name);

</code></pre><p>由于 eval 执行的代码可以访问闭包和全局范围，因此就导致了代码注入的安全问题，因为代码内部可以沿着作用域链往上找，篡改全局变量，这是我们不希望的</p><h4>new Function</h4><p>Function 构造函数创建一个新的 Function 对象。直接调用这个构造函数可用动态创建函数</p><blockquote>语法</blockquote><p><code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code></p><p><strong>arg1, arg2, ... argN</strong> 被函数使用的参数的名称必须是合法命名的。参数名称是一个有效的 JavaScript 标识符的字符串，或者一个用逗号分隔的有效字符串的列表;例如“×”，“theValue”，或“a,b”。</p><p><strong>functionBody</strong> 一个含有包括函数定义的 JavaScript 语句的字符串。</p><pre class="code-block"><code class="language-javascript">const sum = new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;);

console.log(sum(1, 2));//3

</code></pre><p>同样也会遇到和 eval 类似的的安全问题和相对较小的性能问题。</p><pre class="code-block"><code class="language-javascript">var a = 1;

function sandbox() {
    var a = 2;
    return new Function(&#39;return a;&#39;); // 这里的 a 指向最上面全局作用域内的 1
}
var f = sandbox();
console.log(f())

</code></pre><p>与 eval 不同的是 Function 创建的函数只能在全局作用域中运行。它无法访问局部闭包变量，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造器创建时所在的作用域的变量；但是，它仍然可以访问全局范围。new Function()是 eval()更好替代方案。它具有卓越的性能和安全性，但仍没有解决访问全局的问题。</p><h3>with</h3><p>with 是 JavaScript 中一个关键字,扩展一个语句的作用域链。它允许半沙盒执行。那什么叫半沙盒？语句将某个对象添加到作用域链的顶部，如果在沙盒中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出 ReferenceError。</p><pre class="code-block"><code class="language-javascript">function sandbox(o) {
    with (o){
        //a=5; 
        c=2;
        d=3;
        console.log(a,b,c,d); // 0,1,2,3 //每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。
    }

}
var f = {
    a:0,
    b:1
}
sandbox(f);
console.log(f);
console.log(c,d); // 2,3 c、d被泄露到window对象上

</code></pre><p>究其原理，<code>with</code>在内部使用<code>in</code>运算符。对于块内的每个变量访问，它都在沙盒条件下计算变量。如果条件是 true，它将从沙盒中检索变量。否则，就在全局范围内查找变量。但是 with 语句使程序在查找变量值时，都是先在指定的对象中查找。所以对于那些本来不是这个对象的属性的变量，查找起来会很慢，对于有性能要求的程序不适合（JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。）。with 也会导致数据泄漏(在非严格模式下，会自动在全局作用域创建一个全局变量)</p><h3>in 运算符</h3><blockquote>in 运算符能够检测左侧操作数是否为右侧操作数的成员。其中，左侧操作数是一个字符串，或者可以转换为字符串的表达式，右侧操作数是一个对象或数组。</blockquote><pre class="code-block"><code class="language-javascript">var o = {
    a : 1,
    b : function() {}
}
console.log(&quot;a&quot; in o);  //true
console.log(&quot;b&quot; in o);  //true
console.log(&quot;c&quot; in o);  //false
console.log(&quot;valueOf&quot; in o);  //返回true，继承Object的原型方法
console.log(&quot;constructor&quot; in o);  //返回true，继承Object的原型属性

</code></pre><h3>with + new Function</h3><p>配合 with 用法可以稍微限制沙盒作用域，先从当前的 with 提供对象查找，但是如果查找不到依然还能从上获取，污染或篡改全局环境。</p><pre class="code-block"><code class="language-javascript">function sandbox (src) {
    src = &#39;with (sandbox) {&#39; + src + &#39;}&#39;
    return new Function(&#39;sandbox&#39;, src)
}
var str = &#39;let a = 1;window.name=&quot;张三&quot;;console.log(a);console.log(b)&#39;
var b = 2
sandbox(str)({});
console.log(window.name);//&#39;张三&#39;

</code></pre><h3>基于 Proxy 实现的沙箱(ProxySandbox)</h3><p>由上部分内容思考,假如可以做到在使用<code>with</code>对于块内的每个变量访问都限制在沙盒条件下计算变量，从沙盒中检索变量。那么是否可以完美的解决JavaScript沙箱机制。</p><p>使用 with 再加上 proxy 实现 JavaScript 沙箱</p><blockquote>ES6 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，属于一种“元编程”（meta programming）</blockquote><pre class="code-block"><code class="language-javascript">function sandbox(code) {
    code = &#39;with (sandbox) {&#39; + code + &#39;}&#39;
    const fn = new Function(&#39;sandbox&#39;, code)

    return function (sandbox) {
        const sandboxProxy = new Proxy(sandbox, {
            has(target, key) {
                return true
            }
        })
        return fn(sandboxProxy)
    }
}
var a = 1;
var code = &#39;console.log(a)&#39; // TypeError: Cannot read property &#39;log&#39; of undefined
sandbox(code)({})

</code></pre><p>我们前面提到<code>with</code>在内部使用<code>in</code>运算符来计算变量，如果条件是 true，它将从沙盒中检索变量。理想状态下没有问题，但也总有些特例独行的存在，比如 Symbol.unscopables。</p><p><strong>Symbol.unscopables</strong></p><blockquote>Symbol.unscopables 对象的 Symbol.unscopables 属性，指向一个对象。该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。</blockquote><pre class="code-block"><code class="language-javascript">Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;keys&#39;]

</code></pre><p>由此我们的代码还需要修改如下：</p><pre class="code-block"><code class="language-javascript">function sandbox(code) {
    code = &#39;with (sandbox) {&#39; + code + &#39;}&#39;
    const fn = new Function(&#39;sandbox&#39;, code)

    return function (sandbox) {
        const sandboxProxy = new Proxy(sandbox, {
            has(target, key) {
                return true
            },
            get(target, key) {
                if (key === Symbol.unscopables) return undefined
                return target[key]
            }
        })
        return fn(sandboxProxy)
    }
}
var test = {
    a: 1,
    log(){
        console.log(&#39;11111&#39;)
    }
}
var code = &#39;log();console.log(a)&#39; // 1111,TypeError: Cannot read property &#39;log&#39; of undefined
sandbox(code)(test)

</code></pre><p>Symbol.unscopables 定义对象的不可作用属性。Unscopeable 属性永远不会从 with 语句中的沙箱对象中检索，而是直接从闭包或全局范围中检索。</p><h3>快照沙箱(SnapshotSandbox)</h3><p>以下是 qiankun 的 snapshotSandbox 的源码，这里为了帮助理解做部分精简及注释。</p><pre class="code-block"><code class="language-javascript">function iter(obj, callbackFn) {
    for (const prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            callbackFn(prop);
        }
    }
}

/**
 * 基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器
 */
class SnapshotSandbox {
    constructor(name) {
        this.name = name;
        this.proxy = window;
        this.type = &#39;Snapshot&#39;;
        this.sandboxRunning = true;
        this.windowSnapshot = {};
        this.modifyPropsMap = {};
        this.active();
    }
    //激活
    active() {
        // 记录当前快照
        this.windowSnapshot = {};
        iter(window, (prop) =&gt; {
            this.windowSnapshot[prop] = window[prop];
        });

        // 恢复之前的变更
        Object.keys(this.modifyPropsMap).forEach((p) =&gt; {
            window[p] = this.modifyPropsMap[p];
        });

        this.sandboxRunning = true;
    }
    //还原
    inactive() {
        this.modifyPropsMap = {};

        iter(window, (prop) =&gt; {
            if (window[prop] !== this.windowSnapshot[prop]) {
                // 记录变更，恢复环境
                this.modifyPropsMap[prop] = window[prop];

                window[prop] = this.windowSnapshot[prop];
            }
        });
        this.sandboxRunning = false;
    }
}
let sandbox = new SnapshotSandbox();
//test
((window) =&gt; {
    window.name = &#39;张三&#39;
    window.age = 18
    console.log(window.name, window.age) //	张三,18
    sandbox.inactive() //	还原
    console.log(window.name, window.age) //	undefined,undefined
    sandbox.active() //	激活
    console.log(window.name, window.age) //	张三,18
})(sandbox.proxy);

</code></pre><p>快照沙箱实现来说比较简单，主要用于不支持 Proxy 的低版本浏览器，原理是基于<code>diff</code>来实现的,在子应用激活或者卸载时分别去通过快照的形式记录或还原状态来实现沙箱，snapshotSandbox 会污染全局 window。</p><h3>legacySandBox</h3><p>qiankun 框架 singular 模式下 proxy 沙箱实现，为了便于理解，这里做了部分代码的精简和注释。</p><pre class="code-block"><code class="language-javascript">//legacySandBox
const callableFnCacheMap = new WeakMap();

function isCallable(fn) {
  if (callableFnCacheMap.has(fn)) {
    return true;
  }
  const naughtySafari = typeof document.all === &#39;function&#39; &amp;&amp; typeof document.all === &#39;undefined&#39;;
  const callable = naughtySafari ? typeof fn === &#39;function&#39; &amp;&amp; typeof fn !== &#39;undefined&#39; : typeof fn ===
    &#39;function&#39;;
  if (callable) {
    callableFnCacheMap.set(fn, callable);
  }
  return callable;
};

function isPropConfigurable(target, prop) {
  const descriptor = Object.getOwnPropertyDescriptor(target, prop);
  return descriptor ? descriptor.configurable : true;
}

function setWindowProp(prop, value, toDelete) {
  if (value === undefined &amp;&amp; toDelete) {
    delete window[prop];
  } else if (isPropConfigurable(window, prop) &amp;&amp; typeof prop !== &#39;symbol&#39;) {
    Object.defineProperty(window, prop, {
      writable: true,
      configurable: true
    });
    window[prop] = value;
  }
}


function getTargetValue(target, value) {
  /*
    仅绑定 isCallable &amp;&amp; !isBoundedFunction &amp;&amp; !isConstructable 的函数对象，如 window.console、window.atob 这类。目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断
    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）
   */
  if (isCallable(value) &amp;&amp; !isBoundedFunction(value) &amp;&amp; !isConstructable(value)) {
    const boundValue = Function.prototype.bind.call(value, target);
    for (const key in value) {
      boundValue[key] = value[key];
    }
    if (value.hasOwnProperty(&#39;prototype&#39;) &amp;&amp; !boundValue.hasOwnProperty(&#39;prototype&#39;)) {
      Object.defineProperty(boundValue, &#39;prototype&#39;, {
        value: value.prototype,
        enumerable: false,
        writable: true
      });
    }

    return boundValue;
  }

  return value;
}

/**
 * 基于 Proxy 实现的沙箱
 */
class SingularProxySandbox {
  /** 沙箱期间新增的全局变量 */
  addedPropsMapInSandbox = new Map();

  /** 沙箱期间更新的全局变量 */
  modifiedPropsOriginalValueMapInSandbox = new Map();

  /** 持续记录更新的(新增和修改的)全局变量的 map，用于在任意时刻做 snapshot */
  currentUpdatedPropsValueMap = new Map();

  name;

  proxy;

  type = &#39;LegacyProxy&#39;;

  sandboxRunning = true;

  latestSetProp = null;

  active() {
    if (!this.sandboxRunning) {
      this.currentUpdatedPropsValueMap.forEach((v, p) =&gt; setWindowProp(p, v));
    }

    this.sandboxRunning = true;
  }

  inactive() {
    // console.log(&#39; this.modifiedPropsOriginalValueMapInSandbox&#39;, this.modifiedPropsOriginalValueMapInSandbox)
    // console.log(&#39; this.addedPropsMapInSandbox&#39;, this.addedPropsMapInSandbox)
    //删除添加的属性，修改已有的属性
    this.modifiedPropsOriginalValueMapInSandbox.forEach((v, p) =&gt; setWindowProp(p, v));
    this.addedPropsMapInSandbox.forEach((_, p) =&gt; setWindowProp(p, undefined, true));

    this.sandboxRunning = false;
  }

  constructor(name) {
    this.name = name;
    const {
      addedPropsMapInSandbox,
      modifiedPropsOriginalValueMapInSandbox,
      currentUpdatedPropsValueMap
    } = this;

    const rawWindow = window;
    //Object.create(null)的方式，传入一个不含有原型链的对象
    const fakeWindow = Object.create(null);

    const proxy = new Proxy(fakeWindow, {
      set: (_, p, value) =&gt; {
        if (this.sandboxRunning) {
          if (!rawWindow.hasOwnProperty(p)) {
            addedPropsMapInSandbox.set(p, value);
          } else if (!modifiedPropsOriginalValueMapInSandbox.has(p)) {
            // 如果当前 window 对象存在该属性，且 record map 中未记录过，则记录该属性初始值
            const originalValue = rawWindow[p];
            modifiedPropsOriginalValueMapInSandbox.set(p, originalValue);
          }

          currentUpdatedPropsValueMap.set(p, value);
          // 必须重新设置 window 对象保证下次 get 时能拿到已更新的数据
          rawWindow[p] = value;

          this.latestSetProp = p;

          return true;
        }

        // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误
        return true;
      },

      get(_, p) {
        //避免使用 window.window 或者 window.self 逃离沙箱环境，触发到真实环境
        if (p === &#39;top&#39; || p === &#39;parent&#39; || p === &#39;window&#39; || p === &#39;self&#39;) {
          return proxy;
        }
        const value = rawWindow[p];
        return getTargetValue(rawWindow, value);
      },

      has(_, p) { //返回boolean
        return p in rawWindow;
      },

      getOwnPropertyDescriptor(_, p) {
        const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);
        // 如果属性不作为目标对象的自身属性存在，则不能将其设置为不可配置
        if (descriptor &amp;&amp; !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      },
    });

    this.proxy = proxy;
  }
}

let sandbox = new SingularProxySandbox();

((window) =&gt; {
  window.name = &#39;张三&#39;;
  window.age = 18;
  window.sex = &#39;男&#39;;
  console.log(window.name, window.age,window.sex) //	张三,18,男
  sandbox.inactive() //	还原
  console.log(window.name, window.age,window.sex) //	张三,undefined,undefined
  sandbox.active() //	激活
  console.log(window.name, window.age,window.sex) //	张三,18,男
})(sandbox.proxy); //test

</code></pre><p>legacySandBox 还是会操作 window 对象，但是他通过激活沙箱时还原子应用的状态，卸载时还原主应用的状态来实现沙箱隔离的，同样会对 window 造成污染，但是性能比快照沙箱好，不用遍历 window 对象。</p><h3>proxySandbox(多例沙箱)</h3><p>在 qiankun 的沙箱 proxySandbox 源码里面是对 fakeWindow 这个对象进行了代理，而这个对象是通过 createFakeWindow 方法得到的，这个方法是将 window 的 document、location、top、window 等等属性拷贝一份，给到 fakeWindow。</p><p>源码展示：</p><pre class="code-block"><code class="language-javascript">
function createFakeWindow(global: Window) {
  // map always has the fastest performance in has check scenario
  // see https://jsperf.com/array-indexof-vs-set-has/23
  const propertiesWithGetter = new Map&lt;PropertyKey, boolean&gt;();
  const fakeWindow = {} as FakeWindow;

  /*
   copy the non-configurable property of global to fakeWindow
   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor
   &gt; A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.
   */
  Object.getOwnPropertyNames(global)
    .filter((p) =&gt; {
      const descriptor = Object.getOwnPropertyDescriptor(global, p);
      return !descriptor?.configurable;
    })
    .forEach((p) =&gt; {
      const descriptor = Object.getOwnPropertyDescriptor(global, p);
      if (descriptor) {
        const hasGetter = Object.prototype.hasOwnProperty.call(descriptor, &#39;get&#39;);

        /*
         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.
         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get
         &gt; The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.
         */
        if (
          p === &#39;top&#39; ||
          p === &#39;parent&#39; ||
          p === &#39;self&#39; ||
          p === &#39;window&#39; ||
          (process.env.NODE_ENV === &#39;test&#39; &amp;&amp; (p === &#39;mockTop&#39; || p === &#39;mockSafariTop&#39;))
        ) {
          descriptor.configurable = true;
          /*
           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was
           Example:
            Safari/FF: Object.getOwnPropertyDescriptor(window, &#39;top&#39;) -&gt; {get: function, set: undefined, enumerable: true, configurable: false}
            Chrome: Object.getOwnPropertyDescriptor(window, &#39;top&#39;) -&gt; {value: Window, writable: false, enumerable: true, configurable: false}
           */
          if (!hasGetter) {
            descriptor.writable = true;
          }
        }

        if (hasGetter) propertiesWithGetter.set(p, true);

        // freeze the descriptor to avoid being modified by zone.js
        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71
        rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));
      }
    });

  return {
    fakeWindow,
    propertiesWithGetter,
  };
}

</code></pre><p>proxySandbox 由于是拷贝复制了一份 fakeWindow，不会污染全局 window，同时支持多个子应用同时加载。 详细源码请查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Fsandbox%2FproxySandbox.ts %22https://github.com/umijs/qiankun/blob/master/src/sandbox/proxySandbox.ts%22" target="_blank" rel="noopener">：proxySandbox</a></p><h3>关于 CSS 隔离</h3><p>常见的有：</p><ul><li>CSS Module</li><li>namespace</li><li>Dynamic StyleSheet</li><li>css in js</li><li>Shadow DOM 常见的我们这边不再赘述，这里我们重点提一下Shadow DO。</li></ul><h3>Shadow DOM</h3><p>Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。</p></article>
  </main>
  <footer class="site-footer">© 面试题刷题 · 由本地静态页面生成</footer>
</body>
</html>